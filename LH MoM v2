rankMetric,
IF(
  TRIM(mvSel)="Exit (ex-Auto)",
  ABS(IFERROR(--f_delta,0)),
  IFERROR(--f_ssb,0)
),





=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  bank,  CHOOSECOLS(t, XMATCH("Bank_For_Event", hdr)),
  fac,   CHOOSECOLS(t, XMATCH("Facility_For_Event", hdr)),
  own,   CHOOSECOLS(t, XMATCH("Owner_For_Event", hdr)),
  mv,    CHOOSECOLS(t, XMATCH("Movement_Type", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Reviewable_Flag", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("SSB_For_Event", hdr)),
  delta, CHOOSECOLS(t, XMATCH("MoM_Delta", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f, IFERROR(FILTER(t, keep), ""),
  f_ssb, IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  rankMetric, IF(mvSel="Exit (ex-Auto)", ABS(f_delta), f_ssb),

  IF(f="","No matches for the selected Owner/Movement_Type (or Reviewable_Flag not = 1).",
     TAKE(SORTBY(HSTACK(f, rankMetric), rankMetric, -1), 30)
  )
)






=LET(
  t, tbl_Facility_Rollup,
  bank, CHOOSECOLS(t,1),
  fac,  CHOOSECOLS(t,2),
  own,  CHOOSECOLS(t,3),
  mv,   CHOOSECOLS(t,4),
  rev,  CHOOSECOLS(t,5),
  ssb,  CHOOSECOLS(t,6),
  delta,CHOOSECOLS(t,7),

  ownerSel, $B$2,
  mvSel, $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),
  f, FILTER(t, keep),

  f_ssb,  FILTER(ssb, keep),
  f_delta,FILTER(delta, keep),

  rankMetric, IF(mvSel="Exit (ex-Auto)", ABS(f_delta), f_ssb),
  sorted, SORTBY(f, rankMetric, -1),
  TAKE(HSTACK(sorted, rankMetric), 30)
)





=LET(
  t, tbl_Facility_Rollup,
  owner, $B$2,
  mv, $B$3,
  f, FILTER(t, (t[Owner_For_Event]=owner)*(t[Movement_Type]=mv)*(t[Reviewable_Flag]>=1)),
  rankMetric, IF(mv="Exit (ex-Auto)", ABS(INDEX(f[MoM_Delta],0)), INDEX(f[SSB_For_Event],0)),
  sorted, SORTBY(f, rankMetric, -1),
  TAKE(HSTACK(sorted, rankMetric), 30)
)







/* ================================== Query 1: MoM_Account_Detail (incl. negatives, charge-offs, status)
   UPDATED:
   - Movement_Type classified at FACILITY level (stamped onto all Account_Key rows)
   - Reviewable_Flag classified at FACILITY level (stamped onto all Account_Key rows)
   - Facility Owner logic with deterministic pick (largest |SSB_For_Event| account), with hard override:
       Daniel gets EVERYTHING where Contract_Source_System = 'INFL10'
   - Presence tests use SUM(ABS(SSB)) to avoid net-to-zero masking
   - Reviewable exposure tests use SUM(positive SSB) as discussed
   Grain of final output remains ACCOUNT_KEY
======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags (account-level) */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags (account-level) */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Pos→Neg Flip'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Neg→Pos Flip'
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Δ'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Δ'
      ELSE NULL
    END AS Negative_Class

  FROM joined j
),

/* CIS totals (account-level window, as-is) */
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
),

/* Event-scoped fields (same logic you had in final SELECT, moved earlier so we can roll up at facility level) */
event_scoped AS (
  SELECT
    w.*,

    /* Account_Name for the “event” side (curr if exists, else prev) */
    CASE
      WHEN w.has_curr=1 THEN w.Curr_Account_Name
      WHEN w.had_prev=1 THEN w.Prev_Account_Name
      ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
    END AS Account_Name_For_Event,

    /* event scoping */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
      WHEN w.has_curr=1 THEN w.Curr_Bank_Code
      ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
    END AS Bank_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
      WHEN w.has_curr=1 THEN w.Curr_Facility_ID
      ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
    END AS Facility_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
      WHEN w.has_curr=1 THEN w.Curr_CIS
      ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
    END AS CIS_For_Event,

    /* choose event-side CSS/PROD/BANK/RBC for downstream owner logic */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CSS
      WHEN w.has_curr=1 THEN w.Curr_CSS
      ELSE COALESCE(w.Curr_CSS, w.Prev_CSS)
    END AS CSS_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_PROD5
      WHEN w.has_curr=1 THEN w.Curr_PROD5
      ELSE COALESCE(w.Curr_PROD5, w.Prev_PROD5)
    END AS PROD5_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_RBC
      WHEN w.has_curr=1 THEN w.Curr_RBC
      ELSE COALESCE(w.Curr_RBC, w.Prev_RBC)
    END AS RBC_For_Event,

    /* balances */
    (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,

    CASE
      WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
      ELSE COALESCE(w.Prev_SSB,0)
    END AS SSB_For_Event
  FROM with_cis w
),

/* Account-level owner (event-side) with Daniel override moved to the top */
account_owner_event AS (
  SELECT
    e.*,

    CASE
      WHEN e.CSS_For_Event = 'INFL10' THEN 'Daniel'  /* HARD OVERRIDE */
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
      WHEN e.Bank_For_Event='L-SVB' THEN 'Eleanor'
      WHEN UPPER(COALESCE(e.RBC_For_Event,''))='R' THEN 'Autochange'
      WHEN e.Bank_For_Event='L-FCB' THEN 'Connor'
      ELSE 'NOT COVERED'
    END AS Owner_Account_For_Event
  FROM event_scoped e
),

/* Rank accounts within facility to pick representative attributes (largest |SSB_For_Event|) */
ranked_in_facility AS (
  SELECT
    a.*,
    ROW_NUMBER() OVER (
      PARTITION BY a.Bank_For_Event, a.Facility_For_Event
      ORDER BY ABS(COALESCE(a.SSB_For_Event,0)) DESC, a.Account_Key
    ) AS rn_fac
  FROM account_owner_event a
),

/* Facility rollup + facility-level classification + facility owner */
facility_rollup AS (
  SELECT
    Bank_For_Event,
    Facility_For_Event,

    /* Presence tests (avoid net-to-zero masking) */
    SUM(ABS(COALESCE(Prev_SSB,0))) AS Fac_Prev_Abs_SSB,
    SUM(ABS(COALESCE(Curr_SSB,0))) AS Fac_Curr_Abs_SSB,

    /* Positive exposure tests (reviewable gating) */
    SUM(CASE WHEN COALESCE(Prev_SSB,0) > 0 THEN COALESCE(Prev_SSB,0) ELSE 0 END) AS Fac_Prev_Pos_SSB,
    SUM(CASE WHEN COALESCE(Curr_SSB,0) > 0 THEN COALESCE(Curr_SSB,0) ELSE 0 END) AS Fac_Curr_Pos_SSB,

    /* Net balances for delta-based “persisting change” */
    SUM(COALESCE(Prev_SSB,0)) AS Fac_Prev_Net_SSB,
    SUM(COALESCE(Curr_SSB,0)) AS Fac_Curr_Net_SSB,

    /* Facility-level auto flags: ANY auto within facility */
    MAX(CASE WHEN UPPER(COALESCE(Prev_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Prev_Auto_Any,
    MAX(CASE WHEN UPPER(COALESCE(Curr_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Curr_Auto_Any,

    /* Daniel override: ANY INFL10 in facility => Daniel */
    MAX(CASE WHEN CSS_For_Event='INFL10' THEN 1 ELSE 0 END) AS Fac_INFL10_Any,

    /* Representative attributes from top |SSB_For_Event| row */
    MAX(CASE WHEN rn_fac=1 THEN CIS_For_Event END)         AS Fac_CIS_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN PROD5_For_Event END)       AS Fac_PROD5_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN RBC_For_Event END)         AS Fac_RBC_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN Owner_Account_For_Event END) AS Fac_Owner_From_TopRow,

    /* Representative CIS totals from top row (used in threshold exclusions) */
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Curr_CIS_SSB,0) END) AS Fac_Curr_CIS_SSB,
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Prev_CIS_SSB,0) END) AS Fac_Prev_CIS_SSB

  FROM ranked_in_facility
  GROUP BY Bank_For_Event, Facility_For_Event
),

facility_classified AS (
  SELECT
    fr.*,

    /* facility presence flags */
    CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Had_Prev,
    CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Has_Curr,

    /* facility owner for event */
    CASE
      WHEN fr.Fac_INFL10_Any = 1 THEN 'Daniel'
      ELSE COALESCE(fr.Fac_Owner_From_TopRow, 'NOT COVERED')
    END AS Owner_Facility_For_Event,

    /* FACILITY-level Movement_Type */
    CASE
      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
        THEN 'Autochange Downgrade IN'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
        THEN 'Autochange Exit'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange Persisting Balance Changes'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange No Change'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
        THEN 'Downgrade IN (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
        THEN 'Exit (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Persisting Balance Changes (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'No Change (ex-Auto)'

      ELSE NULL
    END AS Movement_Type_Facility,

    /* FACILITY-level Reviewable_Flag (stamped down) */
    CASE
      WHEN (
        /* only these two types are review-queued */
        (CASE
           WHEN (
             CASE
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
               THEN 'Downgrade IN (ex-Auto)'
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
               THEN 'Exit (ex-Auto)'
               ELSE NULL
             END
           ) IS NOT NULL THEN 1 ELSE 0
         END)=1

        AND (
          /* positive exposure must exist on relevant side */
          ( ( /* Downgrade IN */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Curr_Pos_SSB,0) > 0
            )
            OR
            ( /* Exit */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Prev_Pos_SSB,0) > 0
            )
          )
        )

        AND (
          /* exclusions (mirror your prior logic, applied at facility rep-level) */
          CASE
            /* Downgrade IN exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END

            /* Exit exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END
            ELSE 0
          END = 1
        )
      )
      THEN 1 ELSE 0
    END AS Reviewable_Flag_Facility

  FROM facility_rollup fr
)

/* =========================
   FINAL OUTPUT (ACCOUNT_KEY grain)
   - Movement_Type now = facility-level Movement_Type_Facility
   - Owner_For_Event now = facility-level Owner_Facility_For_Event
   - Reviewable_Flag now = facility-level Reviewable_Flag_Facility
   - Owner_Curr / Owner_Prev also updated so Daniel override is absolute
========================= */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  a.Account_Key,

  /* prev attributes */
  a.Prev_Account_Identifier,
  a.Prev_Facility_ID,
  a.Prev_CIS,
  a.Prev_Account_Name,
  a.Prev_CSS,
  a.Prev_PROD5,
  a.Prev_RBC,
  a.Prev_Status,
  a.Prev_GL_L4,
  a.Prev_Bank_Code,
  a.Prev_SSB,
  a.Prev_GL_Balance,
  a.Prev_CO_MTD,

  /* curr attributes */
  a.Curr_Account_Identifier,
  a.Curr_Facility_ID,
  a.Curr_CIS,
  a.Curr_Account_Name,
  a.Curr_CSS,
  a.Curr_PROD5,
  a.Curr_RBC,
  a.Curr_Status,
  a.Curr_GL_L4,
  a.Curr_Bank_Code,
  a.Curr_SSB,
  a.Curr_GL_Balance,
  a.Curr_CO_MTD,

  /* event-side display fields */
  a.Account_Name_For_Event,
  a.Bank_For_Event,
  a.Facility_For_Event,
  a.CIS_For_Event,

  /* balances */
  a.MoM_Delta,
  a.SSB_For_Event,

  /* FACILITY movement typing */
  fc.Movement_Type_Facility AS Movement_Type,

  /* Owners (Curr / Prev) with Daniel override absolute */
  CASE
    WHEN a.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Curr_RBC='R' THEN 'Autochange'
    WHEN a.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN a.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Prev_RBC='R' THEN 'Autochange'
    WHEN a.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* FACILITY owner for event */
  fc.Owner_Facility_For_Event AS Owner_For_Event,

  /* FACILITY reviewable flag */
  fc.Reviewable_Flag_Facility AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  a.Curr_CIS_SSB,
  a.Prev_CIS_SSB,
  a.Negative_Flag,
  a.Negative_Class,
  a.Negative_Flip_Flag

FROM ranked_in_facility a
JOIN facility_classified fc
  ON a.Bank_For_Event = fc.Bank_For_Event
 AND a.Facility_For_Event = fc.Facility_For_Event

/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(a.Prev_SSB,0) = 0 AND COALESCE(a.Curr_SSB,0) = 0)

ORDER BY a.Bank_For_Event, a.Facility_For_Event, a.Account_Key;








Below is my full query for the RC_Code analysis. I was wanting to run the model on one single RC_Code. Can you give me a version that only outputs the analysis for 1 single RC_Code that I will manually input? 

/* ========== RC_Code Anomaly Detection — REG12-only, Thresholded, PBI-safe ========== */
/* Key features:
   - Uses only 12-month regression per RC (no REG36, MA6, MA12, no seasonality)
   - Limits history (min_me) to control runtime
   - Applies exposure_min_for_model on latest balance
   - Adds TOTAL_PORTFOLIO pseudo-RC
   - Outputs PI bands, Severity_0_100, Persistent_Outlier_3of6, Reason_Code
   - Flags Is_Material_Residual_500M for |Residual| >= threshold
*/

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,            -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,   -- >= $1B latest
    500000000.0::FLOAT8                AS material_resid_threshold  -- >= $500M residual
),

/* 1) Base RC-level balances (time filtered) */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b,
       params p
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Portfolio total per month as pseudo-RC */
base_total AS (
  SELECT
    'TOTAL_PORTFOLIO'               AS RC_CODE,
    'Total Loans - Portfolio'       AS RC_DESCRIPTION,
    month_end,
    SUM(bal_num)::FLOAT8            AS bal_num
  FROM base_rc
  GROUP BY month_end
),

/* 3) Combine RC-level + portfolio-level */
base_all AS (
  SELECT * FROM base_rc
  UNION ALL
  SELECT * FROM base_total
),

/* 4) Latest month & latest exposure per RC */
latest_me AS (
  SELECT
    RC_CODE,
    MAX(month_end) AS max_me
  FROM base_all
  GROUP BY RC_CODE
),

latest_exp AS (
  SELECT
    b.RC_CODE,
    b.bal_num AS latest_bal
  FROM base_all b
  JOIN latest_me m
    ON m.RC_CODE = b.RC_CODE
   AND m.max_me  = b.month_end
),

/* 5) RCs that pass exposure threshold */
material_rc AS (
  SELECT
    e.RC_CODE
  FROM latest_exp e
  CROSS JOIN params p
  WHERE e.latest_bal >= p.exposure_min_for_model
),

/* 6) Filter base to material RCs + portfolio */
base AS (
  SELECT b.*
  FROM base_all b
  WHERE b.RC_CODE IN (SELECT RC_CODE FROM material_rc)
),

/* 7) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 8) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 9) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 10) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 11) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 12) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    -- residual distribution stats
    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    -- MoM distribution stats
    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    -- RMSE per RC (for PI bands)
    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 13) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 14) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 15) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 16) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 17) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 18) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  /* Flag big residuals */
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.RC_CODE, r.month_end;





/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE, LAST 12 MONTHS ONLY ========== */

WITH
/* 0) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR(50) AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Find the latest month_end for this RC (Total Loans only) */
rc_max_me AS (
  SELECT
    CAST(MAX(b.END_OF_MONTH_DATE) AS DATE) AS max_me
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.RC_CODE = m.manual_rc_code
),

/* 2) Base RC-level balances — ONLY last 12 months relative to max_me */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN manual_rc m
  CROSS JOIN rc_max_me mx
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.RC_CODE = m.manual_rc_code
    AND CAST(b.END_OF_MONTH_DATE AS DATE) >= ADD_MONTHS(mx.max_me, -11)
    AND CAST(b.END_OF_MONTH_DATE AS DATE) <= mx.max_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 3) Index per RC, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 4) REG12 parameters (computed on these 12 rows) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM idx_tm
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS forecast
  FROM idx_tm l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    f.*,
    t.prev_bal,
    t.pos3_count,

    (f.bal_num - f.forecast)::FLOAT8 AS Resid,
    ABS(f.bal_num - f.forecast)::FLOAT8 AS AbsResid,

    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      ELSE ABS(f.bal_num - t.prev_bal)
    END::FLOAT8 AS MoM_Abs,

    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
      ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(f.bal_num - f.forecast)) OVER (PARTITION BY f.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(f.bal_num - f.forecast)) OVER (PARTITION BY f.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN t.prev_bal IS NULL THEN NULL ELSE ABS(f.bal_num - t.prev_bal) END
    ) OVER (PARTITION BY f.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN t.prev_bal IS NULL THEN NULL ELSE ABS(f.bal_num - t.prev_bal) END
    ) OVER (PARTITION BY f.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN t.prev_bal IS NULL THEN NULL
        WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
        ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
      END
    ) OVER (PARTITION BY f.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN t.prev_bal IS NULL THEN NULL
        WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
        ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
      END
    ) OVER (PARTITION BY f.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (f.bal_num - f.forecast)*(f.bal_num - f.forecast) )
      OVER (PARTITION BY f.RC_CODE)
    ) AS rmse
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 8) P95 AbsResid & MoM_Abs (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 9) Severity */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 10) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 11) Reason_Code */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code
FROM reasoned r
ORDER BY r.month_end;









/* ================================== Query 1: MoM_Account_Detail (incl. negatives, charge-offs, status) @ ACCOUNT_KEY grain ======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives (no SSB>0 filter) */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM NA-pop collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM NA-pop collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + CIS totals + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* ---- Negative logic ---- */
    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      /* 1) Positive → Negative flip */
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Pos→Neg Flip'

      /* 2) Negative → Positive flip */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Neg→Pos Flip'

      /* 3) New negative (no prior exposure, now negative) */
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'

      /* 4) Cleared negative (was negative, now zero) */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'

      /* 5) Persisting negative with delta */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Δ'

      /* 6) Persisting negative, no delta */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Δ'

      ELSE NULL
    END AS Negative_Class

  FROM joined j
  
),
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
)

/* 6) Final projection: includes Account_Name, negative flags, and filters out pure zero rows */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  w.Account_Key,

  /* prev attributes */
  w.Prev_Account_Identifier,
  w.Prev_Facility_ID,
  w.Prev_CIS,
  w.Prev_Account_Name,
  w.Prev_CSS,
  w.Prev_PROD5,
  w.Prev_RBC,
  w.Prev_Status,
  w.Prev_GL_L4,
  w.Prev_Bank_Code,
  w.Prev_SSB,
  w.Prev_GL_Balance,
  w.Prev_CO_MTD,

  /* curr attributes */
  w.Curr_Account_Identifier,
  w.Curr_Facility_ID,
  w.Curr_CIS,
  w.Curr_Account_Name,
  w.Curr_CSS,
  w.Curr_PROD5,
  w.Curr_RBC,
  w.Curr_Status,
  w.Curr_GL_L4,
  w.Curr_Bank_Code,
  w.Curr_SSB,
  w.Curr_GL_Balance,
  w.Curr_CO_MTD,

  /* Account_Name for the “event” side (curr if exists, else prev) */
  CASE
    WHEN w.has_curr=1 THEN w.Curr_Account_Name
    WHEN w.had_prev=1 THEN w.Prev_Account_Name
    ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
  END AS Account_Name_For_Event,

  /* event scoping (bank/facility/CIS for event) */
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
    WHEN w.has_curr=1 THEN w.Curr_Bank_Code
    ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
  END AS Bank_For_Event,
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
    WHEN w.has_curr=1 THEN w.Curr_Facility_ID
    ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
  END AS Facility_For_Event,
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
    WHEN w.has_curr=1 THEN w.Curr_CIS
    ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
  END AS CIS_For_Event,

  /* balances */
  (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,
  CASE
    WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
    ELSE COALESCE(w.Prev_SSB,0)
  END AS SSB_For_Event,

  /* movement typing */
  CASE
    WHEN w.had_prev=0 AND w.has_curr=1 AND w.curr_auto=1 THEN 'Autochange Downgrade IN'
    WHEN w.had_prev=1 AND w.has_curr=0 AND w.prev_auto=1 THEN 'Autochange Exit'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.prev_auto=1 AND w.curr_auto=1
         AND COALESCE(w.Curr_SSB,0)<>COALESCE(w.Prev_SSB,0) THEN 'Autochange Persisting Balance Changes'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.prev_auto=1 AND w.curr_auto=1
         AND COALESCE(w.Curr_SSB,0)= COALESCE(w.Prev_SSB,0) THEN 'Autochange No Change'
    WHEN w.had_prev=0 AND w.has_curr=1 AND w.curr_auto=0 THEN 'Downgrade IN (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=0 AND w.prev_auto=0 THEN 'Exit (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.curr_auto=0
         AND COALESCE(w.Curr_SSB,0)<>COALESCE(w.Prev_SSB,0) THEN 'Persisting Balance Changes (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.curr_auto=0
         AND COALESCE(w.Curr_SSB,0)= COALESCE(w.Prev_SSB,0) THEN 'No Change (ex-Auto)'
    ELSE NULL
  END AS Movement_Type,

  /* Owners w/ CIS thresholds */
  CASE
    WHEN w.Curr_PROD5='Business RE Term Loans'
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN w.Curr_PROD5='Business RE Term Loans'
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN w.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN w.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN w.Curr_RBC='R' THEN 'Autochange'
    WHEN w.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN w.Prev_PROD5='Business RE Term Loans'
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN w.Prev_PROD5='Business RE Term Loans'
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN w.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN w.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN w.Prev_RBC='R' THEN 'Autochange'
    WHEN w.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* Owner for event (for bridges / Top 30 by owner) */
  CASE
    WHEN w.has_curr=1 THEN
      CASE
        WHEN w.Curr_PROD5='Business RE Term Loans'
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
        WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
        WHEN w.Curr_PROD5='Business RE Term Loans'
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
        WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
        WHEN w.Curr_CSS='INFL10' THEN 'Daniel'
        WHEN w.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
        WHEN w.Curr_RBC='R' THEN 'Autochange'
        WHEN w.Curr_Bank_Code='L-FCB' THEN 'Connor'
        ELSE 'NOT COVERED'
      END
    WHEN w.had_prev=1 THEN
      CASE
        WHEN w.Prev_PROD5='Business RE Term Loans'
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
        WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
        WHEN w.Prev_PROD5='Business RE Term Loans'
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
        WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
        WHEN w.Prev_CSS='INFL10' THEN 'Daniel'
        WHEN w.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
        WHEN w.Prev_RBC='R' THEN 'Autochange'
        WHEN w.Prev_Bank_Code='L-FCB' THEN 'Connor'
        ELSE 'NOT COVERED'
      END
    ELSE 'NOT COVERED'
  END AS Owner_For_Event,

  /* reviewable flag */
  CASE
    WHEN (
      (Movement_Type IN ('Downgrade IN (ex-Auto)','Exit (ex-Auto)')) AND
      (
        (Movement_Type='Downgrade IN (ex-Auto)' AND COALESCE(w.Curr_SSB,0) > 0) OR
        (Movement_Type='Exit (ex-Auto)'         AND COALESCE(w.Prev_SSB,0) > 0)
      ) AND
      (
        CASE
          WHEN Movement_Type='Downgrade IN (ex-Auto)' THEN
            CASE
              WHEN w.Curr_PROD5='Business RE Term Loans' AND w.Curr_Bank_Code='L-CIT' AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 0
              WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw') AND w.Curr_Bank_Code='L-CIT' AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 0
              WHEN w.Curr_RBC='R' THEN 0
              ELSE 1
            END
          WHEN Movement_Type='Exit (ex-Auto)' THEN
            CASE
              WHEN w.Prev_PROD5='Business RE Term Loans' AND w.Prev_Bank_Code='L-CIT' AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 0
              WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw') AND w.Prev_Bank_Code='L-CIT' AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 0
              WHEN w.Prev_RBC='R' THEN 0
              ELSE 1
            END
          ELSE 0
        END = 1
      )
    )
    THEN 1 ELSE 0
  END AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  w.Curr_CIS_SSB,
  w.Prev_CIS_SSB,
  w.Negative_Flag,
  w.Negative_Class,
  w.Negative_Flip_Flag

FROM with_cis w
/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(w.Prev_SSB,0) = 0 AND COALESCE(w.Curr_SSB,0) = 0)
ORDER BY Bank_For_Event, Facility_For_Event, Account_Key;









/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE (no thresholds) ========== */

WITH
/* 0) Minimal parameter: history window only */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me   -- last 72 months only
),

/* 0b) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Base RC-level balances (time filtered) — ONLY the selected RC_CODE */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN params p
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
    AND b.RC_CODE = m.manual_rc_code
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 3) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 4) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 8) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 9) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 10) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 11) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 12) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 13) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code
FROM reasoned r
ORDER BY r.month_end;











/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE (manual input) ========== */

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,                 -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,  -- kept for reference (not enforced)
    500000000.0::FLOAT8                AS material_resid_threshold -- >= $500M residual
),

/* 0b) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Base RC-level balances (time filtered) — ONLY the selected RC_CODE */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN params p
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
    AND b.RC_CODE = m.manual_rc_code
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 3) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 4) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 8) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 9) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 10) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 11) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 12) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 13) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.month_end;







/* ========== RC_Code Anomaly Detection — REG12-only, Thresholded, PBI-safe ========== */
/* Key features:
   - Uses only 12-month regression per RC (no REG36, MA6, MA12, no seasonality)
   - Limits history (min_me) to control runtime
   - Applies exposure_min_for_model on latest balance
   - Adds TOTAL_PORTFOLIO pseudo-RC
   - Outputs PI bands, Severity_0_100, Persistent_Outlier_3of6, Reason_Code
   - Flags Is_Material_Residual_500M for |Residual| >= threshold
*/

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,            -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,   -- >= $1B latest
    500000000.0::FLOAT8                AS material_resid_threshold  -- >= $500M residual
),

/* 1) Base RC-level balances (time filtered) */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b,
       params p
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Portfolio total per month as pseudo-RC */
base_total AS (
  SELECT
    'TOTAL_PORTFOLIO'               AS RC_CODE,
    'Total Loans - Portfolio'       AS RC_DESCRIPTION,
    month_end,
    SUM(bal_num)::FLOAT8            AS bal_num
  FROM base_rc
  GROUP BY month_end
),

/* 3) Combine RC-level + portfolio-level */
base_all AS (
  SELECT * FROM base_rc
  UNION ALL
  SELECT * FROM base_total
),

/* 4) Latest month & latest exposure per RC */
latest_me AS (
  SELECT
    RC_CODE,
    MAX(month_end) AS max_me
  FROM base_all
  GROUP BY RC_CODE
),

latest_exp AS (
  SELECT
    b.RC_CODE,
    b.bal_num AS latest_bal
  FROM base_all b
  JOIN latest_me m
    ON m.RC_CODE = b.RC_CODE
   AND m.max_me  = b.month_end
),

/* 5) RCs that pass exposure threshold */
material_rc AS (
  SELECT
    e.RC_CODE
  FROM latest_exp e
  CROSS JOIN params p
  WHERE e.latest_bal >= p.exposure_min_for_model
),

/* 6) Filter base to material RCs + portfolio */
base AS (
  SELECT b.*
  FROM base_all b
  WHERE b.RC_CODE IN (SELECT RC_CODE FROM material_rc)
),

/* 7) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 8) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 9) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 10) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 11) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 12) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    -- residual distribution stats
    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    -- MoM distribution stats
    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    -- RMSE per RC (for PI bands)
    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 13) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 14) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 15) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 16) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 17) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 18) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  /* Flag big residuals */
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.RC_CODE, r.month_end;






https://www.instagram.com/icestat_analytics?igsh=MW4xdTc3dWlsazBzag%3D%3D&utm_source=qr




import os
import pandas as pd
import numpy as np

pd.set_option("display.float_format", "${:,.2f}".format)

# --- USER INPUT ---
FILE_PATH  = "loan_extract.xlsx"    # or "loan_extract.csv" | "loan_extract.xlsb"
SHEET_NAME = 0
DATE_COL   = "END_OF_MONTH_DATE"
BANK_COL   = "BANK_CODE"
GL_COL     = "GL_ACCOUNT_HIER_LEVEL_4"
BAL_COL    = "GL_BALANCE"
MOM_$      = "MoM_GL_$"
MOM_PCT    = "MoM_GL_PCT"

REQUIRED = [DATE_COL, BANK_COL, GL_COL, BAL_COL, MOM_$, MOM_PCT]

# --- Load ---
def read_any(path, sheet=None, parse_dates=None):
    ext = os.path.splitext(path)[1].lower()
    if ext == ".csv":
        return pd.read_csv(path, parse_dates=parse_dates, infer_datetime_format=True)
    elif ext in [".xlsx", ".xls"]:
        return pd.read_excel(path, sheet_name=sheet, parse_dates=parse_dates, engine="openpyxl")
    elif ext == ".xlsb":
        return pd.read_excel(path, sheet_name=sheet, parse_dates=parse_dates, engine="pyxlsb")
    else:
        raise ValueError(f"Unsupported file extension: {ext}")

df = read_any(FILE_PATH, sheet=SHEET_NAME, parse_dates=[DATE_COL])
df.columns = [c.strip() for c in df.columns]

# --- Checks and cleanup ---
missing = [c for c in REQUIRED if c not in df.columns]
if missing:
    raise KeyError(f"Missing required columns: {missing}")

df[DATE_COL] = pd.to_datetime(df[DATE_COL], errors="coerce").dt.date
df[BAL_COL] = pd.to_numeric(df[BAL_COL], errors="coerce").fillna(0)
df[MOM_$] = pd.to_numeric(df[MOM_$], errors="coerce")
df[MOM_PCT] = pd.to_numeric(df[MOM_PCT], errors="coerce")

# --- Find the last 2 month-ends ---
all_dates = sorted([d for d in df[DATE_COL].dropna().unique()])
if len(all_dates) < 2:
    raise ValueError("Less than 2 distinct month-end dates in data.")
prior_eom, current_eom = all_dates[-2], all_dates[-1]

# --- Subsets for the two months ---
cur = df[df[DATE_COL] == current_eom].copy()
prev = df[df[DATE_COL] == prior_eom].copy()

# --- Join current and prior balances ---
joined = pd.merge(
    prev[[BANK_COL, GL_COL, BAL_COL]],
    cur[[BANK_COL, GL_COL, BAL_COL, MOM_$, MOM_PCT]],
    on=[BANK_COL, GL_COL],
    how="outer",
    suffixes=("_prior", "_current")
)

joined = joined.fillna(0)
joined.rename(columns={
    f"{BAL_COL}_prior":   "Prior_GL_BALANCE",
    f"{BAL_COL}_current": "Current_GL_BALANCE",
    MOM_$:                "MoM_GL_$",
    MOM_PCT:              "MoM_GL_PCT"
}, inplace=True)

# --- Display sample ---
print(f"Prior EOM:   {prior_eom}")
print(f"Current EOM: {current_eom}")
print("\n=== Sample joined table ===")
display(joined.head(20))

# --- Optional: pivot by GL then Bank ---
pivot_current = cur.pivot_table(
    index=GL_COL, columns=BANK_COL, values=BAL_COL, aggfunc="sum", fill_value=0
)
pivot_prior = prev.pivot_table(
    index=GL_COL, columns=BANK_COL, values=BAL_COL, aggfunc="sum", fill_value=0
)

print("\n=== Current month matrix (rows=GL, cols=Bank) ===")
display(pivot_current.head(10))
print("\n=== Prior month matrix (rows=GL, cols=Bank) ===")
display(pivot_prior.head(10))

# --- Save outputs ---
os.makedirs("outputs", exist_ok=True)
joined.to_csv("outputs/GL_balances_MoM_joined.csv", index=False)
pivot_current.to_csv("outputs/GL_balances_current_matrix.csv")
pivot_prior.to_csv("outputs/GL_balances_prior_matrix.csv")

print("\nFiles saved in ./outputs:")
print(" - GL_balances_MoM_joined.csv")
print(" - GL_balances_current_matrix.csv")
print(" - GL_balances_prior_matrix.csv")
