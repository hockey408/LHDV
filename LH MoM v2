      MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]






=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,3),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],        /* ACCOUNT_NAME */
      MoM_Account_Detail[PREV_CIS],                 /* CIS_CUSTOMER_NUMBER */
      MoM_Account_Detail[FACILITY_FOR_EVENT],       /* FACILITY_ID */
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],  /* ACCOUNT_IDENTIFIER */
      MoM_Account_Detail[ACCOUNT_KEY],              /* ACCOUNT_KEY */
      MoM_Account_Detail[PREV_BANK_CODE],           /* BANK_CODE */
      MoM_Account_Detail[PREV_CSS],                 /* CONTRACT_SOURCE_SYSTEM */
      MoM_Account_Detail[PREV_GL_L4],               /* GL_ACCOUNT_HIER_LEVEL_4 */
      MoM_Account_Detail[PREV_PROD5],               /* PROD_HIER_LEVEL_5 */
      MoM_Account_Detail[PREV_STATUS],              /* STATUS_CODE */
      MoM_Account_Detail[PREV_RBC],                 /* RBC_CODE */
      MoM_Account_Detail[PREV_SSB],                 /* SOURCE_SYSTEM_BALANCE */
      MoM_Account_Detail[PREV_GL_BALANCE]           /* GL_BALANCE */
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)






=LET(
  me, Top30_Engine!$B$1,
  topBlock, $R$50#,
  topFacilities, INDEX(topBlock,,3),

  acct_identifier, IF(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER]<>"",
                      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
                      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER]),

  bank_code, IF(MoM_Account_Detail[BANK_FOR_EVENT]<>"",
                MoM_Account_Detail[BANK_FOR_EVENT],
                IF(MoM_Account_Detail[CURR_BANK_CODE]<>"",
                   MoM_Account_Detail[CURR_BANK_CODE],
                   MoM_Account_Detail[PREV_BANK_CODE])),

  css, IF(MoM_Account_Detail[CURR_CSS]<>"", MoM_Account_Detail[CURR_CSS], MoM_Account_Detail[PREV_CSS]),
  gl4, IF(MoM_Account_Detail[CURR_GL_L4]<>"", MoM_Account_Detail[CURR_GL_L4], MoM_Account_Detail[PREV_GL_L4]),
  prod5, IF(MoM_Account_Detail[CURR_PROD5]<>"", MoM_Account_Detail[CURR_PROD5], MoM_Account_Detail[PREV_PROD5]),
  status, IF(MoM_Account_Detail[CURR_STATUS]<>"", MoM_Account_Detail[CURR_STATUS], MoM_Account_Detail[PREV_STATUS]),
  rbc, IF(MoM_Account_Detail[CURR_RBC]<>"", MoM_Account_Detail[CURR_RBC], MoM_Account_Detail[PREV_RBC]),
  gl_balance, IF(MoM_Account_Detail[CURR_GL_BALANCE]<>"", MoM_Account_Detail[CURR_GL_BALANCE], MoM_Account_Detail[PREV_GL_BALANCE]),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT],   /* ACCOUNT_NAME */
      MoM_Account_Detail[CIS_FOR_EVENT],            /* CIS_CUSTOMER_NUMBER */
      MoM_Account_Detail[FACILITY_FOR_EVENT],       /* FACILITY_ID */
      acct_identifier,                              /* ACCOUNT_IDENTIFIER */
      MoM_Account_Detail[ACCOUNT_KEY],              /* ACCOUNT_KEY */
      bank_code,                                    /* BANK_CODE */
      css,                                          /* CONTRACT_SOURCE_SYSTEM */
      gl4,                                          /* GL_ACCOUNT_HIER_LEVEL_4 */
      prod5,                                        /* PROD_HIER_LEVEL_5 */
      status,                                       /* STATUS_CODE */
      rbc,                                          /* RBC_CODE */
      MoM_Account_Detail[SSB_FOR_EVENT],            /* SOURCE_SYSTEM_BALANCE */
      gl_balance                                    /* GL_BALANCE */
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[OWNER_FOR_EVENT]=$R$46) *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)





=LET(
  topBlock, $R$50#,
  topFacilities, INDEX(topBlock,,3),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE],
      MoM_Account_Detail[MOVEMENT_TYPE],
      MoM_Account_Detail[OWNER_FOR_EVENT2]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(
        MATCH(
          MoM_Account_Detail[FACILITY_FOR_EVENT],
          topFacilities,
          0
        )
      )
      * (MoM_Account_Detail[REVIEWABLE_FLAG]=1)
      * (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)")
      * (MoM_Account_Detail[OWNER_FOR_EVENT2]=$R$46)
    ),

  SORT(filtered, 12, -1)
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  base, IFERROR(FILTER(MoM_Account_Detail, crit), ""),

  h, MoM_Account_Detail[#Headers],

  acct_name, CHOOSECOLS(base, XMATCH("ACCOUNT_NAME_FOR_EVENT", h)),
  cis,       CHOOSECOLS(base, XMATCH("CIS_FOR_EVENT", h)),
  fac,       CHOOSECOLS(base, XMATCH("FACILITY_FOR_EVENT", h)),

  acct_id_c, CHOOSECOLS(base, XMATCH("CURR_ACCOUNT_IDENTIFIER", h)),
  acct_id_p, CHOOSECOLS(base, XMATCH("PREV_ACCOUNT_IDENTIFIER", h)),
  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),

  acct_key,  CHOOSECOLS(base, XMATCH("ACCOUNT_KEY", h)),

  bank_evt,  CHOOSECOLS(base, XMATCH("BANK_FOR_EVENT", h)),
  bank_c,    CHOOSECOLS(base, XMATCH("CURR_BANK_CODE", h)),
  bank_p,    CHOOSECOLS(base, XMATCH("PREV_BANK_CODE", h)),
  bank,      IF(bank_evt<>"", bank_evt, IF(bank_c<>"", bank_c, bank_p)),

  css_c,     CHOOSECOLS(base, XMATCH("CURR_CSS", h)),
  css_p,     CHOOSECOLS(base, XMATCH("PREV_CSS", h)),
  css,       IF(css_c<>"", css_c, css_p),

  gl4_c,     CHOOSECOLS(base, XMATCH("CURR_GL_L4", h)),
  gl4_p,     CHOOSECOLS(base, XMATCH("PREV_GL_L4", h)),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),

  prod5_c,   CHOOSECOLS(base, XMATCH("CURR_PROD5", h)),
  prod5_p,   CHOOSECOLS(base, XMATCH("PREV_PROD5", h)),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),

  status_c,  CHOOSECOLS(base, XMATCH("CURR_STATUS", h)),
  status_p,  CHOOSECOLS(base, XMATCH("PREV_STATUS", h)),
  status,    IF(status_c<>"", status_c, status_p),

  rbc_c,     CHOOSECOLS(base, XMATCH("CURR_RBC", h)),
  rbc_p,     CHOOSECOLS(base, XMATCH("PREV_RBC", h)),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),

  ssb_evt,   CHOOSECOLS(base, XMATCH("SSB_FOR_EVENT", h)),

  glb_c,     CHOOSECOLS(base, XMATCH("CURR_GL_BALANCE", h)),
  glb_p,     CHOOSECOLS(base, XMATCH("PREV_GL_BALANCE", h)),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  IF(base="","",
    HSTACK(acct_name, cis, fac, acct_id, acct_key, bank, css, gl4, prod5, status, rbc, ssb_evt, glb)
  )
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),

  acct_id_c, FILTER(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER], crit),
  acct_id_p, FILTER(MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER], crit),
  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),

  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),

  bank_evt,  FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),
  bank_c,    FILTER(MoM_Account_Detail[CURR_BANK_CODE], crit),
  bank_p,    FILTER(MoM_Account_Detail[PREV_BANK_CODE], crit),
  bank,      IF(bank_evt<>"", bank_evt, IF(bank_c<>"", bank_c, bank_p)),

  css_c,     FILTER(MoM_Account_Detail[CURR_CSS], crit),
  css_p,     FILTER(MoM_Account_Detail[PREV_CSS], crit),
  css,       IF(css_c<>"", css_c, css_p),

  gl4_c,     FILTER(MoM_Account_Detail[CURR_GL_L4], crit),
  gl4_p,     FILTER(MoM_Account_Detail[PREV_GL_L4], crit),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),

  prod5_c,   FILTER(MoM_Account_Detail[CURR_PROD5], crit),
  prod5_p,   FILTER(MoM_Account_Detail[PREV_PROD5], crit),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),

  status_c,  FILTER(MoM_Account_Detail[CURR_STATUS], crit),
  status_p,  FILTER(MoM_Account_Detail[PREV_STATUS], crit),
  status,    IF(status_c<>"", status_c, status_p),

  rbc_c,     FILTER(MoM_Account_Detail[CURR_RBC], crit),
  rbc_p,     FILTER(MoM_Account_Detail[PREV_RBC], crit),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),

  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  glb_c,     FILTER(MoM_Account_Detail[CURR_GL_BALANCE], crit),
  glb_p,     FILTER(MoM_Account_Detail[PREV_GL_BALANCE], crit),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  HSTACK(
    acct_name,
    cis,
    fac,
    acct_id,
    acct_key,
    bank,
    css,
    gl4,
    prod5,
    status,
    rbc,
    ssb_evt,
    glb
  )
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),
  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),
  bank,      FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),
  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  HSTACK(acct_name, cis, fac, acct_key, bank, ssb_evt)
)






=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),
  acct_id_c, FILTER(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER], crit),
  acct_id_p, FILTER(MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER], crit),
  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),

  bank,      FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),

  css_c,     FILTER(MoM_Account_Detail[CURR_CSS], crit),
  css_p,     FILTER(MoM_Account_Detail[PREV_CSS], crit),

  gl4_c,     FILTER(MoM_Account_Detail[CURR_GL_L4], crit),
  gl4_p,     FILTER(MoM_Account_Detail[PREV_GL_L4], crit),

  prod5_c,   FILTER(MoM_Account_Detail[CURR_PROD5], crit),
  prod5_p,   FILTER(MoM_Account_Detail[PREV_PROD5], crit),

  status_c,  FILTER(MoM_Account_Detail[CURR_STATUS], crit),
  status_p,  FILTER(MoM_Account_Detail[PREV_STATUS], crit),

  rbc_c,     FILTER(MoM_Account_Detail[CURR_RBC], crit),
  rbc_p,     FILTER(MoM_Account_Detail[PREV_RBC], crit),

  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  glb_c,     FILTER(MoM_Account_Detail[CURR_GL_BALANCE], crit),
  glb_p,     FILTER(MoM_Account_Detail[PREV_GL_BALANCE], crit),

  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),
  css,       IF(css_c<>"", css_c, css_p),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),
  status,    IF(status_c<>"", status_c, status_p),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  headers, {"ACCOUNT_NAME","CIS_CUSTOMER_NUMBER","FACILITY_ID","ACCOUNT_IDENTIFIER","ACCOUNT_KEY","BANK_CODE","CONTRACT_SOURCE_SYSTEM","GL_ACCOUNT_HIER_LEVEL_4","PROD_HIER_LEVEL_5","STATUS_CODE","RBC_CODE","SOURCE_SYSTEM_BALANCE","GL_BALANCE"},

  data, HSTACK(acct_name,cis,fac,acct_id,acct_key,bank,css,gl4,prod5,status,rbc,ssb_evt,glb),

  VSTACK(headers, data)
)






Here are the columns I want to show for both top30 facilities' account level detail categories (Downgrade IN (ex-Auto) and Exit (ex-Auto)) within the Top30_Owner tabs. You may need to wire the formulas to pull the correct corresponding columns from MoM_Account_Detail.

ACCOUNT_NAME
CIS_CUSTOMER_NUMBER
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
BANK_CODE
CONTRACT_SOURCE_SYSTEM
GL_ACCOUNT_HIER_LEVEL_4
PROD_HIER_LEVEL_5
STATUS_CODE
RBC_CODE
SOURCE_SYSTEM_BALANCE 
GL_BALANCE

Here are the columns I currently have in MoM_Account_Detail:

QUERY_RUN_TIMESTAMP
CURR_EOM
PREV_EOM
ACCOUNT_KEY
PREV_ACCOUNT_IDENTIFIER
PREV_FACILITY_ID
PREV_CIS
PREV_ACCOUNT_NAME
PREV_CSS
PREV_PROD5
PREV_RBC
PREV_STATUS
PREV_GL_L4
PREV_BANK_CODE
PREV_SSB 
PREV_GL_BALANCE
PREV_CO_MTD 
CURR_ACCOUNT_IDENTIFIER
CURR_FACILITY_ID
CURR_CIS
CURR_ACCOUNT_NAME
CURR_CSS
CURR_PROD5
CURR_RBC
CURR_STATUS
CURR_GL_L4
CURR_BANK_CODE
CURR_SSB 
CURR_GL_BALANCE
CURR_CO_MTD 
ACCOUNT_NAME_FOR_EVENT
BANK_FOR_EVENT
FACILITY_FOR_EVENT
CIS_FOR_EVENT
MOM_DELTA 
SSB_FOR_EVENT 
MOVEMENT_TYPE
OWNER_CURR
OWNER_PREV
OWNER_FOR_EVENT
REVIEWABLE_FLAG
CURR_CIS_SSB 
PREV_CIS_SSB 
NEGATIVE_FLAG
NEGATIVE_CLASS
NEGATIVE_FLIP_FLAG
Curr_CO_MTD_Lookup








=LET(
  me, $B$1,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,

  crit,
    (tbl_Facility_Rollup_All[ME_DATE]=me) *
    (tbl_Facility_Rollup_All[MOVEMENT_TYPE]=mt) *
    (tbl_Facility_Rollup_All[Reviewable_Flag_Max]=1) *
    IF(own="ALL", 1, tbl_Facility_Rollup_All[OWNER_EVENT]=own) *
    IF(bk="ALL", 1, tbl_Facility_Rollup_All[BANK_EVENT]=bk),

  fac,   FILTER(tbl_Facility_Rollup_All[FACILITY_EVENT], crit),
  ownc,  FILTER(tbl_Facility_Rollup_All[OWNER_EVENT], crit),
  bank,  FILTER(tbl_Facility_Rollup_All[BANK_EVENT], crit),
  prev,  FILTER(tbl_Facility_Rollup_All[Prev_SSB_SUM], crit),
  curr,  FILTER(tbl_Facility_Rollup_All[Curr_SSB_SUM], crit),
  delta, FILTER(tbl_Facility_Rollup_All[MoM_Delta_SUM], crit),

  metric, IF(mt="Downgrade IN (ex-Auto)", delta, ABS(delta)),

  data, HSTACK(fac, ownc, bank, prev, curr, delta, metric),
  sorted, SORTBY(data, metric, -1),

  TAKE(sorted, MIN(topN, ROWS(sorted)))
)

Facility | Owner | Bank | Prev_SSB | Curr_SSB | MoM_Delta | Magnitude




=LET(
  t, tbl_Facility_Rollup_All,
  me, $B$1,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,

  base, FILTER(
    t,
    (t[ME_DATE]=me) *
    (t[MOVEMENT_TYPE]=mt) *
    (t[Reviewable_Flag_Max]=1) *
    (IF(own="ALL", TRUE, t[OWNER_EVENT]=own)) *
    (IF(bk="ALL", TRUE, t[BANK_EVENT]=bk))
  ),

  metric, IF(mt="Exit (ex-Auto)", ABS(base[MoM_Delta_SUM]), ABS(base[MoM_Delta_SUM])),
  sorted, SORTBY(base, metric, -1),

  HSTACK(
    TAKE(sorted[FACILITY_EVENT], topN),
    TAKE(sorted[OWNER_EVENT], topN),
    TAKE(sorted[BANK_EVENT], topN),
    TAKE(sorted[Prev_SSB_SUM], topN),
    TAKE(sorted[Curr_SSB_SUM], topN),
    TAKE(sorted[MoM_Delta_SUM], topN),
    TAKE(metric, topN)
  )
)






=LET(
  t, tbl_Facility_Rollup_Latest,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,
  onlyRev, TRUE,

  base, FILTER(
    t,
    (t[MOVEMENT_TYPE]=mt) *
    (IF(onlyRev, t[Reviewable_Flag_Max]=1, TRUE)) *
    (IF(own="ALL", TRUE, t[OWNER_EVENT]=own)) *
    (IF(bk="ALL", TRUE, t[BANK_EVENT]=bk))
  ),

  // ranking metric:
  // - Exit: rank by ABS(delta)
  // - Downgrade IN: rank by delta (positive)
  // default: ABS(delta)
  metric, IF(
    mt="Exit (ex-Auto)",
    ABS(CHOOSECOLS(base, XMATCH("MoM_Delta_SUM", t[#Headers]))),
    ABS(CHOOSECOLS(base, XMATCH("MoM_Delta_SUM", t[#Headers])))
  ),

  sorted, SORTBY(base, metric, -1),

  out, HSTACK(
    TAKE(CHOOSECOLS(sorted, XMATCH("FACILITY_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("OWNER_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("BANK_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("Prev_SSB_SUM", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("Curr_SSB_SUM", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("MoM_Delta_SUM", t[#Headers])), topN),
    TAKE(metric, topN)
  ),

  out
)






let
    Source = Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content]
in
    Source





This is a Player Snapshot — not a stat sheet.

Traditional hockey stats tell you what happened.
They rarely help explain what to do next.

The IceStat Player Snapshot is designed to give coaches:
• A clear, blended view of player impact
• Trend context over time
• Supporting detail when deeper explanation is needed

Not more numbers —
but a clearer picture to support real coaching decisions.

This example uses synthetic data to show how IceStat translates tracked events into coaching context.

Team context and workflow matter just as much — more on that soon.







let
    Source = #"MoM_Account_Detail",

    // -----------------------------
    // Canonical Event Dimensions
    // Priority: FOR_EVENT → CURR → PREV
    // -----------------------------
    AddFacility = Table.AddColumn(Source, "FACILITY_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "FACILITY_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_FACILITY_ID")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_FACILITY_ID")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddBank = Table.AddColumn(AddFacility, "BANK_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "BANK_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    AddOwner = Table.AddColumn(AddBank, "OWNER_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "OWNER_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    // -----------------------------
    // Month End
    // -----------------------------
    AddME = Table.AddColumn(AddOwner, "ME_DATE", each
        let
            c = try Date.From(Record.Field(_, "CURR_EOM")) otherwise null,
            p = try Date.From(Record.Field(_, "PREV_EOM")) otherwise null
        in
            if c <> null then c else p
    , type date),

    // -----------------------------
    // Keep Only What We Need
    // -----------------------------
    KeepCols = Table.SelectColumns(AddME,{
        "ME_DATE",
        "BANK_EVENT",
        "FACILITY_EVENT",
        "OWNER_EVENT",
        "MOVEMENT_TYPE",
        "Prev_SSB",
        "Curr_SSB",
        "MoM_Delta",
        "REVIEWABLE_FLAG"
    }),

    Types = Table.TransformColumnTypes(KeepCols,{
        {"ME_DATE", type date},
        {"BANK_EVENT", type text},
        {"FACILITY_EVENT", type text},
        {"OWNER_EVENT", type text},
        {"MOVEMENT_TYPE", type text},
        {"Prev_SSB", type number},
        {"Curr_SSB", type number},
        {"MoM_Delta", type number},
        {"REVIEWABLE_FLAG", Int64.Type}
    }),

    // -----------------------------
    // Facility-Level Rollup
    // -----------------------------
    Grouped = Table.Group(Types,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE"},
        {
            {"Prev_SSB_SUM", each List.Sum([Prev_SSB]), type number},
            {"Curr_SSB_SUM", each List.Sum([Curr_SSB]), type number},
            {"MoM_Delta_SUM", each List.Sum([MoM_Delta]), type number},
            {"Reviewable_Flag_Max", each List.Max([REVIEWABLE_FLAG]), Int64.Type}
        }
    )
in
    Grouped








AddME = Table.AddColumn(AddOwner, "ME_DATE", each
    let
        c = try Date.From(Record.Field(_, "CURR_EOM")) otherwise null,
        p = try Date.From(Record.Field(_, "PREV_EOM")) otherwise null
    in
        if c <> null then c else p
, type date),






let
    Source = Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content],

    // -----------------------------
    // 1) Add "canonical" event columns
    //    Rule: FOR_EVENT -> CURR -> PREV
    // -----------------------------
    AddFacility = Table.AddColumn(Source, "FACILITY_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "FACILITY_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_FACILITY_ID")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_FACILITY_ID")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddBank = Table.AddColumn(AddFacility, "BANK_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "BANK_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_BANK")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_BANK")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddOwner = Table.AddColumn(AddBank, "OWNER_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "OWNER_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_OWNER")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_OWNER")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddME = Table.AddColumn(AddOwner, "ME_DATE", each
        let
            me = try Date.From(Record.Field(_, "END_OF_MONTH_DATE")) otherwise null
        in
            me
    , type date),

    // -----------------------------
    // 2) Keep only what we need (fast + stable)
    //    IMPORTANT: adjust measure column names here if needed
    // -----------------------------
    KeepCols = Table.SelectColumns(AddME,{
        "ME_DATE",
        "BANK_FOR_EVENT_STD",
        "FACILITY_FOR_EVENT_STD",
        "OWNER_FOR_EVENT_STD",
        "MOVEMENT_TYPE",

        // measures (edit if your names differ)
        "SSB_FOR_EVENT",
        "MOM_DELTA",
        "REVIEWABLE_FLAG"
    }),

    Types = Table.TransformColumnTypes(KeepCols,{
        {"ME_DATE", type date},
        {"BANK_FOR_EVENT_STD", type text},
        {"FACILITY_FOR_EVENT_STD", type text},
        {"OWNER_FOR_EVENT_STD", type text},
        {"MOVEMENT_TYPE", type text},
        {"SSB_FOR_EVENT", type number},
        {"MOM_DELTA", type number},
        {"REVIEWABLE_FLAG", Int64.Type}
    }),

    // -----------------------------
    // 3) Roll up to facility level for Top30 + Waterfall
    // -----------------------------
    Grouped = Table.Group(Types,
        {"ME_DATE","BANK_FOR_EVENT_STD","FACILITY_FOR_EVENT_STD","OWNER_FOR_EVENT_STD","MOVEMENT_TYPE"},
        {
            {"SSB_FOR_EVENT_SUM", each List.Sum([SSB_FOR_EVENT]), type number},
            {"MOM_DELTA_SUM", each List.Sum([MOM_DELTA]), type number},
            {"REVIEWABLE_FLAG_MAX", each List.Max([REVIEWABLE_FLAG]), Int64.Type}
        }
    )

in
    Grouped





=SUMIFS(
  tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)


=SUMIFS(
  tbl_Facility_Rollup[Sum of MOM_DELTA],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)

=-SUMIFS(
  tbl_Facility_Rollup[Sum of MOM_DELTA],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[MOVEMENT_TYPE], "Exit (ex-Auto)",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)






=IFERROR(
  SUMIFS(
    tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
    tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
  ),
  0
)


=IFERROR(
  SUMIFS(
    tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[MOVEMENT_TYPE], "Exit (ex-Auto)",
    tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
  ),
  0
)





BANK_FOR_EVENT
FACILITY_FOR_EVENT
MOVEMENT_TYPE
OWNER_FOR_EVENT
Sum of SSB_FOR_EVENT
Sum of MOM_DELTA
Max of REVIEWABLE_FLAG





=SUMIFS(
    tbl_Facility_Rollup[Reviewable_SSB],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[Movement_Type], "Downgrade IN (ex-Auto)"
)





=LET(
  owner, $B$2,
  mt, "Exit (ex-Auto)",
  facs, UNIQUE(FILTER(MoM_Account_Detail[FACILITY_ID],
        (MoM_Account_Detail[OWNER_FOR_EVENT]=owner)*
        (MoM_Account_Detail[Movement_Type]=mt)
  )),
  perFac, BYROW(facs, LAMBDA(f,
        SUMIFS(
          MoM_Account_Detail[CURR_SSB],
          MoM_Account_Detail[FACILITY_ID], f,
          MoM_Account_Detail[Is_Reviewable], 1
        )
  )),
  SUM(perFac)
)






=GETPIVOTDATA(
  "Total Reviewable SSB",
  Facility_Rollup!$A$3,
  "OWNER_FOR_EVENT", $B$2,
  "Movement_Type", "Downgrade IN (ex-Auto)"
)

=GETPIVOTDATA(
  "Total Reviewable SSB",
  Facility_Rollup!$A$3,
  "OWNER_FOR_EVENT", $B$2,
  "Movement_Type", "Exit (ex-Auto)"
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$59#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel, "")),

  facCol, CHOOSECOLS(d, IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), TAKE(d,0)),

  idxRaw, HSTACK(
    IFNA(XMATCH("PREV_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("PREV_CIS", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("PREV_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("PREV_BANK_CODE", hdr), 0),
    IFNA(XMATCH("PREV_CSS", hdr), 0),
    IFNA(XMATCH("PREV_GL_L4", hdr), 0),
    IFNA(XMATCH("PREV_PROD5", hdr), 0),
    IFNA(XMATCH("PREV_STATUS", hdr), 0),
    IFNA(XMATCH("PREV_RBC", hdr), 0),
    IFNA(XMATCH("PREV_SSB", hdr), 0),
    IFNA(XMATCH("PREV_GL_BALANCE", hdr), 0)
  ),
  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, CHOOSECOLS(rows, idx),

  ssbIdx, IFNA(XMATCH("PREV_SSB", hdr), 0),
  sortKey, IF(ssbIdx=0, 0, ABS(IFERROR(--CHOOSECOLS(rows, ssbIdx), 0))),

  IF(ROWS(rows)=0,
     "No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel, "")),

  facCol, CHOOSECOLS(d, IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), TAKE(d,0)),

  idxRaw, HSTACK(
    IFNA(XMATCH("CURR_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("CIS_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("CURR_BANK_CODE", hdr), 0),
    IFNA(XMATCH("CURR_CSS", hdr), 0),
    IFNA(XMATCH("CURR_GL_L4", hdr), 0),
    IFNA(XMATCH("CURR_PROD5", hdr), 0),
    IFNA(XMATCH("CURR_STATUS", hdr), 0),
    IFNA(XMATCH("CURR_RBC", hdr), 0),
    IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_GL_BALANCE", hdr), 0)
  ),
  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, CHOOSECOLS(rows, idx),

  ssbIdx, IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
  sortKey, IF(ssbIdx=0, 0, IFERROR(--CHOOSECOLS(rows, ssbIdx), 0)),

  IF(ROWS(rows)=0,
     "No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), ""),

  idxRaw, HSTACK(
    IFNA(XMATCH("CURR_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("CIS_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("CURR_BANK_CODE", hdr), 0),
    IFNA(XMATCH("CURR_CSS", hdr), 0),
    IFNA(XMATCH("CURR_GL_L4", hdr), 0),
    IFNA(XMATCH("CURR_PROD5", hdr), 0),
    IFNA(XMATCH("CURR_STATUS", hdr), 0),
    IFNA(XMATCH("CURR_RBC", hdr), 0),
    IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_GL_BALANCE", hdr), 0)
  ),

  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, IF(rows="","No matching account rows.", CHOOSECOLS(rows, idx)),

  sortKey, IF(rows="", 0, IFERROR(--CHOOSECOLS(rows, XMATCH("SSB_FOR_EVENT", hdr)), 0)),

  IF(rows="","No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)







=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), ""),

  idxRaw, HSTACK(
    XMATCH("CURR_ACCOUNT_NAME", hdr),
    XMATCH("CIS_FOR_EVENT", hdr),
    XMATCH("FACILITY_FOR_EVENT", hdr),
    XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr),
    XMATCH("ACCOUNT_KEY", hdr),
    XMATCH("CURR_BANK_CODE", hdr),
    XMATCH("CURR_CSS", hdr),
    XMATCH("CURR_GL_L4", hdr),
    XMATCH("CURR_PROD5", hdr),
    XMATCH("CURR_STATUS", hdr),
    XMATCH("CURR_RBC", hdr),
    XMATCH("SSB_FOR_EVENT", hdr),
    XMATCH("CURR_GL_BALANCE", hdr)
  ),
  idx, FILTER(idxRaw, ISNUMBER(idxRaw)),

  out, IF(rows="","No matching account rows.", CHOOSECOLS(rows, idx)),

  ssbCol, IFERROR(CHOOSECOLS(rows, XMATCH("SSB_FOR_EVENT", hdr)), 0),

  IF(rows="","No matching account rows.",
     SORTBY(out, ssbCol, -1)
  )
)





=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],

  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  keep, ISNUMBER(MATCH(facCol, facs, 0)),

  rows, IFERROR(FILTER(d, keep), ""),

  out, CHOOSECOLS(
        rows,
        XMATCH("CURR_ACCOUNT_NAME", hdr),
        XMATCH("CIS_FOR_EVENT", hdr),
        XMATCH("FACILITY_FOR_EVENT", hdr),
        XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr),
        XMATCH("ACCOUNT_KEY", hdr),
        XMATCH("CURR_BANK_CODE", hdr),
        XMATCH("CURR_CSS", hdr),
        XMATCH("CURR_GL_L4", hdr),
        XMATCH("CURR_PROD5", hdr),
        XMATCH("CURR_STATUS", hdr),
        XMATCH("CURR_RBC", hdr),
        XMATCH("SSB_FOR_EVENT", hdr),
        XMATCH("CURR_GL_BALANCE", hdr)
      ),

  IF(rows="","No matching account rows.",
     SORTBY(out, CHOOSECOLS(out,12), -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$8#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  rows, IFERROR(
          FILTER(d,
            (d[OWNER_FOR_EVENT]=ownerSel)*
            (d[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)")*
            ISNUMBER(MATCH(d[FACILITY_FOR_EVENT], facs, 0))
          ),
          ""
        ),

  out, CHOOSECOLS(
        rows,
        XMATCH("CURR_ACCOUNT_NAME", d[#Headers]),
        XMATCH("CIS_FOR_EVENT", d[#Headers]),
        XMATCH("FACILITY_FOR_EVENT", d[#Headers]),
        XMATCH("CURR_ACCOUNT_IDENTIFIER", d[#Headers]),
        XMATCH("ACCOUNT_KEY", d[#Headers]),
        XMATCH("CURR_BANK_CODE", d[#Headers]),
        XMATCH("CURR_CSS", d[#Headers]),
        XMATCH("CURR_GL_L4", d[#Headers]),
        XMATCH("CURR_PROD5", d[#Headers]),
        XMATCH("CURR_STATUS", d[#Headers]),
        XMATCH("CURR_RBC", d[#Headers]),
        XMATCH("SSB_FOR_EVENT", d[#Headers]),
        XMATCH("CURR_GL_BALANCE", d[#Headers])
      ),

  IF(rows="","No matching account rows.",
     SORTBY(out, CHOOSECOLS(out,12), -1)
  )
)














MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]


      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE],




ACCOUNT_NAME
CIS_CUSTOMER_NUMBER
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
BANK_CODE
CONTRACT_SOURCE_SYSTEM
GL_ACCOUNT_HIER_LEVEL_4
PROD_HIER_LEVEL_5
STATUS_CODE
RBC_CODE
 SOURCE_SYSTEM_BALANCE 
 GL_BALANCE





=LET(
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$8#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  out, FILTER(
        d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]="Downgrade IN (ex-Auto)")*
        ISNUMBER(MATCH(d[Facility_For_Event], facs, 0))
  ),
  SORTBY(out, out[SSB_For_Event], -1)
)



=LET(
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$60#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  out, FILTER(
        d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]="Exit (ex-Auto)")*
        ISNUMBER(MATCH(d[Facility_For_Event], facs, 0))
  ),
  SORTBY(out, ABS(out[MoM_Delta]), -1)
)







=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Exit (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       FILTER(t, keep),
  f_delta, FILTER(delta, keep),

  sorted, SORTBY(f, ABS(IFERROR(--f_delta,0)), -1),
  n, MIN(30, ROWS(sorted)),

  TAKE(sorted, n)
)






=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,     FILTER(t, keep),
  f_ssb, FILTER(ssb, keep),

  sorted, SORTBY(f, IFERROR(--f_ssb,0), -1),
  n, MIN(30, ROWS(sorted)),

  TAKE(sorted, n)
)





=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  sortKey, IFERROR(--f_ssb,0),

  IF(f="",
     "No matches for this owner + movement type.",
     TAKE(SORTBY(f, sortKey, -1), 30)
  )
)





=LET(
  top, Top30_Engine!A8#,
  ownerSel, $B$2,
  ownerCol, 4,
  facCol, 2,
  facs, FILTER(CHOOSECOLS(top, facCol), CHOOSECOLS(top, ownerCol)=ownerSel),
  UNIQUE(facs)
)






=LET(
  top, A8#,
  facList, DROP(CHOOSECOLS(top,2),1),
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",
  out, FILTER(d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]=mvSel)*
        ISNUMBER(MATCH(d[Facility_For_Event], facList, 0))
  ),
  SORTBY(out, out[SSB_For_Event], -1)
)






=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  sortKey,
    IF(TRIM(mvSel)="Exit (ex-Auto)",
       ABS(IFERROR(--f_delta,0)),
       IFERROR(--f_ssb,0)
    ),

  IF(f="",
     "No matches for the selected Owner/Movement_Type (or Reviewable <> 1).",
     TAKE(SORTBY(f, sortKey, -1), 30)
  )
)







=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  bank,  CHOOSECOLS(t, XMATCH("BANK_FOR_EVENT", hdr)),
  fac,   CHOOSECOLS(t, XMATCH("FACILITY_FOR_EVENT", hdr)),
  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  rankMetric,
    IF(TRIM(mvSel)="Exit (ex-Auto)",
       ABS(IFERROR(--f_delta,0)),
       IFERROR(--f_ssb,0)
    ),

  IF(f="",
     "No matches for the selected Owner/Movement_Type (or Reviewable <> 1).",
     TAKE(SORTBY(HSTACK(f, rankMetric), rankMetric, -1), 30)
  )
)






rankMetric,
IF(
  TRIM(mvSel)="Exit (ex-Auto)",
  ABS(IFERROR(--f_delta,0)),
  IFERROR(--f_ssb,0)
),





=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  bank,  CHOOSECOLS(t, XMATCH("Bank_For_Event", hdr)),
  fac,   CHOOSECOLS(t, XMATCH("Facility_For_Event", hdr)),
  own,   CHOOSECOLS(t, XMATCH("Owner_For_Event", hdr)),
  mv,    CHOOSECOLS(t, XMATCH("Movement_Type", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Reviewable_Flag", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("SSB_For_Event", hdr)),
  delta, CHOOSECOLS(t, XMATCH("MoM_Delta", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f, IFERROR(FILTER(t, keep), ""),
  f_ssb, IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  rankMetric, IF(mvSel="Exit (ex-Auto)", ABS(f_delta), f_ssb),

  IF(f="","No matches for the selected Owner/Movement_Type (or Reviewable_Flag not = 1).",
     TAKE(SORTBY(HSTACK(f, rankMetric), rankMetric, -1), 30)
  )
)






=LET(
  t, tbl_Facility_Rollup,
  bank, CHOOSECOLS(t,1),
  fac,  CHOOSECOLS(t,2),
  own,  CHOOSECOLS(t,3),
  mv,   CHOOSECOLS(t,4),
  rev,  CHOOSECOLS(t,5),
  ssb,  CHOOSECOLS(t,6),
  delta,CHOOSECOLS(t,7),

  ownerSel, $B$2,
  mvSel, $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),
  f, FILTER(t, keep),

  f_ssb,  FILTER(ssb, keep),
  f_delta,FILTER(delta, keep),

  rankMetric, IF(mvSel="Exit (ex-Auto)", ABS(f_delta), f_ssb),
  sorted, SORTBY(f, rankMetric, -1),
  TAKE(HSTACK(sorted, rankMetric), 30)
)





=LET(
  t, tbl_Facility_Rollup,
  owner, $B$2,
  mv, $B$3,
  f, FILTER(t, (t[Owner_For_Event]=owner)*(t[Movement_Type]=mv)*(t[Reviewable_Flag]>=1)),
  rankMetric, IF(mv="Exit (ex-Auto)", ABS(INDEX(f[MoM_Delta],0)), INDEX(f[SSB_For_Event],0)),
  sorted, SORTBY(f, rankMetric, -1),
  TAKE(HSTACK(sorted, rankMetric), 30)
)







/* ================================== Query 1: MoM_Account_Detail (incl. negatives, charge-offs, status)
   UPDATED:
   - Movement_Type classified at FACILITY level (stamped onto all Account_Key rows)
   - Reviewable_Flag classified at FACILITY level (stamped onto all Account_Key rows)
   - Facility Owner logic with deterministic pick (largest |SSB_For_Event| account), with hard override:
       Daniel gets EVERYTHING where Contract_Source_System = 'INFL10'
   - Presence tests use SUM(ABS(SSB)) to avoid net-to-zero masking
   - Reviewable exposure tests use SUM(positive SSB) as discussed
   Grain of final output remains ACCOUNT_KEY
======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags (account-level) */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags (account-level) */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Pos→Neg Flip'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Neg→Pos Flip'
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Δ'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Δ'
      ELSE NULL
    END AS Negative_Class

  FROM joined j
),

/* CIS totals (account-level window, as-is) */
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
),

/* Event-scoped fields (same logic you had in final SELECT, moved earlier so we can roll up at facility level) */
event_scoped AS (
  SELECT
    w.*,

    /* Account_Name for the “event” side (curr if exists, else prev) */
    CASE
      WHEN w.has_curr=1 THEN w.Curr_Account_Name
      WHEN w.had_prev=1 THEN w.Prev_Account_Name
      ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
    END AS Account_Name_For_Event,

    /* event scoping */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
      WHEN w.has_curr=1 THEN w.Curr_Bank_Code
      ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
    END AS Bank_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
      WHEN w.has_curr=1 THEN w.Curr_Facility_ID
      ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
    END AS Facility_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
      WHEN w.has_curr=1 THEN w.Curr_CIS
      ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
    END AS CIS_For_Event,

    /* choose event-side CSS/PROD/BANK/RBC for downstream owner logic */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CSS
      WHEN w.has_curr=1 THEN w.Curr_CSS
      ELSE COALESCE(w.Curr_CSS, w.Prev_CSS)
    END AS CSS_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_PROD5
      WHEN w.has_curr=1 THEN w.Curr_PROD5
      ELSE COALESCE(w.Curr_PROD5, w.Prev_PROD5)
    END AS PROD5_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_RBC
      WHEN w.has_curr=1 THEN w.Curr_RBC
      ELSE COALESCE(w.Curr_RBC, w.Prev_RBC)
    END AS RBC_For_Event,

    /* balances */
    (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,

    CASE
      WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
      ELSE COALESCE(w.Prev_SSB,0)
    END AS SSB_For_Event
  FROM with_cis w
),

/* Account-level owner (event-side) with Daniel override moved to the top */
account_owner_event AS (
  SELECT
    e.*,

    CASE
      WHEN e.CSS_For_Event = 'INFL10' THEN 'Daniel'  /* HARD OVERRIDE */
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
      WHEN e.Bank_For_Event='L-SVB' THEN 'Eleanor'
      WHEN UPPER(COALESCE(e.RBC_For_Event,''))='R' THEN 'Autochange'
      WHEN e.Bank_For_Event='L-FCB' THEN 'Connor'
      ELSE 'NOT COVERED'
    END AS Owner_Account_For_Event
  FROM event_scoped e
),

/* Rank accounts within facility to pick representative attributes (largest |SSB_For_Event|) */
ranked_in_facility AS (
  SELECT
    a.*,
    ROW_NUMBER() OVER (
      PARTITION BY a.Bank_For_Event, a.Facility_For_Event
      ORDER BY ABS(COALESCE(a.SSB_For_Event,0)) DESC, a.Account_Key
    ) AS rn_fac
  FROM account_owner_event a
),

/* Facility rollup + facility-level classification + facility owner */
facility_rollup AS (
  SELECT
    Bank_For_Event,
    Facility_For_Event,

    /* Presence tests (avoid net-to-zero masking) */
    SUM(ABS(COALESCE(Prev_SSB,0))) AS Fac_Prev_Abs_SSB,
    SUM(ABS(COALESCE(Curr_SSB,0))) AS Fac_Curr_Abs_SSB,

    /* Positive exposure tests (reviewable gating) */
    SUM(CASE WHEN COALESCE(Prev_SSB,0) > 0 THEN COALESCE(Prev_SSB,0) ELSE 0 END) AS Fac_Prev_Pos_SSB,
    SUM(CASE WHEN COALESCE(Curr_SSB,0) > 0 THEN COALESCE(Curr_SSB,0) ELSE 0 END) AS Fac_Curr_Pos_SSB,

    /* Net balances for delta-based “persisting change” */
    SUM(COALESCE(Prev_SSB,0)) AS Fac_Prev_Net_SSB,
    SUM(COALESCE(Curr_SSB,0)) AS Fac_Curr_Net_SSB,

    /* Facility-level auto flags: ANY auto within facility */
    MAX(CASE WHEN UPPER(COALESCE(Prev_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Prev_Auto_Any,
    MAX(CASE WHEN UPPER(COALESCE(Curr_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Curr_Auto_Any,

    /* Daniel override: ANY INFL10 in facility => Daniel */
    MAX(CASE WHEN CSS_For_Event='INFL10' THEN 1 ELSE 0 END) AS Fac_INFL10_Any,

    /* Representative attributes from top |SSB_For_Event| row */
    MAX(CASE WHEN rn_fac=1 THEN CIS_For_Event END)         AS Fac_CIS_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN PROD5_For_Event END)       AS Fac_PROD5_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN RBC_For_Event END)         AS Fac_RBC_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN Owner_Account_For_Event END) AS Fac_Owner_From_TopRow,

    /* Representative CIS totals from top row (used in threshold exclusions) */
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Curr_CIS_SSB,0) END) AS Fac_Curr_CIS_SSB,
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Prev_CIS_SSB,0) END) AS Fac_Prev_CIS_SSB

  FROM ranked_in_facility
  GROUP BY Bank_For_Event, Facility_For_Event
),

facility_classified AS (
  SELECT
    fr.*,

    /* facility presence flags */
    CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Had_Prev,
    CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Has_Curr,

    /* facility owner for event */
    CASE
      WHEN fr.Fac_INFL10_Any = 1 THEN 'Daniel'
      ELSE COALESCE(fr.Fac_Owner_From_TopRow, 'NOT COVERED')
    END AS Owner_Facility_For_Event,

    /* FACILITY-level Movement_Type */
    CASE
      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
        THEN 'Autochange Downgrade IN'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
        THEN 'Autochange Exit'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange Persisting Balance Changes'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange No Change'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
        THEN 'Downgrade IN (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
        THEN 'Exit (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Persisting Balance Changes (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'No Change (ex-Auto)'

      ELSE NULL
    END AS Movement_Type_Facility,

    /* FACILITY-level Reviewable_Flag (stamped down) */
    CASE
      WHEN (
        /* only these two types are review-queued */
        (CASE
           WHEN (
             CASE
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
               THEN 'Downgrade IN (ex-Auto)'
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
               THEN 'Exit (ex-Auto)'
               ELSE NULL
             END
           ) IS NOT NULL THEN 1 ELSE 0
         END)=1

        AND (
          /* positive exposure must exist on relevant side */
          ( ( /* Downgrade IN */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Curr_Pos_SSB,0) > 0
            )
            OR
            ( /* Exit */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Prev_Pos_SSB,0) > 0
            )
          )
        )

        AND (
          /* exclusions (mirror your prior logic, applied at facility rep-level) */
          CASE
            /* Downgrade IN exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END

            /* Exit exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END
            ELSE 0
          END = 1
        )
      )
      THEN 1 ELSE 0
    END AS Reviewable_Flag_Facility

  FROM facility_rollup fr
)

/* =========================
   FINAL OUTPUT (ACCOUNT_KEY grain)
   - Movement_Type now = facility-level Movement_Type_Facility
   - Owner_For_Event now = facility-level Owner_Facility_For_Event
   - Reviewable_Flag now = facility-level Reviewable_Flag_Facility
   - Owner_Curr / Owner_Prev also updated so Daniel override is absolute
========================= */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  a.Account_Key,

  /* prev attributes */
  a.Prev_Account_Identifier,
  a.Prev_Facility_ID,
  a.Prev_CIS,
  a.Prev_Account_Name,
  a.Prev_CSS,
  a.Prev_PROD5,
  a.Prev_RBC,
  a.Prev_Status,
  a.Prev_GL_L4,
  a.Prev_Bank_Code,
  a.Prev_SSB,
  a.Prev_GL_Balance,
  a.Prev_CO_MTD,

  /* curr attributes */
  a.Curr_Account_Identifier,
  a.Curr_Facility_ID,
  a.Curr_CIS,
  a.Curr_Account_Name,
  a.Curr_CSS,
  a.Curr_PROD5,
  a.Curr_RBC,
  a.Curr_Status,
  a.Curr_GL_L4,
  a.Curr_Bank_Code,
  a.Curr_SSB,
  a.Curr_GL_Balance,
  a.Curr_CO_MTD,

  /* event-side display fields */
  a.Account_Name_For_Event,
  a.Bank_For_Event,
  a.Facility_For_Event,
  a.CIS_For_Event,

  /* balances */
  a.MoM_Delta,
  a.SSB_For_Event,

  /* FACILITY movement typing */
  fc.Movement_Type_Facility AS Movement_Type,

  /* Owners (Curr / Prev) with Daniel override absolute */
  CASE
    WHEN a.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Curr_RBC='R' THEN 'Autochange'
    WHEN a.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN a.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Prev_RBC='R' THEN 'Autochange'
    WHEN a.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* FACILITY owner for event */
  fc.Owner_Facility_For_Event AS Owner_For_Event,

  /* FACILITY reviewable flag */
  fc.Reviewable_Flag_Facility AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  a.Curr_CIS_SSB,
  a.Prev_CIS_SSB,
  a.Negative_Flag,
  a.Negative_Class,
  a.Negative_Flip_Flag

FROM ranked_in_facility a
JOIN facility_classified fc
  ON a.Bank_For_Event = fc.Bank_For_Event
 AND a.Facility_For_Event = fc.Facility_For_Event

/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(a.Prev_SSB,0) = 0 AND COALESCE(a.Curr_SSB,0) = 0)

ORDER BY a.Bank_For_Event, a.Facility_For_Event, a.Account_Key;








Below is my full query for the RC_Code analysis. I was wanting to run the model on one single RC_Code. Can you give me a version that only outputs the analysis for 1 single RC_Code that I will manually input? 

/* ========== RC_Code Anomaly Detection — REG12-only, Thresholded, PBI-safe ========== */
/* Key features:
   - Uses only 12-month regression per RC (no REG36, MA6, MA12, no seasonality)
   - Limits history (min_me) to control runtime
   - Applies exposure_min_for_model on latest balance
   - Adds TOTAL_PORTFOLIO pseudo-RC
   - Outputs PI bands, Severity_0_100, Persistent_Outlier_3of6, Reason_Code
   - Flags Is_Material_Residual_500M for |Residual| >= threshold
*/

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,            -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,   -- >= $1B latest
    500000000.0::FLOAT8                AS material_resid_threshold  -- >= $500M residual
),

/* 1) Base RC-level balances (time filtered) */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b,
       params p
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Portfolio total per month as pseudo-RC */
base_total AS (
  SELECT
    'TOTAL_PORTFOLIO'               AS RC_CODE,
    'Total Loans - Portfolio'       AS RC_DESCRIPTION,
    month_end,
    SUM(bal_num)::FLOAT8            AS bal_num
  FROM base_rc
  GROUP BY month_end
),

/* 3) Combine RC-level + portfolio-level */
base_all AS (
  SELECT * FROM base_rc
  UNION ALL
  SELECT * FROM base_total
),

/* 4) Latest month & latest exposure per RC */
latest_me AS (
  SELECT
    RC_CODE,
    MAX(month_end) AS max_me
  FROM base_all
  GROUP BY RC_CODE
),

latest_exp AS (
  SELECT
    b.RC_CODE,
    b.bal_num AS latest_bal
  FROM base_all b
  JOIN latest_me m
    ON m.RC_CODE = b.RC_CODE
   AND m.max_me  = b.month_end
),

/* 5) RCs that pass exposure threshold */
material_rc AS (
  SELECT
    e.RC_CODE
  FROM latest_exp e
  CROSS JOIN params p
  WHERE e.latest_bal >= p.exposure_min_for_model
),

/* 6) Filter base to material RCs + portfolio */
base AS (
  SELECT b.*
  FROM base_all b
  WHERE b.RC_CODE IN (SELECT RC_CODE FROM material_rc)
),

/* 7) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 8) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 9) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 10) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 11) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 12) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    -- residual distribution stats
    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    -- MoM distribution stats
    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    -- RMSE per RC (for PI bands)
    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 13) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 14) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 15) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 16) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 17) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 18) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  /* Flag big residuals */
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.RC_CODE, r.month_end;





/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE, LAST 12 MONTHS ONLY ========== */

WITH
/* 0) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR(50) AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Find the latest month_end for this RC (Total Loans only) */
rc_max_me AS (
  SELECT
    CAST(MAX(b.END_OF_MONTH_DATE) AS DATE) AS max_me
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.RC_CODE = m.manual_rc_code
),

/* 2) Base RC-level balances — ONLY last 12 months relative to max_me */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN manual_rc m
  CROSS JOIN rc_max_me mx
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.RC_CODE = m.manual_rc_code
    AND CAST(b.END_OF_MONTH_DATE AS DATE) >= ADD_MONTHS(mx.max_me, -11)
    AND CAST(b.END_OF_MONTH_DATE AS DATE) <= mx.max_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 3) Index per RC, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 4) REG12 parameters (computed on these 12 rows) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM idx_tm
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS forecast
  FROM idx_tm l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    f.*,
    t.prev_bal,
    t.pos3_count,

    (f.bal_num - f.forecast)::FLOAT8 AS Resid,
    ABS(f.bal_num - f.forecast)::FLOAT8 AS AbsResid,

    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      ELSE ABS(f.bal_num - t.prev_bal)
    END::FLOAT8 AS MoM_Abs,

    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
      ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(f.bal_num - f.forecast)) OVER (PARTITION BY f.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(f.bal_num - f.forecast)) OVER (PARTITION BY f.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN t.prev_bal IS NULL THEN NULL ELSE ABS(f.bal_num - t.prev_bal) END
    ) OVER (PARTITION BY f.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN t.prev_bal IS NULL THEN NULL ELSE ABS(f.bal_num - t.prev_bal) END
    ) OVER (PARTITION BY f.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN t.prev_bal IS NULL THEN NULL
        WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
        ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
      END
    ) OVER (PARTITION BY f.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN t.prev_bal IS NULL THEN NULL
        WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
        ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
      END
    ) OVER (PARTITION BY f.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (f.bal_num - f.forecast)*(f.bal_num - f.forecast) )
      OVER (PARTITION BY f.RC_CODE)
    ) AS rmse
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 8) P95 AbsResid & MoM_Abs (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 9) Severity */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 10) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 11) Reason_Code */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code
FROM reasoned r
ORDER BY r.month_end;









/* ================================== Query 1: MoM_Account_Detail (incl. negatives, charge-offs, status) @ ACCOUNT_KEY grain ======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives (no SSB>0 filter) */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM NA-pop collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM NA-pop collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + CIS totals + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* ---- Negative logic ---- */
    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      /* 1) Positive → Negative flip */
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Pos→Neg Flip'

      /* 2) Negative → Positive flip */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Neg→Pos Flip'

      /* 3) New negative (no prior exposure, now negative) */
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'

      /* 4) Cleared negative (was negative, now zero) */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'

      /* 5) Persisting negative with delta */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Δ'

      /* 6) Persisting negative, no delta */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Δ'

      ELSE NULL
    END AS Negative_Class

  FROM joined j
  
),
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
)

/* 6) Final projection: includes Account_Name, negative flags, and filters out pure zero rows */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  w.Account_Key,

  /* prev attributes */
  w.Prev_Account_Identifier,
  w.Prev_Facility_ID,
  w.Prev_CIS,
  w.Prev_Account_Name,
  w.Prev_CSS,
  w.Prev_PROD5,
  w.Prev_RBC,
  w.Prev_Status,
  w.Prev_GL_L4,
  w.Prev_Bank_Code,
  w.Prev_SSB,
  w.Prev_GL_Balance,
  w.Prev_CO_MTD,

  /* curr attributes */
  w.Curr_Account_Identifier,
  w.Curr_Facility_ID,
  w.Curr_CIS,
  w.Curr_Account_Name,
  w.Curr_CSS,
  w.Curr_PROD5,
  w.Curr_RBC,
  w.Curr_Status,
  w.Curr_GL_L4,
  w.Curr_Bank_Code,
  w.Curr_SSB,
  w.Curr_GL_Balance,
  w.Curr_CO_MTD,

  /* Account_Name for the “event” side (curr if exists, else prev) */
  CASE
    WHEN w.has_curr=1 THEN w.Curr_Account_Name
    WHEN w.had_prev=1 THEN w.Prev_Account_Name
    ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
  END AS Account_Name_For_Event,

  /* event scoping (bank/facility/CIS for event) */
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
    WHEN w.has_curr=1 THEN w.Curr_Bank_Code
    ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
  END AS Bank_For_Event,
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
    WHEN w.has_curr=1 THEN w.Curr_Facility_ID
    ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
  END AS Facility_For_Event,
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
    WHEN w.has_curr=1 THEN w.Curr_CIS
    ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
  END AS CIS_For_Event,

  /* balances */
  (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,
  CASE
    WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
    ELSE COALESCE(w.Prev_SSB,0)
  END AS SSB_For_Event,

  /* movement typing */
  CASE
    WHEN w.had_prev=0 AND w.has_curr=1 AND w.curr_auto=1 THEN 'Autochange Downgrade IN'
    WHEN w.had_prev=1 AND w.has_curr=0 AND w.prev_auto=1 THEN 'Autochange Exit'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.prev_auto=1 AND w.curr_auto=1
         AND COALESCE(w.Curr_SSB,0)<>COALESCE(w.Prev_SSB,0) THEN 'Autochange Persisting Balance Changes'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.prev_auto=1 AND w.curr_auto=1
         AND COALESCE(w.Curr_SSB,0)= COALESCE(w.Prev_SSB,0) THEN 'Autochange No Change'
    WHEN w.had_prev=0 AND w.has_curr=1 AND w.curr_auto=0 THEN 'Downgrade IN (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=0 AND w.prev_auto=0 THEN 'Exit (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.curr_auto=0
         AND COALESCE(w.Curr_SSB,0)<>COALESCE(w.Prev_SSB,0) THEN 'Persisting Balance Changes (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.curr_auto=0
         AND COALESCE(w.Curr_SSB,0)= COALESCE(w.Prev_SSB,0) THEN 'No Change (ex-Auto)'
    ELSE NULL
  END AS Movement_Type,

  /* Owners w/ CIS thresholds */
  CASE
    WHEN w.Curr_PROD5='Business RE Term Loans'
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN w.Curr_PROD5='Business RE Term Loans'
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN w.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN w.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN w.Curr_RBC='R' THEN 'Autochange'
    WHEN w.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN w.Prev_PROD5='Business RE Term Loans'
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN w.Prev_PROD5='Business RE Term Loans'
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN w.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN w.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN w.Prev_RBC='R' THEN 'Autochange'
    WHEN w.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* Owner for event (for bridges / Top 30 by owner) */
  CASE
    WHEN w.has_curr=1 THEN
      CASE
        WHEN w.Curr_PROD5='Business RE Term Loans'
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
        WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
        WHEN w.Curr_PROD5='Business RE Term Loans'
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
        WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
        WHEN w.Curr_CSS='INFL10' THEN 'Daniel'
        WHEN w.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
        WHEN w.Curr_RBC='R' THEN 'Autochange'
        WHEN w.Curr_Bank_Code='L-FCB' THEN 'Connor'
        ELSE 'NOT COVERED'
      END
    WHEN w.had_prev=1 THEN
      CASE
        WHEN w.Prev_PROD5='Business RE Term Loans'
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
        WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
        WHEN w.Prev_PROD5='Business RE Term Loans'
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
        WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
        WHEN w.Prev_CSS='INFL10' THEN 'Daniel'
        WHEN w.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
        WHEN w.Prev_RBC='R' THEN 'Autochange'
        WHEN w.Prev_Bank_Code='L-FCB' THEN 'Connor'
        ELSE 'NOT COVERED'
      END
    ELSE 'NOT COVERED'
  END AS Owner_For_Event,

  /* reviewable flag */
  CASE
    WHEN (
      (Movement_Type IN ('Downgrade IN (ex-Auto)','Exit (ex-Auto)')) AND
      (
        (Movement_Type='Downgrade IN (ex-Auto)' AND COALESCE(w.Curr_SSB,0) > 0) OR
        (Movement_Type='Exit (ex-Auto)'         AND COALESCE(w.Prev_SSB,0) > 0)
      ) AND
      (
        CASE
          WHEN Movement_Type='Downgrade IN (ex-Auto)' THEN
            CASE
              WHEN w.Curr_PROD5='Business RE Term Loans' AND w.Curr_Bank_Code='L-CIT' AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 0
              WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw') AND w.Curr_Bank_Code='L-CIT' AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 0
              WHEN w.Curr_RBC='R' THEN 0
              ELSE 1
            END
          WHEN Movement_Type='Exit (ex-Auto)' THEN
            CASE
              WHEN w.Prev_PROD5='Business RE Term Loans' AND w.Prev_Bank_Code='L-CIT' AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 0
              WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw') AND w.Prev_Bank_Code='L-CIT' AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 0
              WHEN w.Prev_RBC='R' THEN 0
              ELSE 1
            END
          ELSE 0
        END = 1
      )
    )
    THEN 1 ELSE 0
  END AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  w.Curr_CIS_SSB,
  w.Prev_CIS_SSB,
  w.Negative_Flag,
  w.Negative_Class,
  w.Negative_Flip_Flag

FROM with_cis w
/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(w.Prev_SSB,0) = 0 AND COALESCE(w.Curr_SSB,0) = 0)
ORDER BY Bank_For_Event, Facility_For_Event, Account_Key;









/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE (no thresholds) ========== */

WITH
/* 0) Minimal parameter: history window only */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me   -- last 72 months only
),

/* 0b) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Base RC-level balances (time filtered) — ONLY the selected RC_CODE */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN params p
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
    AND b.RC_CODE = m.manual_rc_code
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 3) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 4) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 8) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 9) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 10) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 11) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 12) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 13) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code
FROM reasoned r
ORDER BY r.month_end;











/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE (manual input) ========== */

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,                 -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,  -- kept for reference (not enforced)
    500000000.0::FLOAT8                AS material_resid_threshold -- >= $500M residual
),

/* 0b) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Base RC-level balances (time filtered) — ONLY the selected RC_CODE */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN params p
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
    AND b.RC_CODE = m.manual_rc_code
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 3) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 4) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 8) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 9) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 10) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 11) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 12) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 13) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.month_end;







/* ========== RC_Code Anomaly Detection — REG12-only, Thresholded, PBI-safe ========== */
/* Key features:
   - Uses only 12-month regression per RC (no REG36, MA6, MA12, no seasonality)
   - Limits history (min_me) to control runtime
   - Applies exposure_min_for_model on latest balance
   - Adds TOTAL_PORTFOLIO pseudo-RC
   - Outputs PI bands, Severity_0_100, Persistent_Outlier_3of6, Reason_Code
   - Flags Is_Material_Residual_500M for |Residual| >= threshold
*/

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,            -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,   -- >= $1B latest
    500000000.0::FLOAT8                AS material_resid_threshold  -- >= $500M residual
),

/* 1) Base RC-level balances (time filtered) */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b,
       params p
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Portfolio total per month as pseudo-RC */
base_total AS (
  SELECT
    'TOTAL_PORTFOLIO'               AS RC_CODE,
    'Total Loans - Portfolio'       AS RC_DESCRIPTION,
    month_end,
    SUM(bal_num)::FLOAT8            AS bal_num
  FROM base_rc
  GROUP BY month_end
),

/* 3) Combine RC-level + portfolio-level */
base_all AS (
  SELECT * FROM base_rc
  UNION ALL
  SELECT * FROM base_total
),

/* 4) Latest month & latest exposure per RC */
latest_me AS (
  SELECT
    RC_CODE,
    MAX(month_end) AS max_me
  FROM base_all
  GROUP BY RC_CODE
),

latest_exp AS (
  SELECT
    b.RC_CODE,
    b.bal_num AS latest_bal
  FROM base_all b
  JOIN latest_me m
    ON m.RC_CODE = b.RC_CODE
   AND m.max_me  = b.month_end
),

/* 5) RCs that pass exposure threshold */
material_rc AS (
  SELECT
    e.RC_CODE
  FROM latest_exp e
  CROSS JOIN params p
  WHERE e.latest_bal >= p.exposure_min_for_model
),

/* 6) Filter base to material RCs + portfolio */
base AS (
  SELECT b.*
  FROM base_all b
  WHERE b.RC_CODE IN (SELECT RC_CODE FROM material_rc)
),

/* 7) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 8) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 9) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 10) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 11) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 12) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    -- residual distribution stats
    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    -- MoM distribution stats
    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    -- RMSE per RC (for PI bands)
    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 13) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 14) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 15) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 16) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 17) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 18) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  /* Flag big residuals */
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.RC_CODE, r.month_end;






https://www.instagram.com/icestat_analytics?igsh=MW4xdTc3dWlsazBzag%3D%3D&utm_source=qr




import os
import pandas as pd
import numpy as np

pd.set_option("display.float_format", "${:,.2f}".format)

# --- USER INPUT ---
FILE_PATH  = "loan_extract.xlsx"    # or "loan_extract.csv" | "loan_extract.xlsb"
SHEET_NAME = 0
DATE_COL   = "END_OF_MONTH_DATE"
BANK_COL   = "BANK_CODE"
GL_COL     = "GL_ACCOUNT_HIER_LEVEL_4"
BAL_COL    = "GL_BALANCE"
MOM_$      = "MoM_GL_$"
MOM_PCT    = "MoM_GL_PCT"

REQUIRED = [DATE_COL, BANK_COL, GL_COL, BAL_COL, MOM_$, MOM_PCT]

# --- Load ---
def read_any(path, sheet=None, parse_dates=None):
    ext = os.path.splitext(path)[1].lower()
    if ext == ".csv":
        return pd.read_csv(path, parse_dates=parse_dates, infer_datetime_format=True)
    elif ext in [".xlsx", ".xls"]:
        return pd.read_excel(path, sheet_name=sheet, parse_dates=parse_dates, engine="openpyxl")
    elif ext == ".xlsb":
        return pd.read_excel(path, sheet_name=sheet, parse_dates=parse_dates, engine="pyxlsb")
    else:
        raise ValueError(f"Unsupported file extension: {ext}")

df = read_any(FILE_PATH, sheet=SHEET_NAME, parse_dates=[DATE_COL])
df.columns = [c.strip() for c in df.columns]

# --- Checks and cleanup ---
missing = [c for c in REQUIRED if c not in df.columns]
if missing:
    raise KeyError(f"Missing required columns: {missing}")

df[DATE_COL] = pd.to_datetime(df[DATE_COL], errors="coerce").dt.date
df[BAL_COL] = pd.to_numeric(df[BAL_COL], errors="coerce").fillna(0)
df[MOM_$] = pd.to_numeric(df[MOM_$], errors="coerce")
df[MOM_PCT] = pd.to_numeric(df[MOM_PCT], errors="coerce")

# --- Find the last 2 month-ends ---
all_dates = sorted([d for d in df[DATE_COL].dropna().unique()])
if len(all_dates) < 2:
    raise ValueError("Less than 2 distinct month-end dates in data.")
prior_eom, current_eom = all_dates[-2], all_dates[-1]

# --- Subsets for the two months ---
cur = df[df[DATE_COL] == current_eom].copy()
prev = df[df[DATE_COL] == prior_eom].copy()

# --- Join current and prior balances ---
joined = pd.merge(
    prev[[BANK_COL, GL_COL, BAL_COL]],
    cur[[BANK_COL, GL_COL, BAL_COL, MOM_$, MOM_PCT]],
    on=[BANK_COL, GL_COL],
    how="outer",
    suffixes=("_prior", "_current")
)

joined = joined.fillna(0)
joined.rename(columns={
    f"{BAL_COL}_prior":   "Prior_GL_BALANCE",
    f"{BAL_COL}_current": "Current_GL_BALANCE",
    MOM_$:                "MoM_GL_$",
    MOM_PCT:              "MoM_GL_PCT"
}, inplace=True)

# --- Display sample ---
print(f"Prior EOM:   {prior_eom}")
print(f"Current EOM: {current_eom}")
print("\n=== Sample joined table ===")
display(joined.head(20))

# --- Optional: pivot by GL then Bank ---
pivot_current = cur.pivot_table(
    index=GL_COL, columns=BANK_COL, values=BAL_COL, aggfunc="sum", fill_value=0
)
pivot_prior = prev.pivot_table(
    index=GL_COL, columns=BANK_COL, values=BAL_COL, aggfunc="sum", fill_value=0
)

print("\n=== Current month matrix (rows=GL, cols=Bank) ===")
display(pivot_current.head(10))
print("\n=== Prior month matrix (rows=GL, cols=Bank) ===")
display(pivot_prior.head(10))

# --- Save outputs ---
os.makedirs("outputs", exist_ok=True)
joined.to_csv("outputs/GL_balances_MoM_joined.csv", index=False)
pivot_current.to_csv("outputs/GL_balances_current_matrix.csv")
pivot_prior.to_csv("outputs/GL_balances_prior_matrix.csv")

print("\nFiles saved in ./outputs:")
print(" - GL_balances_MoM_joined.csv")
print(" - GL_balances_current_matrix.csv")
print(" - GL_balances_prior_matrix.csv")
