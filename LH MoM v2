Dim_Owner =
DISTINCT (
    UNION (
        SELECTCOLUMNS ( PBI_Feed_Facility_Review_Current, "OWNER_EVENT", PBI_Feed_Facility_Review_Current[OWNER_EVENT] ),
        SELECTCOLUMNS ( PBI_Feed_Reviewable_Summary_Current, "OWNER_EVENT", PBI_Feed_Reviewable_Summary_Current[OWNER_EVENT] )
    )
)





let
    Source = Excel.CurrentWorkbook(){[Name="tbl_AUX_Topsides_Raw"]}[Content],

    // Clean column names
    CleanCols =
        Table.TransformColumnNames(
            Source,
            each Text.Trim(Text.Replace(_, "#(lf)", " "))
        ),

    // Rename only known-stable columns
    Renamed =
        Table.RenameColumns(
            CleanCols,
            {
                {"Data Period", "ME_DATE"},
                {"Facility ID", "FACILITY_ID"},
                {"Account_key", "ACCOUNT_KEY"},
                {"Source System ID (Key field)", "SOURCE_SYSTEM_ID"},
                {"NON_ACCRUAL_DATE", "NON_ACCRUAL_DATE"},
                {"NON_ACCRUAL_FLAG (Y/N)", "NON_ACCRUAL_FLAG"},
                {"Line of Business", "LOB"},
                {"Obligor Name", "OBLIGOR_NAME"},
                {"Type of Requested Change", "REQUESTED_CHANGE"},
                {"Reason for requested change", "REQUEST_REASON"},
                {"Comments", "COMMENTS"},
                {"Reference Report", "REFERENCE_REPORT"},
                {"Name of the Requestor", "REQUESTOR"},
                {"Balance", "BALANCE_RAW"}
            },
            MissingField.Ignore
        ),

    // Ensure ACCOUNT_IDENTIFIER exists (nullable)
    EnsureAccountIdentifier =
        if List.Contains(Table.ColumnNames(Renamed), "ACCOUNT_IDENTIFIER") then
            Renamed
        else
            Table.AddColumn(Renamed, "ACCOUNT_IDENTIFIER", each null, type text),

    // Remove any leftover header-like rows defensively
    RemoveHeaderLikeRows =
        Table.SelectRows(
            EnsureAccountIdentifier,
            each
                let
                    md = Text.Upper(Text.Trim(try Text.From([ME_DATE]) otherwise "")),
                    fid = Text.Upper(Text.Trim(try Text.From([FACILITY_ID]) otherwise ""))
                in
                    not (md = "DATA PERIOD" or fid = "FACILITY ID")
        ),

    // Set types
    Types =
        Table.TransformColumnTypes(
            RemoveHeaderLikeRows,
            {
                {"ME_DATE", type date},
                {"FACILITY_ID", type text},
                {"ACCOUNT_KEY", type text},
                {"ACCOUNT_IDENTIFIER", type text},
                {"SOURCE_SYSTEM_ID", type text},
                {"NON_ACCRUAL_DATE", type date},
                {"NON_ACCRUAL_FLAG", type text},
                {"LOB", type text},
                {"OBLIGOR_NAME", type text},
                {"REQUESTED_CHANGE", type text},
                {"REQUEST_REASON", type text},
                {"COMMENTS", type text},
                {"REFERENCE_REPORT", type text},
                {"REQUESTOR", type text},
                {"BALANCE_RAW", type any}
            }
        ),

    // Parse balance to absolute numeric
    BalanceAbs =
        Table.AddColumn(
            Types,
            "BALANCE_ABS",
            each
                let
                    t = try Text.Trim(Text.From([BALANCE_RAW])) otherwise "",
                    t1 = Text.Replace(Text.Replace(Text.Replace(t, ",", ""), "$", ""), "(", "-"),
                    t2 = Text.Replace(t1, ")", ""),
                    n = try Number.FromText(t2) otherwise null
                in
                    if n = null then null else Number.Abs(n),
            type number
        ),

    // Determine topside sign from requested change
    Sign =
        Table.AddColumn(
            BalanceAbs,
            "TOPSIDE_SIGN",
            each
                let rc = Text.Lower(Text.From([REQUESTED_CHANGE]))
                in
                    if Text.Contains(rc, "remove") then -1
                    else if Text.Contains(rc, "add") then 1
                    else 1,
            Int64.Type
        ),

    // Signed topside amount
    Topsided =
        Table.AddColumn(
            Sign,
            "TOPSIDE_AMOUNT",
            each
                if [BALANCE_ABS] = null then null else [BALANCE_ABS] * [TOPSIDE_SIGN],
            type number
        ),

    // Cleanup
    DropRaw =
        Table.RemoveColumns(Topsided, {"BALANCE_RAW"}),

    AddRunTs =
        Table.AddColumn(
            DropRaw,
            "QUERY_RUN_TIMESTAMP",
            each DateTime.LocalNow(),
            type datetime
        )
in
    AddRunTs





let
    Source = Excel.CurrentWorkbook(){[Name="tbl_AUX_Topsides_Raw"]}[Content],

    // Trim header names just in case
    CleanCols = Table.TransformColumnNames(Source, each Text.Trim(Text.Replace(_, "#(lf)", " "))),

    // Rename AUX headers -> standardized names
    Renamed = Table.RenameColumns(
        CleanCols,
        {
            {"Data Period", "ME_DATE"},
            {"Facility ID", "FACILITY_ID"},
            {"Account_key", "ACCOUNT_KEY"},
            {"Account Identifier (Key Field; Unique)", "ACCOUNT_IDENTIFIER"},
            {"Source System ID (Key field)", "SOURCE_SYSTEM_ID"},
            {"NON_ACCRUAL_DATE", "NON_ACCRUAL_DATE"},
            {"NON_ACCRUAL_FLAG (Y/N)", "NON_ACCRUAL_FLAG"},
            {"Line of Business", "LOB"},
            {"Obligor Name", "OBLIGOR_NAME"},
            {"Type of Requested Change", "REQUESTED_CHANGE"},
            {"Reason for requested change", "REQUEST_REASON"},
            {"Comments", "COMMENTS"},
            {"Reference Report", "REFERENCE_REPORT"},
            {"Name of the Requestor", "REQUESTOR"},
            {"Balance", "BALANCE_RAW"}
        },
        MissingField.Ignore
    ),

    // Safety: remove any accidental leftover header row in the data area
    // (e.g., ME_DATE contains "Data Period" or FACILITY_ID contains "Facility ID")
    RemoveHeaderLikeRows = Table.SelectRows(
        Renamed,
        each
            let
                md = Text.Upper(Text.Trim(try Text.From([ME_DATE]) otherwise "")),
                fid = Text.Upper(Text.Trim(try Text.From([FACILITY_ID]) otherwise ""))
            in
                not (md = "DATA PERIOD" or fid = "FACILITY ID")
    ),

    // Type handling
    Types = Table.TransformColumnTypes(
        RemoveHeaderLikeRows,
        {
            {"ME_DATE", type date},
            {"FACILITY_ID", type text},
            {"ACCOUNT_KEY", type text},
            {"ACCOUNT_IDENTIFIER", type text},
            {"SOURCE_SYSTEM_ID", type text},
            {"NON_ACCRUAL_DATE", type date},
            {"NON_ACCRUAL_FLAG", type text},
            {"LOB", type text},
            {"OBLIGOR_NAME", type text},
            {"REQUESTED_CHANGE", type text},
            {"REQUEST_REASON", type text},
            {"COMMENTS", type text},
            {"REFERENCE_REPORT", type text},
            {"REQUESTOR", type text},
            {"BALANCE_RAW", type any}
        }
    ),

    // Parse balance robustly (handles $ , commas, parentheses)
    BalanceAbs = Table.AddColumn(
        Types,
        "BALANCE_ABS",
        each
            let
                t = try Text.Trim(Text.From([BALANCE_RAW])) otherwise "",
                t1 = Text.Replace(Text.Replace(Text.Replace(t, ",", ""), "$", ""), "(", "-"),
                t2 = Text.Replace(t1, ")", ""),
                n = try Number.FromText(t2) otherwise null
            in
                if n = null then null else Number.Abs(n),
        type number
    ),

    // Determine sign from requested change
    Sign = Table.AddColumn(
        BalanceAbs,
        "TOPSIDE_SIGN",
        each
            let rc = Text.Lower(Text.From([REQUESTED_CHANGE]))
            in
                if Text.Contains(rc, "remove") then -1
                else if Text.Contains(rc, "add") then 1
                else 1,
        Int64.Type
    ),

    // Signed topside amount
    Topsided = Table.AddColumn(
        Sign,
        "TOPSIDE_AMOUNT",
        each if [BALANCE_ABS] = null then null else [BALANCE_ABS] * [TOPSIDE_SIGN],
        type number
    ),

    // Drop raw balance column (optional)
    DropRaw = Table.RemoveColumns(Topsided, {"BALANCE_RAW"}),

    AddRunTs = Table.AddColumn(DropRaw, "QUERY_RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)
in
    AddRunTs





let
    Source = Excel.CurrentWorkbook(){[Name="tbl_AUX_Topsides_Raw"]}[Content],

    // Clean column names (remove line breaks / extra spaces)
    CleanCols = Table.TransformColumnNames(Source, each Text.Trim(Text.Replace(_, "#(lf)", " "))),

    // Rename AUX headers -> standardized names
    Renamed = Table.RenameColumns(
        CleanCols,
        {
            {"Data Period", "ME_DATE"},
            {"Facility ID", "FACILITY_ID"},
            {"Account_key", "ACCOUNT_KEY"},
            {"Account Identifier (Key Field; Unique)", "ACCOUNT_IDENTIFIER"},
            {"Source System ID (Key field)", "SOURCE_SYSTEM_ID"},
            {"NON_ACCRUAL_DATE", "NON_ACCRUAL_DATE"},
            {"NON_ACCRUAL_FLAG (Y/N)", "NON_ACCRUAL_FLAG"},
            {"Line of Business", "LOB"},
            {"Obligor Name", "OBLIGOR_NAME"},
            {"Type of Requested Change", "REQUESTED_CHANGE"},
            {"Reason for requested change", "REQUEST_REASON"},
            {"Comments", "COMMENTS"},
            {"Reference Report", "REFERENCE_REPORT"},
            {"Name of the Requestor", "REQUESTOR"},
            {"Balance", "BALANCE_RAW"}
        },
        MissingField.Ignore
    ),

    // Type handling (Balance may come as text)
    Types = Table.TransformColumnTypes(
        Renamed,
        {
            {"ME_DATE", type date},
            {"FACILITY_ID", type text},
            {"ACCOUNT_KEY", type text},
            {"ACCOUNT_IDENTIFIER", type text},
            {"SOURCE_SYSTEM_ID", type text},
            {"NON_ACCRUAL_DATE", type date},
            {"NON_ACCRUAL_FLAG", type text},
            {"LOB", type text},
            {"OBLIGOR_NAME", type text},
            {"REQUESTED_CHANGE", type text},
            {"REQUEST_REASON", type text},
            {"COMMENTS", type text},
            {"REFERENCE_REPORT", type text},
            {"REQUESTOR", type text},
            {"BALANCE_RAW", type any}
        }
    ),

    // Parse balance robustly
    BalanceNum = Table.AddColumn(
        Types,
        "BALANCE_ABS",
        each
            let
                t = try Text.Trim(Text.From([BALANCE_RAW])) otherwise "",
                t2 = Text.Replace(Text.Replace(Text.Replace(t, ",", ""), "$", ""), "(", "-"),
                t3 = Text.Replace(t2, ")", ""),
                n = try Number.FromText(t3) otherwise null
            in
                if n = null then null else Number.Abs(n),
        type number
    ),

    // Determine sign from requested change
    Sign = Table.AddColumn(
        BalanceNum,
        "TOPSIDE_SIGN",
        each
            let rc = Text.Lower(Text.From([REQUESTED_CHANGE]))
            in
                if Text.Contains(rc, "remove") then -1
                else if Text.Contains(rc, "add") then 1
                else 1,
        Int64.Type
    ),

    // Signed topside amount
    Topsided = Table.AddColumn(
        Sign,
        "TOPSIDE_AMOUNT",
        each if [BALANCE_ABS] = null then null else [BALANCE_ABS] * [TOPSIDE_SIGN],
        type number
    ),

    // Optional: drop raw balance column
    DropRaw = Table.RemoveColumns(Topsided, {"BALANCE_RAW"}),

    AddRunTs = Table.AddColumn(DropRaw, "QUERY_RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)
in
    AddRunTs






Hdr - Title :=
"Non-Accrual Portfolio Executive Snapshot"

Hdr - As Of :=
VAR d =
    MAX ( PBI_Feed_Portfolio_Summary_Current[ME_DATE] )
RETURN
"Month End: " & FORMAT ( d, "mmm d, yyyy" )

Hdr - Data Refreshed :=
VAR ts =
    MAX ( PBI_Feed_Movement_Summary_All_Current[QUERY_RUN_TIMESTAMP] )
RETURN
"Data refreshed: " & FORMAT ( ts, "mmm d, yyyy h:mm AM/PM" )



Hdr - Subtitle :=
[Hdr - As Of] & "  â€¢  " & [Hdr - Data Refreshed]



Waterfall_Axis =
DATATABLE (
    "Step", STRING,
    "SortOrder", INTEGER,
    "BarType", STRING,
    {
        {"Beginning Balance", 1, "Start"},
        {"Downgrade IN",      2, "Change"},
        {"Exit",              3, "Change"},
        {"Other",             4, "Change"},
        {"Ending Balance",    5, "End"}
    }
)

WF - Amount :=
SWITCH(
    SELECTEDVALUE(Waterfall_Axis[Step]),
    "Beginning Balance", [KPI - Total Previous Portfolio Balance],
    "Downgrade IN",      [KPI - Downgrade IN Total (All)],
    "Exit",              - [KPI - Exit Total (All, Abs)],
    "Other",
        [KPI - Total Current Portfolio Balance]
        - [KPI - Total Previous Portfolio Balance]
        - [KPI - Downgrade IN Total (All)]
        + [KPI - Exit Total (All, Abs)],
    "Ending Balance",    [KPI - Total Current Portfolio Balance]
)





Waterfall Bar Color :=
VAR Step =
    SELECTEDVALUE ( Waterfall_Axis[Step] )
RETURN
SWITCH (
    TRUE(),
    Step = "Beginning Balance", "#4A4A4A",   -- neutral gray
    Step = "Ending Balance",    "#4A4A4A",   -- total bar
    Step = "Other",             "#9E9E9E",   -- muted gray
    [Waterfall Amount] > 0,     "#D84315",   -- increase (Downgrade IN) - red/orange
    [Waterfall Amount] < 0,     "#2E7D32",   -- decrease (Exit) - green
    "#9E9E9E"
)





Waterfall_Axis =
DATATABLE (
    "Step", STRING,
    "SortOrder", INTEGER,
    {
        {"Beginning Balance", 1},
        {"Downgrade IN", 2},
        {"Exit", 3},
        {"Other", 4}
    }
)

Waterfall Amount :=
SWITCH (
    SELECTEDVALUE ( Waterfall_Axis[Step] ),
    "Beginning Balance", [Beginning Balance],
    "Downgrade IN", [Waterfall - Downgrade IN],
    "Exit", [Waterfall - Exit],
    "Other", [Waterfall - Other (Net)]
)





Waterfall_Axis =
DATATABLE (
    "Step", STRING,
    "SortOrder", INTEGER,
    {
        {"Beginning Balance", 1},
        {"Downgrade IN", 2},
        {"Exit", 3},
        {"Other", 4},
        {"Ending Balance", 5}
    }
)


SortOrder =
SWITCH(
  Waterfall_Axis[Step],
  "Beginning Balance", 1,
  "Downgrade IN", 2,
  "Exit", 3,
  "Other", 4,
  "Ending Balance", 5,
  99
)







Waterfall - Other (Net) :=
VAR Prev = [Beginning Balance]
VAR Curr = [Ending Balance]
VAR Down = [Waterfall - Downgrade IN]
VAR Exit = [Waterfall - Exit]
RETURN
    Curr - Prev - Down - Exit




Waterfall_Axis =
DATATABLE (
    "Step", STRING,
    {
        {"Beginning Balance"},
        {"Downgrade IN"},
        {"Exit"},
        {"Other"},
        {"Ending Balance"}
    }
)


Waterfall Amount :=
SWITCH (
    SELECTEDVALUE ( Waterfall_Axis[Step] ),
    "Beginning Balance", [Beginning Balance],
    "Downgrade IN", [Waterfall - Downgrade IN],
    "Exit", [Waterfall - Exit],
    "Other", [Waterfall - Other (Net)],
    "Ending Balance", [Ending Balance]
)






KPI - Downgrade IN Total (All) :=
CALCULATE (
    SUM ( PBI_Feed_Movement_Summary_All_Current[MOM_DELTA_SUM] ),
    FILTER (
        ALL ( PBI_Feed_Movement_Summary_All_Current ),
        CONTAINSSTRING ( LOWER ( PBI_Feed_Movement_Summary_All_Current[MOVEMENT_TYPE] ), "downgrade" )
            && CONTAINSSTRING ( LOWER ( PBI_Feed_Movement_Summary_All_Current[MOVEMENT_TYPE] ), "in" )
    )
)


KPI - Exit Total (All, Abs) :=
ABS (
    CALCULATE (
        SUM ( PBI_Feed_Movement_Summary_All_Current[MOM_DELTA_SUM] ),
        FILTER (
            ALL ( PBI_Feed_Movement_Summary_All_Current ),
            CONTAINSSTRING ( LOWER ( PBI_Feed_Movement_Summary_All_Current[MOVEMENT_TYPE] ), "exit" )
        )
    )
)

KPI - Downgrade IN Total (All) :=
CALCULATE (
    SUM ( PBI_Feed_Movement_Summary_All_Current[MOM_DELTA_SUM] ),
    PBI_Feed_Movement_Summary_All_Current[MOVEMENT_TYPE] IN {
        "Downgrade IN (ex-Auto)",
        "Autochange Downgrade IN"
    }
)






let
    Source = pq_Facility_Rollup_All,

    // Keep only what we need
    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE", "MOVEMENT_TYPE", "MOM_DELTA_SUM"}
    ),

    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"MOVEMENT_TYPE", type text},
            {"MOM_DELTA_SUM", type number}
        }
    ),

    // Group to movement totals (this preserves Autochange + Not Covered + everything)
    Grouped = Table.Group(
        Types,
        {"ME_DATE", "MOVEMENT_TYPE"},
        {{"MOM_DELTA_SUM", each List.Sum([MOM_DELTA_SUM]), type number}}
    ),

    AddRunTs = Table.AddColumn(Grouped, "QUERY_RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)
in
    AddRunTs






= Table.SelectRows(#"Previous Step", each [FACILITY_EVENT] <> null and Text.Trim(Text.From([FACILITY_EVENT])) <> "")





=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

  header, HSTACK("CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT","EXPOSURE_BASIS","OWNER_RANK"),
  blankRow, HSTACK(eom,"","","","",0),

  mk, LAMBDA(owner, movement, rng,
    LET(
      n, IFERROR(ROWS(rng), 0),
      magTest, IFERROR(INDEX(rng,1,7), ""),
      facTest, IFERROR(INDEX(rng,1,1), ""),
      IF(
        OR(n=0, facTest="", magTest=""),
        blankRow,
        HSTACK(
          MAKEARRAY(n,1,LAMBDA(x,y,eom)),
          MAKEARRAY(n,1,LAMBDA(x,y,owner)),
          MAKEARRAY(n,1,LAMBDA(x,y,movement)),
          CHOOSECOLS(rng,1),     /* Facility */
          CHOOSECOLS(rng,7),     /* Magnitude */
          SEQUENCE(n)
        )
      )
    )
  ),

  stacked,
    VSTACK(
      mk("Samya","Downgrade IN (ex-Auto)", dSamya),
      mk("Samya","Exit (ex-Auto)", eSamya),
      mk("Connor","Downgrade IN (ex-Auto)", dConnor),
      mk("Connor","Exit (ex-Auto)", eConnor),
      mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
      mk("Daniel","Exit (ex-Auto)", eDaniel),
      mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
      mk("Eleanor","Exit (ex-Auto)", eEleanor),
      mk("Casey","Downgrade IN (ex-Auto)", dCasey),
      mk("Casey","Exit (ex-Auto)", eCasey)
    ),

  cleaned,
    IFERROR(
      FILTER(stacked, INDEX(stacked,,4)<>""),   /* keep only rows with Facility */
      TAKE(stacked,1)
    ),

  VSTACK(header, cleaned)
)





=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

  header, HSTACK("CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT","EXPOSURE_BASIS","OWNER_RANK"),
  blankRow, HSTACK(eom,"","","","",0),

  mk, LAMBDA(owner, movement, rng,
    LET(
      r, IFERROR(rng, ""),                 /* convert #CALC/#N/A spills to blank */
      n, IFERROR(ROWS(r), 0),
      IF(
        n=0,
        blankRow,
        HSTACK(
          MAKEARRAY(n,1,LAMBDA(x,y,eom)),
          MAKEARRAY(n,1,LAMBDA(x,y,owner)),
          MAKEARRAY(n,1,LAMBDA(x,y,movement)),
          CHOOSECOLS(r,1),                 /* Facility */
          CHOOSECOLS(r,7),                 /* Magnitude */
          SEQUENCE(n)
        )
      )
    )
  ),

  stacked,
    VSTACK(
      mk("Samya","Downgrade IN (ex-Auto)", dSamya),
      mk("Samya","Exit (ex-Auto)", eSamya),
      mk("Connor","Downgrade IN (ex-Auto)", dConnor),
      mk("Connor","Exit (ex-Auto)", eConnor),
      mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
      mk("Daniel","Exit (ex-Auto)", eDaniel),
      mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
      mk("Eleanor","Exit (ex-Auto)", eEleanor),
      mk("Casey","Downgrade IN (ex-Auto)", dCasey),
      mk("Casey","Exit (ex-Auto)", eCasey)
    ),

  cleaned,
    IFERROR(
      FILTER(stacked, INDEX(stacked,,4)<>""),   /* keep only rows with facility */
      TAKE(stacked,1)
    ),

  VSTACK(header, cleaned)
)





=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

  header, HSTACK("CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT","EXPOSURE_BASIS","OWNER_RANK"),
  blankRow, HSTACK(eom,"","","","",0),

  mk, LAMBDA(owner, movement, rng,
    LET(
      n, IFERROR(ROWS(rng),0),
      IF(
        n=0,
        blankRow,
        HSTACK(
          MAKEARRAY(n,1,LAMBDA(x,y,eom)),
          MAKEARRAY(n,1,LAMBDA(x,y,owner)),
          MAKEARRAY(n,1,LAMBDA(x,y,movement)),
          CHOOSECOLS(rng,1),          /* Facility (assumed col 1) */
          CHOOSECOLS(rng,7),          /* Magnitude (Exposure basis) */
          SEQUENCE(n)
        )
      )
    )
  ),

  stacked,
    VSTACK(
      mk("Samya","Downgrade IN (ex-Auto)", dSamya),
      mk("Samya","Exit (ex-Auto)", eSamya),
      mk("Connor","Downgrade IN (ex-Auto)", dConnor),
      mk("Connor","Exit (ex-Auto)", eConnor),
      mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
      mk("Daniel","Exit (ex-Auto)", eDaniel),
      mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
      mk("Eleanor","Exit (ex-Auto)", eEleanor),
      mk("Casey","Downgrade IN (ex-Auto)", dCasey),
      mk("Casey","Exit (ex-Auto)", eCasey)
    ),

  cleaned,
    IFERROR(
      FILTER(stacked, INDEX(stacked,,4)<>""),   /* keep only rows with FACILITY_EVENT */
      TAKE(stacked,1)
    ),

  VSTACK(header, cleaned)
)







let
    Source = Excel.CurrentWorkbook(){[Name="rng_PBI_Feed_Facility_Review_Current"]}[Content],
    PromoteHeaders = Table.PromoteHeaders(Source, [PromoteAllScalars=true]),

    // Keep as text first to avoid conversion errors from blanks/placeholder rows
    AsText = Table.TransformColumnTypes(
        PromoteHeaders,
        {
            {"CURR_EOM_DATE", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"FACILITY_EVENT", type text},
            {"EXPOSURE_BASIS", type text},
            {"OWNER_RANK", type text}
        }
    ),

    // Parse date safely
    ParseDate = Table.TransformColumns(
        AsText,
        {{"CURR_EOM_DATE", each try Date.From(_) otherwise try Date.FromText(_) otherwise null, type date}}
    ),

    // Parse exposure safely (handles blanks, commas, etc.)
    AddExposureNum = Table.AddColumn(
        ParseDate,
        "EXPOSURE_BASIS_NUM",
        each
            let t = Text.Trim([EXPOSURE_BASIS])
            in if t = "" then null else try Number.FromText(Text.Replace(t, ",", "")) otherwise null,
        type number
    ),

    // Parse rank safely
    AddRankNum = Table.AddColumn(
        AddExposureNum,
        "OWNER_RANK_NUM",
        each
            let t = Text.Trim([OWNER_RANK])
            in if t = "" then null else try Number.FromText(t) otherwise null,
        Int64.Type
    ),

    // Remove original text cols and rename numeric versions
    DropOld = Table.RemoveColumns(AddRankNum, {"EXPOSURE_BASIS", "OWNER_RANK"}),

    RenameCols = Table.RenameColumns(
        DropOld,
        {{"EXPOSURE_BASIS_NUM", "EXPOSURE_BASIS"}, {"OWNER_RANK_NUM", "OWNER_RANK"}}
    ),

    // Optional: remove placeholder/blank rows (no facility)
    FilterRealRows = Table.SelectRows(RenameCols, each [FACILITY_EVENT] <> null and Text.Trim([FACILITY_EVENT]) <> ""),

    AddTopNFlag = Table.AddColumn(FilterRealRows, "TOPN_OWNER_FLAG", each "Y", type text),
    AddRunTs = Table.AddColumn(AddTopNFlag, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs






let
    Source = Excel.CurrentWorkbook(){[Name="rng_PBI_Feed_Facility_Review_Current"]}[Content],
    PromoteHeaders = Table.PromoteHeaders(Source, [PromoteAllScalars=true]),
    Types = Table.TransformColumnTypes(
        PromoteHeaders,
        {
            {"CURR_EOM_DATE", type date},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"FACILITY_EVENT", type text},
            {"EXPOSURE_BASIS", type number},
            {"OWNER_RANK", Int64.Type}
        }
    ),
    AddTopNFlag = Table.AddColumn(Types, "TOPN_OWNER_FLAG", each "Y", type text),
    AddRunTs = Table.AddColumn(AddTopNFlag, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)
in
    AddRunTs





=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

  header, HSTACK("CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT","EXPOSURE_BASIS","OWNER_RANK"),
  blankRow, HSTACK(eom,"","","","",0),

  mk, LAMBDA(owner, movement, rng,
    LET(
      n, IFERROR(ROWS(rng),0),
      IF(
        n=0,
        blankRow,
        HSTACK(
          MAKEARRAY(n,1,LAMBDA(x,y,eom)),
          MAKEARRAY(n,1,LAMBDA(x,y,owner)),
          MAKEARRAY(n,1,LAMBDA(x,y,movement)),
          IFERROR(CHOOSECOLS(rng,1), ""),
          IFERROR(CHOOSECOLS(rng,2), ""),
          SEQUENCE(n)
        )
      )
    )
  ),

  stacked,
    VSTACK(
      mk("Samya","Downgrade IN (ex-Auto)", dSamya),
      mk("Samya","Exit (ex-Auto)", eSamya),
      mk("Connor","Downgrade IN (ex-Auto)", dConnor),
      mk("Connor","Exit (ex-Auto)", eConnor),
      mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
      mk("Daniel","Exit (ex-Auto)", eDaniel),
      mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
      mk("Eleanor","Exit (ex-Auto)", eEleanor),
      mk("Casey","Downgrade IN (ex-Auto)", dCasey),
      mk("Casey","Exit (ex-Auto)", eCasey)
    ),

  cleaned,
    IFERROR(
      FILTER(stacked, INDEX(stacked,,4)<>""),   /* keep only rows with FACILITY_EVENT */
      TAKE(stacked,1)                          /* fallback: return 1 row (won't error) */
    ),

  VSTACK(header, cleaned)
)






=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

  header, {"CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT","EXPOSURE_BASIS","OWNER_RANK"},
  blankRow, {eom,"","","","",0},

  mk, LAMBDA(owner, movement, rng,
    LET(
      n, IFERROR(ROWS(rng),0),
      r, IF(n=0,"",rng),
      IF(
        n=0,
        blankRow,
        HSTACK(
          MAKEARRAY(n,1,LAMBDA(x,y,eom)),
          MAKEARRAY(n,1,LAMBDA(x,y,owner)),
          MAKEARRAY(n,1,LAMBDA(x,y,movement)),
          IFERROR(CHOOSECOLS(r,1), ""),
          IFERROR(CHOOSECOLS(r,2), ""),
          SEQUENCE(n)
        )
      )
    )
  ),

  stacked,
    VSTACK(
      mk("Samya","Downgrade IN (ex-Auto)", dSamya),
      mk("Samya","Exit (ex-Auto)", eSamya),
      mk("Connor","Downgrade IN (ex-Auto)", dConnor),
      mk("Connor","Exit (ex-Auto)", eConnor),
      mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
      mk("Daniel","Exit (ex-Auto)", eDaniel),
      mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
      mk("Eleanor","Exit (ex-Auto)", eEleanor),
      mk("Casey","Downgrade IN (ex-Auto)", dCasey),
      mk("Casey","Exit (ex-Auto)", eCasey)
    ),

  cleaned,
    IFERROR(
      FILTER(stacked, INDEX(stacked,,4)<>""),   /* keep only rows with FACILITY_EVENT */
      TAKE(header,1)                           /* if nothing to keep, return just header */
    ),

  VSTACK(header, cleaned)
)








=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

  empty6, TAKE(SEQUENCE(1,6),0),

  mk, LAMBDA(owner, movement, rng,
    LET(
      r, IFERROR(rng, TAKE(SEQUENCE(1,2),0)),
      col2ok, IFERROR(INDEX(r,1,2), NA()),
      IF(
        ISNA(col2ok),
        empty6,
        LET(
          n, ROWS(r),
          IF(
            n=0,
            empty6,
            HSTACK(
              MAKEARRAY(n,1,LAMBDA(x,y,eom)),
              MAKEARRAY(n,1,LAMBDA(x,y,owner)),
              MAKEARRAY(n,1,LAMBDA(x,y,movement)),
              CHOOSECOLS(r,1),
              CHOOSECOLS(r,2),
              SEQUENCE(n)
            )
          )
        )
      )
    )
  ),

  IFERROR(
    VSTACK(
      mk("Samya","Downgrade IN (ex-Auto)", dSamya),
      mk("Samya","Exit (ex-Auto)", eSamya),
      mk("Connor","Downgrade IN (ex-Auto)", dConnor),
      mk("Connor","Exit (ex-Auto)", eConnor),
      mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
      mk("Daniel","Exit (ex-Auto)", eDaniel),
      mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
      mk("Eleanor","Exit (ex-Auto)", eEleanor),
      mk("Casey","Downgrade IN (ex-Auto)", dCasey),
      mk("Casey","Exit (ex-Auto)", eCasey)
    ),
    empty6
  )
)






=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

  mk, LAMBDA(owner, movement, rng,
    LET(
      r, IFERROR(rng, TAKE(SEQUENCE(1,2),0)),          /* always an array */
      empty6, TAKE(SEQUENCE(1,6),0),
      col2ok, IFERROR( INDEX(r,1,2), NA() ),
      IF(
        ISNA(col2ok),
        empty6,
        LET(
          n, ROWS(r),
          IF(
            n=0,
            empty6,
            HSTACK(
              MAKEARRAY(n,1,LAMBDA(x,y,eom)),
              MAKEARRAY(n,1,LAMBDA(x,y,owner)),
              MAKEARRAY(n,1,LAMBDA(x,y,movement)),
              CHOOSECOLS(r,1),
              CHOOSECOLS(r,2),
              SEQUENCE(n)
            )
          )
        )
      )
    )
  ),

  VSTACK(
    mk("Samya","Downgrade IN (ex-Auto)", dSamya),
    mk("Samya","Exit (ex-Auto)", eSamya),
    mk("Connor","Downgrade IN (ex-Auto)", dConnor),
    mk("Connor","Exit (ex-Auto)", eConnor),
    mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
    mk("Daniel","Exit (ex-Auto)", eDaniel),
    mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
    mk("Eleanor","Exit (ex-Auto)", eEleanor),
    mk("Casey","Downgrade IN (ex-Auto)", dCasey),
    mk("Casey","Exit (ex-Auto)", eCasey)
  )
)







=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

  mk, LAMBDA(owner, movement, rng,
    LET(
      rr, IFERROR(rng, ""),
      has2, IFERROR(COLUMNS(rr)>=2, FALSE),
      empty6, TAKE(SEQUENCE(1,6), 0),
      IF(
        NOT(has2),
        empty6,
        LET(
          r, rr,
          n, ROWS(r),
          IF(
            n=0,
            empty6,
            HSTACK(
              MAKEARRAY(n,1,LAMBDA(x,y,eom)),
              MAKEARRAY(n,1,LAMBDA(x,y,owner)),
              MAKEARRAY(n,1,LAMBDA(x,y,movement)),
              CHOOSECOLS(r,1),
              CHOOSECOLS(r,2),
              SEQUENCE(n)
            )
          )
        )
      )
    )
  ),

  VSTACK(
    mk("Samya","Downgrade IN (ex-Auto)", dSamya),
    mk("Samya","Exit (ex-Auto)", eSamya),
    mk("Connor","Downgrade IN (ex-Auto)", dConnor),
    mk("Connor","Exit (ex-Auto)", eConnor),
    mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
    mk("Daniel","Exit (ex-Auto)", eDaniel),
    mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
    mk("Eleanor","Exit (ex-Auto)", eEleanor),
    mk("Casey","Downgrade IN (ex-Auto)", dCasey),
    mk("Casey","Exit (ex-Auto)", eCasey)
  )
)





=LET(
  eom, Top30_Engine!$B$5,
  dSamya, Top30_Engine!$AA$14#,
  eSamya, Top30_Engine!$AA$55#,
  dConnor, Top30_Engine!$A$14#,
  eConnor, Top30_Engine!$A$55#,
  dDaniel, Top30_Engine!$J$14#,
  eDaniel, Top30_Engine!$R$14#,
  dEleanor, Top30_Engine!$AQ$14#,
  eEleanor, Top30_Engine!$AQ$55#,
  dCasey, Top30_Engine!$AI$14#,
  eCasey, Top30_Engine!$AI$55#,

mk, LAMBDA(owner,movement,rng,
  LET(
    r, IFERROR(rng, TAKE(SEQUENCE(1,2),0)),
    n, ROWS(r),
    empty6, TAKE(SEQUENCE(1,6),0),
    IF(
      n=0,
      empty6,
      HSTACK(
        MAKEARRAY(n,1,LAMBDA(x,y,eom)),
        MAKEARRAY(n,1,LAMBDA(x,y,owner)),
        MAKEARRAY(n,1,LAMBDA(x,y,movement)),
        CHOOSECOLS(r,1),
        CHOOSECOLS(r,2),
        SEQUENCE(n)
      )
    )
  )
),

  VSTACK(
    mk("Samya","Downgrade IN (ex-Auto)", dSamya),
    mk("Samya","Exit (ex-Auto)", eSamya),
    mk("Connor","Downgrade IN (ex-Auto)", dConnor),
    mk("Connor","Exit (ex-Auto)", eConnor),
    mk("Daniel","Downgrade IN (ex-Auto)", dDaniel),
    mk("Daniel","Exit (ex-Auto)", eDaniel),
    mk("Eleanor","Downgrade IN (ex-Auto)", dEleanor),
    mk("Eleanor","Exit (ex-Auto)", eEleanor),
    mk("Casey","Downgrade IN (ex-Auto)", dCasey),
    mk("Casey","Exit (ex-Auto)", eCasey)
  )
)






mk, LAMBDA(owner, movement, rng,
  LET(
    r, IFERROR(rng, TAKE(SEQUENCE(1,2),0)),          /* ALWAYS 2-col array */
    n, ROWS(r),
    empty6, TAKE(SEQUENCE(1,6),0),                   /* ALWAYS 6-col empty array */
    IF(
      n=0,
      empty6,
      HSTACK(
        MAKEARRAY(n,1,LAMBDA(x,y,eom)),
        MAKEARRAY(n,1,LAMBDA(x,y,owner)),
        MAKEARRAY(n,1,LAMBDA(x,y,movement)),
        CHOOSECOLS(r,1),
        CHOOSECOLS(r,2),
        SEQUENCE(n)
      )
    )
  )
),





mk, LAMBDA(owner, movement, rng,
  LET(
    r, IFERROR(rng, ""),
    empty6, DROP(SEQUENCE(1,6),1),         /* 0 rows x 6 cols */
    IF(
      OR(r="", IFERROR(ROWS(r),0)=0),
      empty6,
      LET(
        n, ROWS(r),
        HSTACK(
          MAKEARRAY(n,1,LAMBDA(x,y,eom)),
          MAKEARRAY(n,1,LAMBDA(x,y,owner)),
          MAKEARRAY(n,1,LAMBDA(x,y,movement)),
          CHOOSECOLS(r,1),
          CHOOSECOLS(r,2),
          SEQUENCE(n)
        )
      )
    )
  )
),





mk, LAMBDA(owner, movement, rng,
  LET(
    r, IFERROR(rng,""),
    IF( OR(r="", ROWS(r)=0),
      "",
      HSTACK(
        MAKEARRAY(ROWS(r),1,LAMBDA(x,y,eom)),
        MAKEARRAY(ROWS(r),1,LAMBDA(x,y,owner)),
        MAKEARRAY(ROWS(r),1,LAMBDA(x,y,movement)),
        CHOOSECOLS(r,1),
        CHOOSECOLS(r,2),
        SEQUENCE(ROWS(r))
      )
    )
  )
),





=LET(
  eom, Top30_Engine!$B$2,
  dSamya, Top30_Engine!$A$7#, 
  eSamya, Top30_Engine!$H$7#,

  mk, LAMBDA(owner, movement, rng,
    IF(ROWS(rng)=0,"",
      HSTACK(
        MAKEARRAY(ROWS(rng),1,LAMBDA(r,c,eom)),
        MAKEARRAY(ROWS(rng),1,LAMBDA(r,c,owner)),
        MAKEARRAY(ROWS(rng),1,LAMBDA(r,c,movement)),
        CHOOSECOLS(rng,1),              /* FACILITY_EVENT col */
        CHOOSECOLS(rng,2),              /* EXPOSURE_BASIS col */
        SEQUENCE(ROWS(rng))             /* OWNER_RANK */
      )
    )
  ),

  VSTACK(
    mk("Samya","Downgrade IN (ex-Auto)", dSamya),
    mk("Samya","Exit (ex-Auto)", eSamya)
  )
)






let
    // ============================================================
    // 0) Sources
    // ============================================================
    Source0 = pq_Facility_Rollup_All,
    ReviewedSummaryRaw0 = Excel.CurrentWorkbook(){[Name="PBI_Feed_Reviewed_Summary_Current"]}[Content],

    // ============================================================
    // 1) Reviewed Summary: Types + Clean Keys
    // ============================================================
    ReviewedSummaryTypes =
        Table.TransformColumnTypes(
            ReviewedSummaryRaw0,
            {
                {"CURR_EOM_DATE", type any},
                {"OWNER_EVENT", type text},
                {"MOVEMENT_TYPE", type text},
                {"TOPN_USED", Int64.Type},
                {"REVIEWED_BALANCE", type number}
            }
        ),

    ReviewedSummaryDateKey =
        Table.AddColumn(
            ReviewedSummaryTypes,
            "CURR_EOM_DATE_KEY",
            each
                let v = [CURR_EOM_DATE]
                in
                    if v is date then v
                    else if v is datetime then Date.From(v)
                    else try Date.From(v) otherwise try Date.FromText(Text.From(v)) otherwise null,
            type date
        ),

    ReviewedSummaryOwnerKey =
        Table.AddColumn(
            ReviewedSummaryDateKey,
            "OWNER_KEY",
            each Text.Upper(Text.Trim(Text.Clean([OWNER_EVENT]))),
            type text
        ),

    ReviewedSummaryMovementKey =
        Table.AddColumn(
            ReviewedSummaryOwnerKey,
            "MOVEMENT_KEY",
            each Text.Trim(Text.Clean([MOVEMENT_TYPE])),
            type text
        ),

    ReviewedSummarySlim =
        Table.SelectColumns(
            ReviewedSummaryMovementKey,
            {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY","TOPN_USED"}
        ),

    SummaryMaxDate =
        List.Max(List.RemoveNulls(ReviewedSummarySlim[CURR_EOM_DATE_KEY])),

    ReviewedSummaryCurrentMonth =
        Table.SelectRows(ReviewedSummarySlim, each [CURR_EOM_DATE_KEY] = SummaryMaxDate),

    ReviewedSummaryLookup =
        Table.Distinct(
            Table.SelectColumns(ReviewedSummaryCurrentMonth, {"OWNER_KEY","MOVEMENT_KEY","TOPN_USED"}),
            {"OWNER_KEY","MOVEMENT_KEY"}
        ),

    // ============================================================
    // 2) Base facility movement set: select, type, filter
    // ============================================================
    BaseKeep =
        Table.SelectColumns(
            Source0,
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"
            }
        ),

    BaseTypes =
        Table.TransformColumnTypes(
            BaseKeep,
            {
                {"ME_DATE", type any},
                {"BANK_EVENT", type text},
                {"FACILITY_EVENT", type text},
                {"OWNER_EVENT", type text},
                {"MOVEMENT_TYPE", type text},
                {"PREV_SSB_SUM", type number},
                {"CURR_SSB_SUM", type number},
                {"MOM_DELTA_SUM", type number},
                {"REVIEWABLE_FLAG_MAX", Int64.Type}
            }
        ),

    MovementFiltered =
        Table.SelectRows(
            BaseTypes,
            each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
              or [MOVEMENT_TYPE] = "Exit (ex-Auto)"
        ),

    OwnerFiltered =
        Table.SelectRows(
            MovementFiltered,
            each not (
                [OWNER_EVENT] = "NOT COVERED"
                or Text.StartsWith([OWNER_EVENT], "Not Covered; Under")
            )
        ),

    AddExposureBasis =
        Table.AddColumn(
            OwnerFiltered,
            "EXPOSURE_BASIS",
            each
                if [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)" then [CURR_SSB_SUM]
                else if [MOVEMENT_TYPE] = "Exit (ex-Auto)" then [PREV_SSB_SUM]
                else null,
            type number
        ),

    // ============================================================
    // 3) Remove key columns if they already exist (safe)
    // ============================================================
    RemoveIfExists =
        (tbl as table, colName as text) as table =>
            if List.Contains(Table.ColumnNames(tbl), colName) then Table.RemoveColumns(tbl, {colName}) else tbl,

    NoMEKey = RemoveIfExists(AddExposureBasis, "ME_DATE_KEY"),
    NoOwnerKey = RemoveIfExists(NoMEKey, "OWNER_KEY"),
    NoMoveKey = RemoveIfExists(NoOwnerKey, "MOVEMENT_KEY"),

    // ============================================================
    // 4) Add facility-side keys (robust)
    // ============================================================
    AddMeDateKey =
        Table.AddColumn(
            NoMoveKey,
            "ME_DATE_KEY",
            each
                let v = [ME_DATE]
                in
                    if v is date then v
                    else if v is datetime then Date.From(v)
                    else try Date.From(v) otherwise try Date.FromText(Text.From(v)) otherwise null,
            type date
        ),

    AddOwnerKey =
        Table.AddColumn(
            AddMeDateKey,
            "OWNER_KEY",
            each Text.Upper(Text.Trim(Text.Clean([OWNER_EVENT]))),
            type text
        ),

    AddMovementKey =
        Table.AddColumn(
            AddOwnerKey,
            "MOVEMENT_KEY",
            each Text.Trim(Text.Clean([MOVEMENT_TYPE])),
            type text
        ),

    // ============================================================
    // 5) Primary join on (date, owner, movement)
    // ============================================================
    JoinedPrimary =
        Table.NestedJoin(
            AddMovementKey,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            ReviewedSummarySlim,
            {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            "TopN_Primary",
            JoinKind.LeftOuter
        ),

    ExpandedPrimary =
        Table.ExpandTableColumn(
            JoinedPrimary,
            "TopN_Primary",
            {"TOPN_USED"},
            {"TOPN_USED_PRIMARY"}
        ),

    // ============================================================
    // 6) Fallback join on (owner, movement) using summary max date
    // ============================================================
    JoinedFallback =
        Table.NestedJoin(
            ExpandedPrimary,
            {"OWNER_KEY","MOVEMENT_KEY"},
            ReviewedSummaryLookup,
            {"OWNER_KEY","MOVEMENT_KEY"},
            "TopN_Fallback",
            JoinKind.LeftOuter
        ),

    ExpandedFallback =
        Table.ExpandTableColumn(
            JoinedFallback,
            "TopN_Fallback",
            {"TOPN_USED"},
            {"TOPN_USED_FALLBACK"}
        ),

    // ============================================================
    // 7) Final TOPN_LIMIT (primary > fallback > default 30)
    // ============================================================
    AddTopNLimit =
        Table.AddColumn(
            ExpandedFallback,
            "TOPN_LIMIT",
            each
                if [TOPN_USED_PRIMARY] <> null then [TOPN_USED_PRIMARY]
                else if [TOPN_USED_FALLBACK] <> null then [TOPN_USED_FALLBACK]
                else 30,
            Int64.Type
        ),

    AddTopNSource =
        Table.AddColumn(
            AddTopNLimit,
            "TOPN_SOURCE",
            each
                if [TOPN_USED_PRIMARY] <> null then "PRIMARY_JOIN"
                else if [TOPN_USED_FALLBACK] <> null then "FALLBACK_JOIN"
                else "DEFAULT_30",
            type text
        ),

    // ============================================================
    // 8) De-dupe + sort for rank
    // ============================================================
    Dedup =
        Table.Distinct(
            AddTopNSource,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY","FACILITY_EVENT"}
        ),

    SortForRank =
        Table.Sort(
            Dedup,
            {
                {"ME_DATE_KEY", Order.Ascending},
                {"OWNER_KEY", Order.Ascending},
                {"MOVEMENT_KEY", Order.Ascending},
                {"EXPOSURE_BASIS", Order.Descending}
            }
        ),

    // ============================================================
    // 9) Group, rank, flag (IMPORTANT: do NOT expand ME_DATE_KEY again)
    // ============================================================
    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "OWNER_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(
                            t2,
                            "TOPN_OWNER_FLAG",
                            each if [OWNER_RANK] <= [TOPN_LIMIT] then "Y" else "N",
                            type text
                        )
                    in
                        t3,
                 type table}
            }
        ),

    // Expand ONLY non-key columns from Data (keys already exist in Grouped record)
    Expanded =
        Table.ExpandTableColumn(
            Grouped,
            "Data",
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX",
                "EXPOSURE_BASIS","TOPN_USED_PRIMARY","TOPN_USED_FALLBACK",
                "TOPN_LIMIT","TOPN_SOURCE","OWNER_RANK","TOPN_OWNER_FLAG"
            },
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX",
                "EXPOSURE_BASIS","TOPN_USED_PRIMARY","TOPN_USED_FALLBACK",
                "TOPN_LIMIT","TOPN_SOURCE","OWNER_RANK","TOPN_OWNER_FLAG"
            }
        ),

    // ============================================================
    // 10) Final shaping
    // ============================================================
    Rename = Table.RenameColumns(Expanded, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddAbsDelta = Table.AddColumn(Rename, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),
    AddRunTs = Table.AddColumn(AddAbsDelta, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs






let
    // ============================================================
    // 0) Sources
    // ============================================================
    Source0 = pq_Facility_Rollup_All,
    ReviewedSummaryRaw0 = Excel.CurrentWorkbook(){[Name="PBI_Feed_Reviewed_Summary_Current"]}[Content],

    // ============================================================
    // 1) Reviewed Summary: Types + Clean Keys
    // ============================================================
    ReviewedSummaryTypes =
        Table.TransformColumnTypes(
            ReviewedSummaryRaw0,
            {
                {"CURR_EOM_DATE", type any},
                {"OWNER_EVENT", type text},
                {"MOVEMENT_TYPE", type text},
                {"TOPN_USED", Int64.Type},
                {"REVIEWED_BALANCE", type number}
            }
        ),

    ReviewedSummaryDateKey =
        Table.AddColumn(
            ReviewedSummaryTypes,
            "CURR_EOM_DATE_KEY",
            each
                let v = [CURR_EOM_DATE]
                in
                    if v is date then v
                    else if v is datetime then Date.From(v)
                    else try Date.From(v) otherwise try Date.FromText(Text.From(v)) otherwise null,
            type date
        ),

    ReviewedSummaryOwnerKey =
        Table.AddColumn(
            ReviewedSummaryDateKey,
            "OWNER_KEY",
            each Text.Upper(Text.Trim(Text.Clean([OWNER_EVENT]))),
            type text
        ),

    ReviewedSummaryMovementKey =
        Table.AddColumn(
            ReviewedSummaryOwnerKey,
            "MOVEMENT_KEY",
            each Text.Trim(Text.Clean([MOVEMENT_TYPE])),
            type text
        ),

    ReviewedSummarySlim =
        Table.SelectColumns(
            ReviewedSummaryMovementKey,
            {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY","TOPN_USED"}
        ),

    SummaryMaxDate =
        List.Max(List.RemoveNulls(ReviewedSummarySlim[CURR_EOM_DATE_KEY])),

    ReviewedSummaryCurrentMonth =
        Table.SelectRows(ReviewedSummarySlim, each [CURR_EOM_DATE_KEY] = SummaryMaxDate),

    ReviewedSummaryLookup =
        Table.Distinct(
            Table.SelectColumns(ReviewedSummaryCurrentMonth, {"OWNER_KEY","MOVEMENT_KEY","TOPN_USED"}),
            {"OWNER_KEY","MOVEMENT_KEY"}
        ),

    // ============================================================
    // 2) Base facility movement set: select, type, filter
    // ============================================================
    BaseKeep =
        Table.SelectColumns(
            Source0,
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"
            }
        ),

    BaseTypes =
        Table.TransformColumnTypes(
            BaseKeep,
            {
                {"ME_DATE", type any},
                {"BANK_EVENT", type text},
                {"FACILITY_EVENT", type text},
                {"OWNER_EVENT", type text},
                {"MOVEMENT_TYPE", type text},
                {"PREV_SSB_SUM", type number},
                {"CURR_SSB_SUM", type number},
                {"MOM_DELTA_SUM", type number},
                {"REVIEWABLE_FLAG_MAX", Int64.Type}
            }
        ),

    MovementFiltered =
        Table.SelectRows(
            BaseTypes,
            each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
              or [MOVEMENT_TYPE] = "Exit (ex-Auto)"
        ),

    OwnerFiltered =
        Table.SelectRows(
            MovementFiltered,
            each not (
                [OWNER_EVENT] = "NOT COVERED"
                or Text.StartsWith([OWNER_EVENT], "Not Covered; Under")
            )
        ),

    AddExposureBasis =
        Table.AddColumn(
            OwnerFiltered,
            "EXPOSURE_BASIS",
            each
                if [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)" then [CURR_SSB_SUM]
                else if [MOVEMENT_TYPE] = "Exit (ex-Auto)" then [PREV_SSB_SUM]
                else null,
            type number
        ),

    // ============================================================
    // 3) Safety: remove key columns if they already exist
    // ============================================================
    ExistingCols = Table.ColumnNames(AddExposureBasis),

    RemoveIfExists =
        (tbl as table, colName as text) as table =>
            if List.Contains(Table.ColumnNames(tbl), colName) then Table.RemoveColumns(tbl, {colName}) else tbl,

    NoMEKey = RemoveIfExists(AddExposureBasis, "ME_DATE_KEY"),
    NoOwnerKey = RemoveIfExists(NoMEKey, "OWNER_KEY"),
    NoMoveKey = RemoveIfExists(NoOwnerKey, "MOVEMENT_KEY"),

    // ============================================================
    // 4) Add facility-side keys (robust)
    // ============================================================
    AddMeDateKey =
        Table.AddColumn(
            NoMoveKey,
            "ME_DATE_KEY",
            each
                let v = [ME_DATE]
                in
                    if v is date then v
                    else if v is datetime then Date.From(v)
                    else try Date.From(v) otherwise try Date.FromText(Text.From(v)) otherwise null,
            type date
        ),

    AddOwnerKey =
        Table.AddColumn(
            AddMeDateKey,
            "OWNER_KEY",
            each Text.Upper(Text.Trim(Text.Clean([OWNER_EVENT]))),
            type text
        ),

    AddMovementKey =
        Table.AddColumn(
            AddOwnerKey,
            "MOVEMENT_KEY",
            each Text.Trim(Text.Clean([MOVEMENT_TYPE])),
            type text
        ),

    // ============================================================
    // 5) Primary join on (date, owner, movement)
    // ============================================================
    JoinedPrimary =
        Table.NestedJoin(
            AddMovementKey,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            ReviewedSummarySlim,
            {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            "TopN_Primary",
            JoinKind.LeftOuter
        ),

    ExpandedPrimary =
        Table.ExpandTableColumn(
            JoinedPrimary,
            "TopN_Primary",
            {"TOPN_USED"},
            {"TOPN_USED_PRIMARY"}
        ),

    // ============================================================
    // 6) Fallback join on (owner, movement) using summary's max date
    // ============================================================
    JoinedFallback =
        Table.NestedJoin(
            ExpandedPrimary,
            {"OWNER_KEY","MOVEMENT_KEY"},
            ReviewedSummaryLookup,
            {"OWNER_KEY","MOVEMENT_KEY"},
            "TopN_Fallback",
            JoinKind.LeftOuter
        ),

    ExpandedFallback =
        Table.ExpandTableColumn(
            JoinedFallback,
            "TopN_Fallback",
            {"TOPN_USED"},
            {"TOPN_USED_FALLBACK"}
        ),

    // ============================================================
    // 7) Final TOPN_LIMIT (primary > fallback > default 30)
    // ============================================================
    AddTopNLimit =
        Table.AddColumn(
            ExpandedFallback,
            "TOPN_LIMIT",
            each
                if [TOPN_USED_PRIMARY] <> null then [TOPN_USED_PRIMARY]
                else if [TOPN_USED_FALLBACK] <> null then [TOPN_USED_FALLBACK]
                else 30,
            Int64.Type
        ),

    AddTopNSource =
        Table.AddColumn(
            AddTopNLimit,
            "TOPN_SOURCE",
            each
                if [TOPN_USED_PRIMARY] <> null then "PRIMARY_JOIN"
                else if [TOPN_USED_FALLBACK] <> null then "FALLBACK_JOIN"
                else "DEFAULT_30",
            type text
        ),

    // ============================================================
    // 8) De-dupe + rank within (month, owner, movement)
    // ============================================================
    Dedup =
        Table.Distinct(
            AddTopNSource,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY","FACILITY_EVENT"}
        ),

    SortForRank =
        Table.Sort(
            Dedup,
            {
                {"ME_DATE_KEY", Order.Ascending},
                {"OWNER_KEY", Order.Ascending},
                {"MOVEMENT_KEY", Order.Ascending},
                {"EXPOSURE_BASIS", Order.Descending}
            }
        ),

    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "OWNER_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(
                            t2,
                            "TOPN_OWNER_FLAG",
                            each if [OWNER_RANK] <= [TOPN_LIMIT] then "Y" else "N",
                            type text
                        )
                    in
                        t3,
                 type table}
            }
        ),

    Expanded =
        Table.ExpandTableColumn(
            Grouped,
            "Data",
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX",
                "EXPOSURE_BASIS","ME_DATE_KEY","TOPN_USED_PRIMARY","TOPN_USED_FALLBACK",
                "TOPN_LIMIT","TOPN_SOURCE","OWNER_RANK","TOPN_OWNER_FLAG"
            },
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX",
                "EXPOSURE_BASIS","ME_DATE_KEY","TOPN_USED_PRIMARY","TOPN_USED_FALLBACK",
                "TOPN_LIMIT","TOPN_SOURCE","OWNER_RANK","TOPN_OWNER_FLAG"
            }
        ),

    // ============================================================
    // 9) Final shaping
    // ============================================================
    Rename = Table.RenameColumns(Expanded, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddAbsDelta = Table.AddColumn(Rename, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),
    AddRunTs = Table.AddColumn(AddAbsDelta, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs







let
    // ============================================================
    // 0) Sources
    // ============================================================
    Source = pq_Facility_Rollup_All,
    ReviewedSummaryRaw = Excel.CurrentWorkbook(){[Name="PBI_Feed_Reviewed_Summary_Current"]}[Content],

    // ============================================================
    // 1) Reviewed Summary: Types + Clean Keys
    // ============================================================
    ReviewedSummaryTypes =
        Table.TransformColumnTypes(
            ReviewedSummaryRaw,
            {
                {"CURR_EOM_DATE", type any},  // we'll coerce robustly below
                {"OWNER_EVENT", type text},
                {"MOVEMENT_TYPE", type text},
                {"TOPN_USED", Int64.Type},
                {"REVIEWED_BALANCE", type number}
            }
        ),

    // Robust date coercion (handles text/date/datetime)
    ReviewedSummaryDateKey =
        Table.AddColumn(
            ReviewedSummaryTypes,
            "CURR_EOM_DATE_KEY",
            each
                let v = [CURR_EOM_DATE]
                in
                    if v is date then v
                    else if v is datetime then Date.From(v)
                    else try Date.From(v) otherwise try Date.FromText(Text.From(v)) otherwise null,
            type date
        ),

    ReviewedSummaryOwnerKey =
        Table.AddColumn(
            ReviewedSummaryDateKey,
            "OWNER_KEY",
            each Text.Upper(Text.Trim(Text.Clean([OWNER_EVENT]))),
            type text
        ),

    ReviewedSummaryMovementKey =
        Table.AddColumn(
            ReviewedSummaryOwnerKey,
            "MOVEMENT_KEY",
            each Text.Trim(Text.Clean([MOVEMENT_TYPE])),
            type text
        ),

    ReviewedSummarySlim =
        Table.SelectColumns(
            ReviewedSummaryMovementKey,
            {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY","TOPN_USED"}
        ),

    // Determine "current month" from the reviewed summary (max date)
    SummaryMaxDate =
        List.Max(List.RemoveNulls(ReviewedSummarySlim[CURR_EOM_DATE_KEY])),

    // Create fallback lookup table for current month: (OWNER_KEY, MOVEMENT_KEY) -> TOPN_USED
    ReviewedSummaryCurrentMonth =
        Table.SelectRows(ReviewedSummarySlim, each [CURR_EOM_DATE_KEY] = SummaryMaxDate),

    ReviewedSummaryLookup =
        Table.Distinct(
            Table.SelectColumns(ReviewedSummaryCurrentMonth, {"OWNER_KEY","MOVEMENT_KEY","TOPN_USED"}),
            {"OWNER_KEY","MOVEMENT_KEY"}
        ),

    // ============================================================
    // 2) Base facility movement set: select, type, filter
    // ============================================================
    BaseKeep =
        Table.SelectColumns(
            Source,
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"
            }
        ),

    BaseTypes =
        Table.TransformColumnTypes(
            BaseKeep,
            {
                {"ME_DATE", type any},  // robust date handling below
                {"BANK_EVENT", type text},
                {"FACILITY_EVENT", type text},
                {"OWNER_EVENT", type text},
                {"MOVEMENT_TYPE", type text},
                {"PREV_SSB_SUM", type number},
                {"CURR_SSB_SUM", type number},
                {"MOM_DELTA_SUM", type number},
                {"REVIEWABLE_FLAG_MAX", Int64.Type}
            }
        ),

    // Only review movements
    MovementFiltered =
        Table.SelectRows(
            BaseTypes,
            each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
              or [MOVEMENT_TYPE] = "Exit (ex-Auto)"
        ),

    // Remove pseudo-owners
    OwnerFiltered =
        Table.SelectRows(
            MovementFiltered,
            each not (
                [OWNER_EVENT] = "NOT COVERED"
                or Text.StartsWith([OWNER_EVENT], "Not Covered; Under")
            )
        ),

    // Exposure basis for ranking
    AddExposureBasis =
        Table.AddColumn(
            OwnerFiltered,
            "EXPOSURE_BASIS",
            each
                if [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)" then [CURR_SSB_SUM]
                else if [MOVEMENT_TYPE] = "Exit (ex-Auto)" then [PREV_SSB_SUM]
                else null,
            type number
        ),

    // ============================================================
    // 3) Facility-side keys (robust date + clean text)
    // ============================================================
    AddMeDateKey =
        Table.AddColumn(
            AddExposureBasis,
            "ME_DATE_KEY",
            each
                let v = [ME_DATE]
                in
                    if v is date then v
                    else if v is datetime then Date.From(v)
                    else try Date.From(v) otherwise try Date.FromText(Text.From(v)) otherwise null,
            type date
        ),

    AddOwnerKey =
        Table.AddColumn(
            AddMeDateKey,
            "OWNER_KEY",
            each Text.Upper(Text.Trim(Text.Clean([OWNER_EVENT]))),
            type text
        ),

    AddMovementKey =
        Table.AddColumn(
            AddOwnerKey,
            "MOVEMENT_KEY",
            each Text.Trim(Text.Clean([MOVEMENT_TYPE])),
            type text
        ),

    // ============================================================
    // 4) Primary join on (date, owner, movement)
    // ============================================================
    JoinedPrimary =
        Table.NestedJoin(
            AddMovementKey,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            ReviewedSummarySlim,
            {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            "TopN_Primary",
            JoinKind.LeftOuter
        ),

    ExpandedPrimary =
        Table.ExpandTableColumn(
            JoinedPrimary,
            "TopN_Primary",
            {"TOPN_USED"},
            {"TOPN_USED_PRIMARY"}
        ),

    // ============================================================
    // 5) Fallback join on (owner, movement) using summary's current month
    //     (This fixes cases where date keys don't line up)
    // ============================================================
    JoinedFallback =
        Table.NestedJoin(
            ExpandedPrimary,
            {"OWNER_KEY","MOVEMENT_KEY"},
            ReviewedSummaryLookup,
            {"OWNER_KEY","MOVEMENT_KEY"},
            "TopN_Fallback",
            JoinKind.LeftOuter
        ),

    ExpandedFallback =
        Table.ExpandTableColumn(
            JoinedFallback,
            "TopN_Fallback",
            {"TOPN_USED"},
            {"TOPN_USED_FALLBACK"}
        ),

    // ============================================================
    // 6) Final TOPN_LIMIT selection logic
    //     Primary match wins, else fallback, else default 30
    // ============================================================
    AddTopNLimit =
        Table.AddColumn(
            ExpandedFallback,
            "TOPN_LIMIT",
            each
                if [TOPN_USED_PRIMARY] <> null then [TOPN_USED_PRIMARY]
                else if [TOPN_USED_FALLBACK] <> null then [TOPN_USED_FALLBACK]
                else 30,
            Int64.Type
        ),

    AddTopNSource =
        Table.AddColumn(
            AddTopNLimit,
            "TOPN_SOURCE",
            each
                if [TOPN_USED_PRIMARY] <> null then "PRIMARY_JOIN"
                else if [TOPN_USED_FALLBACK] <> null then "FALLBACK_JOIN"
                else "DEFAULT_30",
            type text
        ),

    // ============================================================
    // 7) De-dupe per (month, owner, movement, facility)
    // ============================================================
    Dedup =
        Table.Distinct(
            AddTopNSource,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY","FACILITY_EVENT"}
        ),

    // ============================================================
    // 8) Rank within (month, owner, movement) by exposure
    // ============================================================
    SortForRank =
        Table.Sort(
            Dedup,
            {
                {"ME_DATE_KEY", Order.Ascending},
                {"OWNER_KEY", Order.Ascending},
                {"MOVEMENT_KEY", Order.Ascending},
                {"EXPOSURE_BASIS", Order.Descending}
            }
        ),

    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "OWNER_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(
                            t2,
                            "TOPN_OWNER_FLAG",
                            each if [OWNER_RANK] <= [TOPN_LIMIT] then "Y" else "N",
                            type text
                        )
                    in
                        t3,
                 type table}
            }
        ),

    Expanded =
        Table.ExpandTableColumn(
            Grouped,
            "Data",
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX",
                "EXPOSURE_BASIS","ME_DATE_KEY","TOPN_USED_PRIMARY","TOPN_USED_FALLBACK",
                "TOPN_LIMIT","TOPN_SOURCE","OWNER_RANK","TOPN_OWNER_FLAG","OWNER_KEY","MOVEMENT_KEY"
            },
            {
                "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
                "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX",
                "EXPOSURE_BASIS","ME_DATE_KEY","TOPN_USED_PRIMARY","TOPN_USED_FALLBACK",
                "TOPN_LIMIT","TOPN_SOURCE","OWNER_RANK","TOPN_OWNER_FLAG","OWNER_KEY","MOVEMENT_KEY"
            }
        ),

    // ============================================================
    // 9) Final shaping
    // ============================================================
    Rename =
        Table.RenameColumns(Expanded, {{"ME_DATE","CURR_EOM_DATE"}}),

    AddAbsDelta =
        Table.AddColumn(Rename, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),

    AddRunTs =
        Table.AddColumn(AddAbsDelta, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    // ============================================================
    // 0) Sources
    // ============================================================
    Source = pq_Facility_Rollup_All,

    ReviewedSummaryRaw = Excel.CurrentWorkbook(){[Name="PBI_Feed_Reviewed_Summary_Current"]}[Content],

    ReviewedSummaryTypes = Table.TransformColumnTypes(
        ReviewedSummaryRaw,
        {
            {"CURR_EOM_DATE", type date},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"TOPN_USED", Int64.Type},
            {"REVIEWED_BALANCE", type number}
        }
    ),

    // Normalize join keys on Reviewed Summary (trim + upper + date)
    ReviewedSummaryKey1 = Table.AddColumn(ReviewedSummaryTypes, "CURR_EOM_DATE_KEY", each Date.From([CURR_EOM_DATE]), type date),
    ReviewedSummaryKey2 = Table.AddColumn(ReviewedSummaryKey1, "OWNER_KEY", each Text.Upper(Text.Trim([OWNER_EVENT])), type text),
    ReviewedSummaryKey3 = Table.AddColumn(ReviewedSummaryKey2, "MOVEMENT_KEY", each Text.Trim([MOVEMENT_TYPE]), type text),

    ReviewedSummarySlim = Table.SelectColumns(
        ReviewedSummaryKey3,
        {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY","TOPN_USED"}
    ),

    // ============================================================
    // 1) Base facility movement set (from pq_Facility_Rollup_All)
    // ============================================================
    BaseKeep = Table.SelectColumns(
        Source,
        {
            "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
            "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"
        }
    ),

    BaseTypes = Table.TransformColumnTypes(
        BaseKeep,
        {
            {"ME_DATE", type date},
            {"BANK_EVENT", type text},
            {"FACILITY_EVENT", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // ============================================================
    // 2) Filter to movements in scope (Downgrade IN + Exit only)
    // ============================================================
    MovementFiltered = Table.SelectRows(
        BaseTypes,
        each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
          or [MOVEMENT_TYPE] = "Exit (ex-Auto)"
    ),

    // ============================================================
    // 3) Remove pseudo-owners (NOT COVERED / Under $ buckets)
    // ============================================================
    OwnerFiltered = Table.SelectRows(
        MovementFiltered,
        each not (
            [OWNER_EVENT] = "NOT COVERED"
            or Text.StartsWith([OWNER_EVENT], "Not Covered; Under")
        )
    ),

    // ============================================================
    // 4) Exposure basis for ranking
    //    - Downgrade IN ranks by current exposure
    //    - Exit ranks by previous exposure
    // ============================================================
    AddExposureBasis = Table.AddColumn(
        OwnerFiltered,
        "EXPOSURE_BASIS",
        each
            if [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)" then [CURR_SSB_SUM]
            else if [MOVEMENT_TYPE] = "Exit (ex-Auto)" then [PREV_SSB_SUM]
            else null,
        type number
    ),

    // ============================================================
    // 5) Normalize join keys on facility side
    // ============================================================
    AddKey1 = Table.AddColumn(AddExposureBasis, "ME_DATE_KEY", each Date.From([ME_DATE]), type date),
    AddKey2 = Table.AddColumn(AddKey1, "OWNER_KEY", each Text.Upper(Text.Trim([OWNER_EVENT])), type text),
    AddKey3 = Table.AddColumn(AddKey2, "MOVEMENT_KEY", each Text.Trim([MOVEMENT_TYPE]), type text),

    // ============================================================
    // 6) Join to Reviewed Summary to fetch TOPN_USED (TopN limit)
    //    Default to 30 if not found
    // ============================================================
    Joined = Table.NestedJoin(
        AddKey3,
        {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
        ReviewedSummarySlim,
        {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
        "TopN",
        JoinKind.LeftOuter
    ),

    ExpandedTopN = Table.ExpandTableColumn(Joined, "TopN", {"TOPN_USED"}, {"TOPN_USED"}),

    AddTopNLimit = Table.AddColumn(
        ExpandedTopN,
        "TOPN_LIMIT",
        each if [TOPN_USED] <> null then [TOPN_USED] else 30,
        Int64.Type
    ),

    // Optional debug: keep a join-hit flag (remove later if you want)
    AddJoinHit = Table.AddColumn(
        AddTopNLimit,
        "TOPN_JOIN_HIT",
        each if [TOPN_USED] <> null then 1 else 0,
        Int64.Type
    ),

    // ============================================================
    // 7) De-dupe: one facility per (month, owner, movement)
    // ============================================================
    Dedup = Table.Distinct(
        AddJoinHit,
        {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY","FACILITY_EVENT"}
    ),

    // ============================================================
    // 8) Rank within (ME_DATE, OWNER_EVENT, MOVEMENT_TYPE) by exposure basis
    // ============================================================
    SortForRank = Table.Sort(
        Dedup,
        {
            {"ME_DATE_KEY", Order.Ascending},
            {"OWNER_KEY", Order.Ascending},
            {"MOVEMENT_KEY", Order.Ascending},
            {"EXPOSURE_BASIS", Order.Descending}
        }
    ),

    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "OWNER_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(
                            t2,
                            "TOPN_OWNER_FLAG",
                            each if [OWNER_RANK] <= [TOPN_LIMIT] then "Y" else "N",
                            type text
                        )
                    in
                        t3,
                 type table}
            }
        ),

    Expanded = Table.ExpandTableColumn(
        Grouped,
        "Data",
        {
            "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
            "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX",
            "EXPOSURE_BASIS","TOPN_USED","TOPN_LIMIT","TOPN_JOIN_HIT","OWNER_RANK","TOPN_OWNER_FLAG"
        },
        {
            "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
            "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX",
            "EXPOSURE_BASIS","TOPN_USED","TOPN_LIMIT","TOPN_JOIN_HIT","OWNER_RANK","TOPN_OWNER_FLAG"
        }
    ),

    // ============================================================
    // 9) Final shaping
    // ============================================================
    Rename = Table.RenameColumns(Expanded, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddAbsDelta = Table.AddColumn(Rename, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),
    AddRunTs = Table.AddColumn(AddAbsDelta, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime),

    // Optional: If you ONLY want the TopN rows in this feed, uncomment next line
    // TopNOnly = Table.SelectRows(AddRunTs, each [TOPN_OWNER_FLAG] = "Y")

    Final = AddRunTs
in
    Final






// --- Normalize join keys on facility side (the table you are ranking) ---
AddJoinKeys_Fac1 = Table.AddColumn(AddExposureBasis, "ME_DATE_KEY", each Date.From([ME_DATE]), type date),
AddJoinKeys_Fac2 = Table.AddColumn(AddJoinKeys_Fac1, "OWNER_KEY", each Text.Upper(Text.Trim([OWNER_EVENT])), type text),
AddJoinKeys_Fac3 = Table.AddColumn(AddJoinKeys_Fac2, "MOVEMENT_KEY", each Text.Trim([MOVEMENT_TYPE]), type text),

ReviewedSummaryKeys1 = Table.AddColumn(ReviewedSummary, "CURR_EOM_DATE_KEY", each Date.From([CURR_EOM_DATE]), type date),
ReviewedSummaryKeys2 = Table.AddColumn(ReviewedSummaryKeys1, "OWNER_KEY", each Text.Upper(Text.Trim([OWNER_EVENT])), type text),
ReviewedSummaryKeys3 = Table.AddColumn(ReviewedSummaryKeys2, "MOVEMENT_KEY", each Text.Trim([MOVEMENT_TYPE]), type text),


JoinedTopN = Table.NestedJoin(
    AddJoinKeys_Fac3,
    {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
    ReviewedSummaryKeys3,
    {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
    "ReviewedCfg",
    JoinKind.LeftOuter
),

ExpandedTopN = Table.ExpandTableColumn(
    JoinedTopN,
    "ReviewedCfg",
    {"TOPN_USED"},
    {"TOPN_LIMIT"}
),

AddTopNDefault = Table.AddColumn(
    ExpandedTopN,
    "TOPN_LIMIT_FINAL",
    each if [TOPN_LIMIT] <> null then [TOPN_LIMIT] else 30,
    Int64.Type
),

JoinHit = Table.AddColumn(ExpandedTopN, "TOPN_JOIN_HIT", each if [TOPN_LIMIT] <> null then 1 else 0, Int64.Type),





AddJoinKeys_Fac = Table.AddColumn(OwnerFiltered, "ME_DATE_KEY", each Date.From([ME_DATE]), type date),
    AddJoinKeys_Fac2 = Table.AddColumn(AddJoinKeys_Fac, "OWNER_KEY", each Text.Upper(Text.Trim([OWNER_EVENT])), type text),
    AddJoinKeys_Fac3 = Table.AddColumn(AddJoinKeys_Fac2, "MOVEMENT_KEY", each Text.Trim([MOVEMENT_TYPE]), type text),


    ReviewedSummaryKeys1 = Table.AddColumn(ReviewedSummary, "CURR_EOM_DATE_KEY", each Date.From([CURR_EOM_DATE]), type date),
    ReviewedSummaryKeys2 = Table.AddColumn(ReviewedSummaryKeys1, "OWNER_KEY", each Text.Upper(Text.Trim([OWNER_EVENT])), type text),
    ReviewedSummaryKeys3 = Table.AddColumn(ReviewedSummaryKeys2, "MOVEMENT_KEY", each Text.Trim([MOVEMENT_TYPE]), type text),



    JoinedTopN = Table.NestedJoin(
        AddExposureBasis,                          // or AddJoinKeys_Fac3 if that's your current step name
        {"ME_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
        ReviewedSummaryKeys3,
        {"CURR_EOM_DATE_KEY","OWNER_KEY","MOVEMENT_KEY"},
        "ReviewedCfg",
        JoinKind.LeftOuter
    ),

    ExpandedTopN = Table.ExpandTableColumn(
        JoinedTopN,
        "ReviewedCfg",
        {"TOPN_USED"},
        {"TOPN_LIMIT"}
    ),

    AddTopNDefault = Table.AddColumn(
        ExpandedTopN,
        "TOPN_LIMIT_FINAL",
        each if [TOPN_LIMIT] <> null then [TOPN_LIMIT] else 30,
        Int64.Type
    ),


    AddJoinHitFlag = Table.AddColumn(AddTopNDefault, "TOPN_JOIN_HIT", each if [TOPN_LIMIT] <> null then 1 else 0, Int64.Type),










let
    // =========================
    // Sources
    // =========================
    Source = pq_Facility_Rollup_All,

    ReviewedSummaryRaw = Excel.CurrentWorkbook(){[Name="PBI_Feed_Reviewed_Summary_Current"]}[Content],
    ReviewedSummary = Table.TransformColumnTypes(
        ReviewedSummaryRaw,
        {
            {"CURR_EOM_DATE", type date},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"TOPN_USED", Int64.Type},
            {"REVIEWED_BALANCE", type number}
        }
    ),

    // =========================
    // Select + Types
    // =========================
    KeepCols = Table.SelectColumns(
        Source,
        {
            "ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
            "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"
        }
    ),

    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"BANK_EVENT", type text},
            {"FACILITY_EVENT", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // =========================
    // Filter to review movements only
    // =========================
    MovementFiltered = Table.SelectRows(
        Types,
        each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
          or [MOVEMENT_TYPE] = "Exit (ex-Auto)"
    ),

    // =========================
    // Remove non-owner buckets
    // =========================
    OwnerFiltered = Table.SelectRows(
        MovementFiltered,
        each not (
            [OWNER_EVENT] = "NOT COVERED"
            or Text.StartsWith([OWNER_EVENT], "Not Covered; Under")
        )
    ),

    // =========================
    // Exposure basis
    // =========================
    AddExposureBasis = Table.AddColumn(
        OwnerFiltered,
        "EXPOSURE_BASIS",
        each
            if [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)" then [CURR_SSB_SUM]
            else if [MOVEMENT_TYPE] = "Exit (ex-Auto)" then [PREV_SSB_SUM]
            else null,
        type number
    ),

    // =========================
    // Join to Reviewed Summary to get TOPN_USED
    // =========================
    JoinedTopN = Table.NestedJoin(
        AddExposureBasis,
        {"ME_DATE","OWNER_EVENT","MOVEMENT_TYPE"},
        ReviewedSummary,
        {"CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE"},
        "ReviewedCfg",
        JoinKind.LeftOuter
    ),

    ExpandedTopN = Table.ExpandTableColumn(
        JoinedTopN,
        "ReviewedCfg",
        {"TOPN_USED"},
        {"TOPN_LIMIT"}
    ),

    // =========================
    // Default TOPN to 30 if missing
    // =========================
    AddTopNDefault = Table.AddColumn(
        ExpandedTopN,
        "TOPN_LIMIT_FINAL",
        each if [TOPN_LIMIT] <> null then [TOPN_LIMIT] else 30,
        Int64.Type
    ),

    RemoveTemp = Table.RemoveColumns(AddTopNDefault, {"TOPN_LIMIT"}),

    // =========================
    // De-dupe per owner / movement / facility
    // =========================
    Dedup = Table.Distinct(
        RemoveTemp,
        {"ME_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT"}
    ),

    // =========================
    // Sort for ranking
    // =========================
    SortForRank = Table.Sort(
        Dedup,
        {
            {"ME_DATE", Order.Ascending},
            {"OWNER_EVENT", Order.Ascending},
            {"MOVEMENT_TYPE", Order.Ascending},
            {"EXPOSURE_BASIS", Order.Descending}
        }
    ),

    // =========================
    // Rank within (Month, Owner, Movement)
    // =========================
    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE","OWNER_EVENT","MOVEMENT_TYPE"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "OWNER_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(
                            t2,
                            "TOPN_OWNER_FLAG",
                            each if [OWNER_RANK] <= [TOPN_LIMIT_FINAL] then "Y" else "N",
                            type text
                        )
                    in
                        t3,
                 type table}
            }
        ),

    ExpandedFinal = Table.ExpandTableColumn(
        Grouped,
        "Data",
        {
            "BANK_EVENT","FACILITY_EVENT","REVIEWABLE_FLAG_MAX",
            "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM",
            "EXPOSURE_BASIS","TOPN_LIMIT_FINAL","OWNER_RANK","TOPN_OWNER_FLAG"
        },
        {
            "BANK_EVENT","FACILITY_EVENT","REVIEWABLE_FLAG_MAX",
            "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM",
            "EXPOSURE_BASIS","TOPN_LIMIT","OWNER_RANK","TOPN_OWNER_FLAG"
        }
    ),

    Rename = Table.RenameColumns(ExpandedFinal, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddAbsDelta = Table.AddColumn(Rename, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),
    AddRunTs = Table.AddColumn(AddAbsDelta, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





Total Downgrade IN (All Coverage) =
CALCULATE(
    SUM ( PBI_Feed_FacilityReview_Current[MOM_DELTA_SUM] ),
    PBI_Feed_FacilityReview_Current[MOVEMENT_GROUP] = "Downgrade IN",
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[REVIEWABLE_FLAG_MAX] ),
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[TOPN_OWNER_FLAG] ),
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[OWNER_EVENT] )
)


Total Exit (All Coverage) =
CALCULATE(
    SUM ( PBI_Feed_FacilityReview_Current[MOM_DELTA_SUM] ),
    PBI_Feed_FacilityReview_Current[MOVEMENT_GROUP] = "Exit",
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[REVIEWABLE_FLAG_MAX] ),
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[TOPN_OWNER_FLAG] ),
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[OWNER_EVENT] )
)




ReviewDistinct = Table.Distinct(
        ReviewOwnerFiltered,
        {"CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT"}
    ),



// --- Remove non-owner buckets that can appear in OWNER_EVENT ---
    ReviewOwnerFiltered = Table.SelectRows(
        ReviewFiltered,
        each not (
            [OWNER_EVENT] = "NOT COVERED"
            or Text.StartsWith([OWNER_EVENT], "Not Covered; Under")
        )
    ),




Reviewable Balance - Downgrade =
CALCULATE(
    [Reviewable Balance (Total)],
    PBI_Feed_Reviewable_Summary_Current[MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
)

Reviewable Balance - Exit =
CALCULATE(
    [Reviewable Balance (Total)],
    PBI_Feed_Reviewable_Summary_Current[MOVEMENT_TYPE] = "Exit (ex-Auto)"
)


Reviewed Balance (Total) =
SUM ( PBI_Feed_Reviewed_Summary_Current[REVIEWED_BALANCE] )


Reviewed Coverage % =
DIVIDE( [Reviewed Balance (Total)], [Reviewable Balance (Total)] )





let
    // --- Source queries (must already exist in PQ) ---
    Review = PBI_Feed_FacilityReview_Current,
    Bal    = PBI_Feed_FacilityBalance_Current,

    // --- Keep only what we need from Review table ---
    ReviewKeep = Table.SelectColumns(
        Review,
        {"CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT"}
    ),

    ReviewTypes = Table.TransformColumnTypes(
        ReviewKeep,
        {
            {"CURR_EOM_DATE", type date},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"FACILITY_EVENT", type text}
        }
    ),

    // --- Filter to the two movement types that define "reviewable" ---
    ReviewFiltered = Table.SelectRows(
        ReviewTypes,
        each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
          or [MOVEMENT_TYPE] = "Exit (ex-Auto)"
    ),

    // --- De-dupe so each facility is counted once per (month, owner, movement) ---
    ReviewDistinct = Table.Distinct(
        ReviewFiltered,
        {"CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE","FACILITY_EVENT"}
    ),

    // --- Keep only what we need from Balance table ---
    BalKeep = Table.SelectColumns(
        Bal,
        {"CURR_EOM_DATE","FACILITY_EVENT","CURR_SSB_FAC","PREV_SSB_FAC","REVIEWABLE_FLAG_MAX"}
    ),

    BalTypes = Table.TransformColumnTypes(
        BalKeep,
        {
            {"CURR_EOM_DATE", type date},
            {"FACILITY_EVENT", type text},
            {"CURR_SSB_FAC", type number},
            {"PREV_SSB_FAC", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // --- Filter to reviewable_flag = 1 (your definition) ---
    BalReviewableOnly = Table.SelectRows(BalTypes, each [REVIEWABLE_FLAG_MAX] = 1),

    // --- Join Review -> Balance on (month, facility) ---
    Joined = Table.NestedJoin(
        ReviewDistinct,
        {"CURR_EOM_DATE","FACILITY_EVENT"},
        BalReviewableOnly,
        {"CURR_EOM_DATE","FACILITY_EVENT"},
        "Bal",
        JoinKind.Inner
    ),

    Expanded = Table.ExpandTableColumn(
        Joined,
        "Bal",
        {"CURR_SSB_FAC","PREV_SSB_FAC"},
        {"CURR_SSB_FAC","PREV_SSB_FAC"}
    ),

    // --- Exposure basis logic: Downgrade uses Curr, Exit uses Prev ---
    AddExposure = Table.AddColumn(
        Expanded,
        "REVIEWABLE_BALANCE",
        each
            if [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)" then [CURR_SSB_FAC]
            else if [MOVEMENT_TYPE] = "Exit (ex-Auto)" then [PREV_SSB_FAC]
            else null,
        type number
    ),

    // --- Aggregate to summary grain (month, owner, movement) ---
    Summary = Table.Group(
        AddExposure,
        {"CURR_EOM_DATE","OWNER_EVENT","MOVEMENT_TYPE"},
        {{"REVIEWABLE_BALANCE", each List.Sum([REVIEWABLE_BALANCE]), type number}}
    ),

    // --- Add refresh timestamp ---
    AddRunTs = Table.AddColumn(Summary, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs




Reviewed Balance - Downgrade (Top30, Curr Exposure) =
VAR DowngradeFacilities =
    CALCULATETABLE(
        VALUES ( PBI_Feed_FacilityReview_Current[FACILITY_EVENT] ),
        REMOVEFILTERS ( PBI_Feed_FacilityReview_Current ),
        PBI_Feed_FacilityReview_Current[MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
    )
VAR WithExposure =
    ADDCOLUMNS(
        DowngradeFacilities,
        "Exposure",
            CALCULATE(
                SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
                PBI_Feed_FacilityBalance_Current[REVIEWABLE_FLAG_MAX] = 1,
                TREATAS( DowngradeFacilities, PBI_Feed_FacilityBalance_Current[FACILITY_EVENT] )
            )
    )
VAR TopN =
    TOPN( 30, WithExposure, [Exposure], DESC )
RETURN
    SUMX( TopN, [Exposure] )







Reviewable Balance - Downgrade (Curr Exposure) =
VAR FacSet =
    CALCULATETABLE(
        VALUES ( PBI_Feed_FacilityReview_Current[FACILITY_EVENT] ),
        REMOVEFILTERS ( PBI_Feed_FacilityReview_Current ),
        PBI_Feed_FacilityReview_Current[MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)"
    )
RETURN
    CALCULATE(
        SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
        PBI_Feed_FacilityBalance_Current[REVIEWABLE_FLAG_MAX] = 1,
        TREATAS( FacSet, PBI_Feed_FacilityBalance_Current[FACILITY_EVENT] )
    )


Reviewable Balance - Exit (Prev Exposure) =
VAR FacSet =
    CALCULATETABLE(
        VALUES ( PBI_Feed_FacilityReview_Current[FACILITY_EVENT] ),
        REMOVEFILTERS ( PBI_Feed_FacilityReview_Current ),
        PBI_Feed_FacilityReview_Current[MOVEMENT_TYPE] = "Exit (ex-Auto)"
    )
RETURN
    CALCULATE(
        SUM ( PBI_Feed_FacilityBalance_Current[PREV_SSB_FAC] ),
        PBI_Feed_FacilityBalance_Current[REVIEWABLE_FLAG_MAX] = 1,
        TREATAS( FacSet, PBI_Feed_FacilityBalance_Current[FACILITY_EVENT] )
    )


Reviewable Balance (Total) =
[Reviewable Balance - Downgrade (Curr Exposure)] +
[Reviewable Balance - Exit (Prev Exposure)]







Downgrade IN (% Label) =
VAR p = [Downgrade IN (% of Prior NA)]
RETURN IF( ISBLANK(p), BLANK(), FORMAT(p, "0.0%") & " of prior NA" )

Exit (% of Prior NA) =
DIVIDE( [Exit (Î”)], [NA Balance (Prev)] )

Exit (% Label) =
VAR p = [Exit (% of Prior NA)]
RETURN IF( ISBLANK(p), BLANK(), FORMAT(p, "0.0%") & " of prior NA" )


Exit Magnitude (% of Prior NA) =
DIVIDE( ABS([Exit (Î”)]), [NA Balance (Prev)] )

Reviewable Balance (Curr) =
CALCULATE(
    SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
    PBI_Feed_FacilityBalance_Current[REVIEWABLE_FLAG_MAX] = 1,
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current )
)


Top30 Reviewed (Balance) =
VAR TopFacilities =
    CALCULATETABLE(
        VALUES ( PBI_Feed_FacilityReview_Current[FACILITY_EVENT] ),
        PBI_Feed_FacilityReview_Current[TOP30_FLAG] = "Y",
        REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[MOVEMENT_TYPE] )
    )
RETURN
    CALCULATE(
        SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
        TREATAS( TopFacilities, PBI_Feed_FacilityBalance_Current[FACILITY_EVENT] )
    )

Reviewable (% of Total NA) =
DIVIDE( [Reviewable Balance (Curr)], [NA Balance (Curr)] )

Top30 (% of Reviewable) =
DIVIDE( [Top30 Reviewed (Balance)], [Reviewable Balance (Curr)] )

Top30 (% Label) =
VAR p = [Top30 (% of Reviewable)]
RETURN IF( ISBLANK(p), BLANK(), FORMAT(p, "0%") & " of reviewable" )






https://www.swisstransfer.com/d/9ba8fd62-9d29-44f0-87d1-571ea0cb5b7a





IceStat is built to evolve â€” with coaches, players, and the game.

Weâ€™re starting with a coach-led approach:
track the on-ice actions you already care about â†’ turn them into clear, coaching-ready insights.

V1: Coaches or assistants log key game actions.
IceStat synthesizes that data into dashboards for:
â€¢ Bench decisions
â€¢ Player development
â€¢ Objective conversations

V2: The same core stats â€” captured faster and more consistently.

V3: AI-assisted video review to help classify actions, surface patterns, and scale insight.

Thereâ€™s also a version for players â€” simple snapshots that show impact, habits, and focus areas between practices.

Same philosophy at every stage:
analytics should simplify decisions â€” not complicate them.

IceStat is coming soon. ðŸ§ŠðŸ“Š



Purpose
Identify and quantify Negative Non-Accrual balances that impact period-end exposure and reconciliation views.

Primary Inputs

Netezza SQL extract (tbl_Neg_NA)

Month-end Non-Accrual account attributes

Facility identifiers

Key Logic Applied

SQL identifies accounts with negative Non-Accrual balances as of month-end

Data is aligned to the same Facility keys used across the workbook

No Movement_Type or Owner classification is derived on this tab

Business Rules / Assumptions

Negative balances are reported for transparency and reconciliation

Neg_NA balances do not independently drive Top 30 facility selection

Classification fields (if present) are inherited from SQL logic upstream

Outputs / How to Use
Used as supporting context for Executive Summary totals and reconciliation review.




Purpose
Surface current-period charge-off activity that affects Non-Accrual balances and movement interpretation.

Primary Inputs

Netezza SQL extract (tbl_Chargeoff)

Month-to-date charge-off amounts

Facility and account identifiers

Key Logic Applied

SQL calculates charge-off amounts for the current reporting period

Charge-off data is associated to Facility identifiers for aggregation

No Movement_Type or Owner classification is recalculated on this tab

Business Rules / Assumptions

Charge-offs are presented as explanatory context, not as drivers of Top 30 ranking

Timing differences may exist between Non-Accrual exits and charge-off recognition

Outputs / How to Use
Used to explain reductions in Non-Accrual exposure and support executive commentary.






Reviewable NA (Curr) =
CALCULATE(
    SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
    PBI_Feed_FacilityBalance_Current[REVIEWABLE_FLAG_MAX] = 1,
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[MOVEMENT_TYPE] )
)

Reviewable NA (Curr) =
CALCULATE(
    SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
    PBI_Feed_FacilityBalance_Current[REVIEWABLE_FLAG_MAX] = 1,
    REMOVEFILTERS ( PBI_Feed_FacilityReview_Current )
)

Top30 Balance Reviewed (Curr) =
VAR TopFacilities =
    CALCULATETABLE(
        VALUES ( PBI_Feed_FacilityReview_Current[FACILITY_EVENT] ),
        PBI_Feed_FacilityReview_Current[TOP30_FLAG] = "Y",
        REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[MOVEMENT_TYPE] )
    )
RETURN
    CALCULATE(
        SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
        TREATAS( TopFacilities, PBI_Feed_FacilityBalance_Current[FACILITY_EVENT] )
    )

Top30 Balance Reviewed (Curr) =
VAR TopFacilities =
    CALCULATETABLE(
        VALUES ( PBI_Feed_FacilityReview_Current[FACILITY_EVENT] ),
        PBI_Feed_FacilityReview_Current[TOP30_FLAG] = "Y",
        REMOVEFILTERS ( PBI_Feed_FacilityReview_Current )
    )
RETURN
    CALCULATE(
        SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
        TREATAS( TopFacilities, PBI_Feed_FacilityBalance_Current[FACILITY_EVENT] )
    )

Top30 Movement Reviewed (Abs) =
VAR TopFacilities =
    CALCULATETABLE(
        VALUES ( PBI_Feed_FacilityReview_Current[FACILITY_EVENT] ),
        PBI_Feed_FacilityReview_Current[TOP30_FLAG] = "Y",
        REMOVEFILTERS ( PBI_Feed_FacilityReview_Current[MOVEMENT_TYPE] )
    )
RETURN
    CALCULATE(
        SUM ( PBI_Feed_FacilityBalance_Current[BAL_CHANGE_ABS] ),
        TREATAS( TopFacilities, PBI_Feed_FacilityBalance_Current[FACILITY_EVENT] )
    )




=IF(OR([@Owner_Consistency_Flag]="MISMATCH",[@Movement_Consistency_Flag]="MISMATCH"),"EXCEPTION","OK")





=LET(
  f, [@FACILITY_ID],
  u, UNIQUE(FILTER(MoM_Account_Detail[OWNER_FOR_EVENT], MoM_Account_Detail[FACILITY_ID]=f)),
  IF(ROWS(u)=1,"OK","MISMATCH")
)

=LET(
  f, [@FACILITY_ID],
  u, UNIQUE(FILTER(MoM_Account_Detail[MOVEMENT_TYPE], MoM_Account_Detail[FACILITY_ID]=f)),
  IF(ROWS(u)=1,"OK","MISMATCH")
)

=LET(
  f, [@FACILITY_ID],
  ROWS(UNIQUE(FILTER(MoM_Account_Detail[OWNER_FOR_EVENT], MoM_Account_Detail[FACILITY_ID]=f)))
)

=LET(
  f, [@FACILITY_ID],
  ROWS(UNIQUE(FILTER(MoM_Account_Detail[MOVEMENT_TYPE], MoM_Account_Detail[FACILITY_ID]=f)))
)

=LET(
  f, [@FACILITY_ID],
  TEXTJOIN(" | ", TRUE, UNIQUE(FILTER(MoM_Account_Detail[MOVEMENT_TYPE], MoM_Account_Detail[FACILITY_ID]=f)))
)






Purpose
Account-level detail and drill-through view for MoM Non-Accrual changes, aligned to Facility-level classification.

Primary Inputs
	â€¢	Netezza SQL extract (account-level rows)
	â€¢	SQL-derived Facility-level classification fields (Movement_Type, Owner)

Key Logic Applied
	â€¢	SQL aligns current vs prior month and computes MoM deltas at the account level
	â€¢	SQL assigns Movement_Type and Owner at the Facility level, then stamps those values onto each account row within that facility (for consistent detail views)

Business Rules / Assumptions
	â€¢	Movement_Type/Owner are authoritative from SQL (facility-level)
	â€¢	Account-level attributes may vary within a facility, but classification does not

Outputs / How to Use
Use for Top 30 facility drill-down and reviewer evidence.

â¸»

âœ… Corrected Callout â€” Facility_Rollup

LOGIC & METHODOLOGY â€” FACILITY_ROLLUP

Purpose
Facility-level aggregation layer used for Top 30 ranking and executive summaries.

Primary Inputs
	â€¢	MoM_Account_Detail (account-level rows with facility keys)
	â€¢	SQL-derived Facility-level MOVEMENT_TYPE and OWNER_FOR_EVENT

Key Logic Applied
	â€¢	Aggregates account-level balances/movements to Facility totals
	â€¢	Does not re-calculate Movement_Type or Owner
	â€¢	Uses SQL-derived Facility-level Movement_Type/Owner as the facilityâ€™s classification fields (should be consistent across all accounts within facility)

Business Rules / Assumptions
	â€¢	If accounts within a facility ever disagree on Movement_Type/Owner, that is treated as a data quality exception to investigate (should be rare if SQL is correct)

Outputs / How to Use
Feeds Top30_Engine and the Executive Summary as the authoritative facility-level review dataset.






ðŸ“˜ Facility_Rollup

LOGIC & METHODOLOGY â€” FACILITY_ROLLUP

Purpose
Aggregate account-level Non-Accrual activity to the Facility level for consistent classification and review.

Primary Inputs
	â€¢	MoM_Account_Detail
	â€¢	Facility identifiers and attributes

Key Logic Applied
	â€¢	Rollup of account-level balances and movements to Facility
	â€¢	Assignment of Movement_Type at the Facility level
	â€¢	Assignment of Owner at the Facility level based on dominant exposure and movement

Business Rules / Assumptions
	â€¢	Facility is the authoritative unit for Movement_Type and Owner
	â€¢	Individual account behavior is subordinated to Facility-level classification
	â€¢	Conflicting account flags are resolved through aggregation logic

Outputs / How to Use
Primary driver for Top 30 rankings and executive review.

â¸»

ðŸ“˜ Top30_Engine

LOGIC & METHODOLOGY â€” TOP30_ENGINE

Purpose
Identify and rank the most material facilities requiring review by Owner and Movement_Type.

Primary Inputs
	â€¢	Facility_Rollup
	â€¢	Current and prior Non-Accrual balances

Key Logic Applied
	â€¢	Filtering to reviewable Movement_Types (e.g., Exit ex-Auto, Downgrade IN ex-Auto)
	â€¢	Ranking facilities by materiality
	â€¢	Spill-based Top 30 selection logic

Business Rules / Assumptions
	â€¢	Rankings are performed at the Facility level
	â€¢	Ties and edge cases follow deterministic ranking logic
	â€¢	Only non-Auto driven movements are included

Outputs / How to Use
Feeds all Top 30 summary and detail tabs.

â¸»

ðŸ“˜ Top30_[Owner]_[Movement] (Detail Tabs)

LOGIC & METHODOLOGY â€” TOP30 FACILITY DETAIL

Purpose
Provide account-level transparency for Top 30 facilities flagged for review.

Primary Inputs
	â€¢	Top30_Engine
	â€¢	MoM_Account_Detail

Key Logic Applied
	â€¢	Dynamic filtering to selected Top 30 facilities
	â€¢	Return of only accounts associated with those facilities
	â€¢	Presentation of current and prior attributes for review

Business Rules / Assumptions
	â€¢	Accounts inherit Facility-level Movement_Type and Owner
	â€¢	Presence does not imply independent materiality

Outputs / How to Use
Used by reviewers to understand why a facility appears in the Top 30 list.







Purpose
Serve as the granular account-level foundation for all month-over-month Non-Accrual analysis.

Primary Inputs

Netezza SQL extract (current and prior month)

Account, facility, customer, and product attributes

Key Logic Applied

Alignment of current vs. prior month records

Calculation of MoM Non-Accrual changes

Retention of full account-level detail for drill-through

Business Rules / Assumptions

Account-level Non-Accrual flags may differ within a facility

No Movement_Type classification occurs at this level

Outputs / How to Use
Used for downstream facility aggregation and Top 30 account-level detail views.




Top30 Balance Reviewed (Curr) =
VAR TopFacilities =
    CALCULATETABLE(
        VALUES ( PBI_Feed_FacilityReview_Current[FACILITY_EVENT] ),
        PBI_Feed_FacilityReview_Current[TOP30_FLAG] = "Y"
    )
RETURN
    CALCULATE(
        SUM ( PBI_Feed_FacilityBalance_Current[CURR_SSB_FAC] ),
        TREATAS( TopFacilities, PBI_Feed_FacilityBalance_Current[FACILITY_EVENT] )
    )



Chargeoffs MTD =
SUM ( PBI_Feed_Chargeoff_Current[CHARGEOFF_MTD_AMT] )

Neg_NA SSB =
SUM ( PBI_Feed_NegNA_Current[CIS_NEG_NA_SSB] )


Neg_NA SSB (Filtered) =
CALCULATE(
    SUM ( PBI_Feed_NegNA_Current[SSB] ),
    PBI_Feed_NegNA_Current[IS_NEGATIVE_SSB] = 1
)

Waterfall Value =
SWITCH(
    SELECTEDVALUE( WaterfallSteps[Step] ),
    "Previous Portfolio", [Portfolio Prev NA],
    "Exit (ex-Auto)", [Exit (ex-Auto)],
    "Downgrade IN (ex-Auto)", [Downgrade IN (ex-Auto)],
    "Other Reviewable", [Other Reviewable],
    "Non-Reviewable Net", [Non-Reviewable Net Î”],
    "Current Portfolio", [Portfolio Curr NA]
)







let
    Source = pq_Facility_Rollup_All,

    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"}
    ),

    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"BANK_EVENT", type text},
            {"FACILITY_EVENT", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // Keep reviewable only for review tables / top30 ranking
    ReviewableOnly = Table.SelectRows(Types, each [REVIEWABLE_FLAG_MAX] = 1),

    AddAbs = Table.AddColumn(ReviewableOnly, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),

    // Sort for ranking within month-end
    SortForRank = Table.Sort(AddAbs, {{"ME_DATE", Order.Ascending}, {"BAL_CHANGE_ABS", Order.Descending}}),

    // Rank by month-end
    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "MONTH_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(t2, "TOP30_FLAG", each if [MONTH_RANK] <= 30 then "Y" else "N", type text)
                    in
                        t3
                , type table}
            }
        ),

    Expanded = Table.ExpandTableColumn(
        Grouped,
        "Data",
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"},
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"}
    ),

    Rename = Table.RenameColumns(Expanded, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddRunTs = Table.AddColumn(Rename, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = pq_Facility_Rollup_All,

    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE","FACILITY_EVENT","PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"}
    ),

    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"FACILITY_EVENT", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // Dedupe: 1 row per facility per month-end
    // Use MAX to avoid double-counting if the facility appears multiple times
    FacilityDedup =
        Table.Group(
            Types,
            {"ME_DATE","FACILITY_EVENT"},
            {
                {"PREV_SSB_FAC", each List.Max([PREV_SSB_SUM]), type number},
                {"CURR_SSB_FAC", each List.Max([CURR_SSB_SUM]), type number},
                {"MOM_DELTA_FAC", each List.Max([MOM_DELTA_SUM]), type number},
                {"REVIEWABLE_FLAG_MAX", each List.Max([REVIEWABLE_FLAG_MAX]), Int64.Type}
            }
        ),

    Rename = Table.RenameColumns(FacilityDedup, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddAbs = Table.AddColumn(Rename, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_FAC]), type number),
    AddRunTs = Table.AddColumn(AddAbs, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = Excel.CurrentWorkbook(){[Name="tbl_Neg_NA"]}[Content],

    Types = Table.TransformColumnTypes(
        Source,
        {
            {"END_OF_MONTH_DATE", type date},
            {"CIS_CUSTOMER_NUMBER", type text},
            {"ACCOUNT_KEY", type text},
            {"ACCOUNT_IDENTIFIER", type text},
            {"FACILITY_ID", type text},
            {"ACCOUNT_NAME", type text},
            {"CONTRACT_SOURCE_SYSTEM", type text},
            {"PROD_HIER_LEVEL_5", type text},
            {"RBC_CODE", type text},
            {"STATUS_CODE_DESCRIPTION", type text},
            {"GL_ACCOUNT_HIER_LEVEL_4", type text},
            {"GL_ACCOUNT_CODE", type text},
            {"NON_ACCRUAL_FLAG", type text},
            {"SSB", type number},
            {"CO_MTD", type number},
            {"IS_NA", Int64.Type},
            {"IS_NEGATIVE_SSB", Int64.Type},
            {"CIS_NEG_NA_SSB", type number}
        }
    ),

    Renamed = Table.RenameColumns(Types, {{"END_OF_MONTH_DATE", "CURR_EOM_DATE"}}),

    KeepCols = Table.SelectColumns(
        Renamed,
        {
            "CURR_EOM_DATE",
            "CIS_CUSTOMER_NUMBER",
            "FACILITY_ID",
            "ACCOUNT_KEY",
            "ACCOUNT_IDENTIFIER",
            "ACCOUNT_NAME",
            "CONTRACT_SOURCE_SYSTEM",
            "PROD_HIER_LEVEL_5",
            "RBC_CODE",
            "STATUS_CODE_DESCRIPTION",
            "GL_ACCOUNT_HIER_LEVEL_4",
            "GL_ACCOUNT_CODE",
            "NON_ACCRUAL_FLAG",
            "SSB",
            "CO_MTD",
            "IS_NA",
            "IS_NEGATIVE_SSB",
            "CIS_NEG_NA_SSB"
        }
    ),

    AddRunTs = Table.AddColumn(KeepCols, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs






let
    Source = Excel.CurrentWorkbook(){[Name="tbl_Chargeoff"]}[Content],

    // Types (force IDs to text)
    Types = Table.TransformColumnTypes(
        Source,
        {
            {"QUERY_RUN_TIMESTAMP", type datetime},
            {"END_OF_MONTH_DATE", type date},
            {"CIS_CUSTOMER_NUMBER", type text},
            {"ACCOUNT_NAME", type text},
            {"CONTRACT_SOURCE_SYSTEM", type text},
            {"FACILITY_ID", type text},
            {"ACCOUNT_IDENTIFIER", type text},
            {"ACCOUNT_KEY", type text},
            {"CHARGE_OFF_AMOUNT_MTD", type number},
            {"BANK_CODE", type text}
        }
    ),

    // Rename to stable PBI feed contract
    Renamed = Table.RenameColumns(
        Types,
        {
            {"END_OF_MONTH_DATE", "CURR_EOM_DATE"},
            {"CHARGE_OFF_AMOUNT_MTD", "CHARGEOFF_MTD_AMT"}
        }
    ),

    // Keep only what we need
    KeepCols = Table.SelectColumns(
        Renamed,
        {
            "CURR_EOM_DATE",
            "QUERY_RUN_TIMESTAMP",
            "BANK_CODE",
            "CONTRACT_SOURCE_SYSTEM",
            "FACILITY_ID",
            "ACCOUNT_KEY",
            "ACCOUNT_IDENTIFIER",
            "ACCOUNT_NAME",
            "CIS_CUSTOMER_NUMBER",
            "CHARGEOFF_MTD_AMT"
        }
    ),

    // Add refresh timestamp (optional; you already have QUERY_RUN_TIMESTAMP)
    AddRunTs = Table.AddColumn(KeepCols, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





QUERY_RUN_TIMESTAMP
END_OF_MONTH_DATE
CIS_CUSTOMER_NUMBER
ACCOUNT_NAME
CONTRACT_SOURCE_SYSTEM
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
CHARGE_OFF_AMOUNT_MTD
BANK_CODE

END_OF_MONTH_DATE
CIS_CUSTOMER_NUMBER
ACCOUNT_KEY
ACCOUNT_IDENTIFIER
FACILITY_ID
ACCOUNT_NAME
CONTRACT_SOURCE_SYSTEM
PROD_HIER_LEVEL_5
RBC_CODE
STATUS_CODE_DESCRIPTION
GL_ACCOUNT_HIER_LEVEL_4
GL_ACCOUNT_CODE
NON_ACCRUAL_FLAG
SSB
CO_MTD
IS_NA
IS_NEGATIVE_SSB
CIS_CLUSTER_SSB
CIS_CLUSTER_CO_MTD
CIS_NEG_NA_SSB






let
    Source = pq_Facility_Rollup_All,

    Types = Table.TransformColumnTypes(
        Source,
        {
            {"ME_DATE", type date},
            {"MOVEMENT_TYPE", type text},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    Reviewable = Table.SelectRows(Types, each [REVIEWABLE_FLAG_MAX] = 1),

    Grouped = Table.Group(
        Reviewable,
        {"ME_DATE"},
        {
            {"REVIEWABLE_TOTAL_DELTA", each List.Sum([MOM_DELTA_SUM]), type number},
            {"EXIT_EX_AUTO_DELTA", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Exit (ex-Auto)")[MOM_DELTA_SUM]), type number},
            {"DOWNGRADE_IN_EX_AUTO_DELTA", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)")[MOM_DELTA_SUM]), type number}
        }
    ),

    AddOther = Table.AddColumn(
        Grouped,
        "OTHER_REVIEWABLE_DELTA",
        each [REVIEWABLE_TOTAL_DELTA] - ([EXIT_EX_AUTO_DELTA] + [DOWNGRADE_IN_EX_AUTO_DELTA]),
        type number
    ),

    Rename = Table.RenameColumns(Grouped, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddRunTs = Table.AddColumn(AddOther, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content],

    // --- EDIT THESE 4 NAMES TO MATCH YOUR TABLE ---
    Types = Table.TransformColumnTypes(
        Source,
        {
            {"CURR_EOM", type date},
            {"PREV_EOM", type date},
            {"CURR_SSB", type number},
            {"PREV_SSB", type number}
        }
    ),

    // Deduplicate at account_key if needed (prevents double counting)
    // If each row is already unique per ACCOUNT_KEY, this still works.
    Dedup = Table.Group(
        Types,
        {"CURR_EOM","PREV_EOM","ACCOUNT_KEY"},
        {
            {"CURR_SSB_ACCT", each List.Max([CURR_SSB]), type number},
            {"PREV_SSB_ACCT", each List.Max([PREV_SSB]), type number}
        }
    ),

    OneRow = Table.Group(
        Dedup,
        {"CURR_EOM","PREV_EOM"},
        {
            {"PORTFOLIO_CURR_NA_BAL", each List.Sum([CURR_SSB_ACCT]), type number},
            {"PORTFOLIO_PREV_NA_BAL", each List.Sum([PREV_SSB_ACCT]), type number}
        }
    ),

    AddDelta = Table.AddColumn(OneRow, "PORTFOLIO_MOM_DELTA", each [PORTFOLIO_CURR_NA_BAL] - [PORTFOLIO_PREV_NA_BAL], type number),

    Rename = Table.RenameColumns(AddDelta, {{"CURR_EOM","CURR_EOM_DATE"},{"PREV_EOM","PREV_EOM_DATE"}}),

    AddRunTs = Table.AddColumn(Rename, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = PBI_Feed_FacilityReview_Current,

    // One row per CURR_EOM_DATE (you currently only have 1 date anyway, but this is robust)
    Grouped = Table.Group(
        Source,
        {"CURR_EOM_DATE"},
        {
            {"TOTAL_CURR_SSB_SUM", each List.Sum([CURR_SSB_SUM]), type number},
            {"TOTAL_PREV_SSB_SUM", each List.Sum([PREV_SSB_SUM]), type number},
            {"TOTAL_MOM_DELTA_SUM", each List.Sum([MOM_DELTA_SUM]), type number},
            {"REVIEWABLE_FACILITY_COUNT", each Table.RowCount(_), Int64.Type},

            // Movement buckets (edit these strings ONLY if your MOVEMENT_TYPE labels differ)
            {"EXIT_EX_AUTO_DELTA", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Exit (ex-Auto)")[MOM_DELTA_SUM]), type number},
            {"DOWNGRADE_IN_EX_AUTO_DELTA", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)")[MOM_DELTA_SUM]), type number}
        }
    ),

    AddOther = Table.AddColumn(
        Grouped,
        "OTHER_NET_DELTA",
        each [TOTAL_MOM_DELTA_SUM] - ([EXIT_EX_AUTO_DELTA] + [DOWNGRADE_IN_EX_AUTO_DELTA]),
        type number
    ),

    // Add PREV_EOM_DATE if you want it shown in the executive subtitle:
    // Since it is not in your rollup, we set it as null for now.
    // If you have a reliable place to pull PREV_EOM_DATE (e.g., a parameter table), we can wire it in.
    AddPrevDate = Table.AddColumn(AddOther, "PREV_EOM_DATE", each null, type date),

    AddRunTs = Table.AddColumn(AddPrevDate, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = pq_Facility_Rollup_All,

    // Keep only known columns (stable feed contract)
    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"}
    ),

    // Type enforcement (FACILITY_EVENT as text is important)
    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"BANK_EVENT", type text},
            {"FACILITY_EVENT", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // Keep reviewable only (recommended for exec feed)
    ReviewableOnly = Table.SelectRows(Types, each [REVIEWABLE_FLAG_MAX] = 1),

    // Add abs change for ranking / sorting
    AddAbs = Table.AddColumn(ReviewableOnly, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),

    // Rank Top30 within the month-end by BAL_CHANGE_ABS
    SortForRank = Table.Sort(AddAbs, {{"ME_DATE", Order.Ascending}, {"BAL_CHANGE_ABS", Order.Descending}}),

    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "MONTH_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(t2, "TOP30_FLAG", each if [MONTH_RANK] <= 30 then "Y" else "N", type text)
                    in
                        t3
                , type table}
            }
        ),

    Expanded = Table.ExpandTableColumn(
        Grouped,
        "Data",
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"},
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"}
    ),

    // Rename ME_DATE -> CURR_EOM_DATE to make "snapshot" explicit
    RenameCols = Table.RenameColumns(Expanded, {{"ME_DATE", "CURR_EOM_DATE"}}),

    // Refresh timestamp
    AddRunTs = Table.AddColumn(RenameCols, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs






let
    Source = PBI_Feed_FacilityReview,

    Grouped = Table.Group(
        Source,
        {"ME_DATE"},
        {
            {"TOTAL_NON_ACCRUAL_BAL", each List.Sum([CURR_SSB_SUM]), type number},
            {"TOTAL_NON_ACCRUAL_BAL_PRIOR", each List.Sum([PREV_SSB_SUM]), type number},
            {"MOM_CHANGE_BAL", each List.Sum([MOM_DELTA_SUM]), type number},
            {"REVIEWABLE_FACILITY_COUNT", each Table.RowCount(_), Int64.Type},

            // Movement buckets (edit strings if your MOVEMENT_TYPE labels differ)
            {"EXIT_EX_AUTO_BAL", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Exit (ex-Auto)")[MOM_DELTA_SUM]), type number},
            {"DOWNGRADE_IN_EX_AUTO_BAL", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)")[MOM_DELTA_SUM]), type number}
        }
    ),

    AddOther = Table.AddColumn(
        Grouped,
        "OTHER_NET_MOVEMENT_BAL",
        each [MOM_CHANGE_BAL] - ([EXIT_EX_AUTO_BAL] + [DOWNGRADE_IN_EX_AUTO_BAL]),
        type number
    ),

    AddRunTs = Table.AddColumn(AddOther, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = pq_Facility_Rollup_All,

    // Keep only available columns
    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"}
    ),

    // Types (treat FACILITY_EVENT as text to preserve formatting)
    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"BANK_EVENT", type text},
            {"FACILITY_EVENT", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // Filter to reviewable rows (recommended for the exec dataset)
    ReviewableOnly = Table.SelectRows(Types, each [REVIEWABLE_FLAG_MAX] = 1),

    // Add absolute change for ranking
    AddAbs = Table.AddColumn(ReviewableOnly, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),

    // Rank TOP30 per month-end by BAL_CHANGE_ABS
    SortForRank = Table.Sort(AddAbs, {{"ME_DATE", Order.Ascending}, {"BAL_CHANGE_ABS", Order.Descending}}),

    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "MONTH_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(t2, "TOP30_FLAG", each if [MONTH_RANK] <= 30 then "Y" else "N", type text)
                    in
                        t3
                , type table}
            }
        ),

    Expanded = Table.ExpandTableColumn(
        Grouped,
        "Data",
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"},
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"}
    ),

    // Add refresh timestamp
    AddRunTs = Table.AddColumn(Expanded, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs







ME_DATE
BANK_EVENT
FACILITY_EVENT
OWNER_EVENT
MOVEMENT_TYPE
PREV_SSB_SUM
CURR_SSB_SUM
MOM_DELTA_SUM
REVIEWABLE_FLAG_MAX







Process & Methodology

EXECUTIVE SUMMARY (READ THIS FIRST)

WHAT THIS FILE PRODUCES
This workbook delivers a controlled, reconcilable view of the Non-Accrual (NA) portfolio, including:
â€¢ A portfolio-level bridge explaining month-over-month NA balance change
â€¢ Top30 facility review lists for material Downgrades IN and Exits
â€¢ Owner-specific drilldowns to support targeted review and accountability

WHY THE OUTPUTS CAN BE TRUSTED
â€¢ Single source of truth: All results originate from one SQL extract (MoM_Account_Detail)
â€¢ Deterministic pipeline: SQL â†’ Excel table â†’ Power Query rollups â†’ Excel formulas
â€¢ No manual manipulation: One-button refresh minimizes human error
â€¢ Built-in controls: Multiple reconciliation checks must pass before use
â€¢ Transparency: Exceptions (e.g., negative balances) are surfaced, not hidden

DECISION RULE
If Overall QA Health = PASS, outputs are approved for review and distribution.
If FAIL, results should not be used until resolved.

------------------------------------------------------------

1. OUTPUTS & KEY DEFINITIONS

â€¢ NA Population: Accounts flagged as Non-Accrual at month end
â€¢ Movement_Type: Facility-level classification explaining NA population change
â€¢ Reviewable_Flag: Identifies facilities queued for Top30 review
â€¢ Owner_For_Event: Single accountable owner per facility
â€¢ Top30: Prioritized review list, not portfolio totals

------------------------------------------------------------

2. END-TO-END DATA FLOW

SQL (Netezza)
â†’ MoM_Account_Detail (Excel Table)
â†’ Power Query Facility Rollup
â†’ Top30 Engine
â†’ Owner Drilldowns
â†’ Waterfall
â†’ QA & Controls (PASS/FAIL)

------------------------------------------------------------

3. SQL LOGIC OVERVIEW

Month Selection
â€¢ CURR_EOM: latest NA month
â€¢ PREV_EOM: prior NA month

Population Scope
â€¢ NA accounts only
â€¢ Relevant GL categories
â€¢ Positive and negative balances retained

Account-Level Construction
â€¢ Collapse to one row per ACCOUNT_KEY per month
â€¢ Full outer join across months
â€¢ MOM_DELTA = CURR_SSB âˆ’ PREV_SSB
â€¢ Negative diagnostics retained

Event-Scoped Identifiers
â€¢ FOR_EVENT â†’ CURR â†’ PREV logic ensures correct grouping

------------------------------------------------------------

4. FACILITY-LEVEL CLASSIFICATION

Movement_Type
â€¢ Downgrade IN (ex-Auto)
â€¢ Exit (ex-Auto)
â€¢ Persisting Balance Changes (ex-Auto)
â€¢ Autochange variants
â€¢ No Change variants

Owner_For_Event
â€¢ Derived from representative account (largest |SSB_FOR_EVENT|)
â€¢ Absolute overrides applied at facility level

Reviewable_Flag
â€¢ Only Downgrade IN and Exit (ex-Auto)
â€¢ Requires positive exposure
â€¢ Coverage thresholds applied
â€¢ Autochange excluded

------------------------------------------------------------

5. EXCEL LOGIC

Power Query Rollup
â€¢ Groups by Month, Bank, Facility, Owner, Movement_Type
â€¢ Sums PREV_SSB, CURR_SSB, MOM_DELTA

Top30 Engine
â€¢ Downgrade IN ranked by MOM_DELTA
â€¢ Exit ranked by ABS(MOM_DELTA)

Owner Tabs
â€¢ Drilldowns using unified facility key logic
â€¢ Account-level context only

------------------------------------------------------------

6. WATERFALL LOGIC

â€¢ Starting balance = Prior NA population
â€¢ Movement rows explain change
â€¢ Ending balance = Current NA population
â€¢ Negative rows are diagnostic only

------------------------------------------------------------

7. QA & CONTROLS

â€¢ Anchor reconciliation
â€¢ Rollup reconciliation
â€¢ Top30 reconciliation
â€¢ Waterfall tie-out
â€¢ Overall QA Health (PASS/FAIL)





=LET(
  me, Top30_Engine!$B$2,
  topBlock, Top30_Engine!$A$11#,
  topFacilities, INDEX(topBlock,,1),

  facKey,
    IF(MoM_Account_Detail[FACILITY_FOR_EVENT]<>"",
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      IF(MoM_Account_Detail[CURR_FACILITY_ID]<>"",
        MoM_Account_Detail[CURR_FACILITY_ID],
        MoM_Account_Detail[PREV_FACILITY_ID]
      )
    ),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      facKey,
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(facKey, topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)

=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,1),

  facKey,
    IF(MoM_Account_Detail[FACILITY_FOR_EVENT]<>"",
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      IF(MoM_Account_Detail[CURR_FACILITY_ID]<>"",
        MoM_Account_Detail[CURR_FACILITY_ID],
        MoM_Account_Detail[PREV_FACILITY_ID]
      )
    ),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      facKey,
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(facKey, topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)










=LET(
  me, Top30_Engine!$B$2,
  topBlock, Top30_Engine!$A$11#,
  topFacilities, INDEX(topBlock,,1),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)


=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,1),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)









=LET(
  me, $B$2,
  mt, $B$3,
  own, $B$4,
  bk, $B$5,
  topN, $B$7,

  crit,
    (tbl_Facility_Rollup_All[ME_DATE]=me) *
    (tbl_Facility_Rollup_All[MOVEMENT_TYPE]=mt) *
    (tbl_Facility_Rollup_All[REVIEWABLE_FLAG_MAX]=1) *
    IF(own="ALL", 1, tbl_Facility_Rollup_All[OWNER_EVENT]=own) *
    IF(bk="ALL", 1, tbl_Facility_Rollup_All[BANK_EVENT]=bk),

  fac,   FILTER(tbl_Facility_Rollup_All[FACILITY_EVENT], crit),
  ownc,  FILTER(tbl_Facility_Rollup_All[OWNER_EVENT], crit),
  bank,  FILTER(tbl_Facility_Rollup_All[BANK_EVENT], crit),
  prev,  FILTER(tbl_Facility_Rollup_All[PREV_SSB_SUM], crit),
  curr,  FILTER(tbl_Facility_Rollup_All[CURR_SSB_SUM], crit),
  delta, FILTER(tbl_Facility_Rollup_All[MOM_DELTA_SUM], crit),

  metric, IF(mt="Downgrade IN (ex-Auto)", delta, ABS(delta)),

  data, HSTACK(fac, ownc, bank, prev, curr, delta, metric),
  sorted, SORTBY(data, metric, -1),

  TAKE(sorted, MIN(topN, ROWS(sorted)))
)

=LET(
  me, $B$43,
  mt, $B$44,
  own, $B$45,
  bk, $B$46,
  topN, $B$48,

  crit,
    (tbl_Facility_Rollup_All[ME_DATE]=me) *
    (tbl_Facility_Rollup_All[MOVEMENT_TYPE]=mt) *
    (tbl_Facility_Rollup_All[REVIEWABLE_FLAG_MAX]=1) *
    IF(own="ALL", 1, tbl_Facility_Rollup_All[OWNER_EVENT]=own) *
    IF(bk="ALL", 1, tbl_Facility_Rollup_All[BANK_EVENT]=bk),

  fac,   FILTER(tbl_Facility_Rollup_All[FACILITY_EVENT], crit),
  ownc,  FILTER(tbl_Facility_Rollup_All[OWNER_EVENT], crit),
  bank,  FILTER(tbl_Facility_Rollup_All[BANK_EVENT], crit),
  prev,  FILTER(tbl_Facility_Rollup_All[PREV_SSB_SUM], crit),
  curr,  FILTER(tbl_Facility_Rollup_All[CURR_SSB_SUM], crit),
  delta, FILTER(tbl_Facility_Rollup_All[MOM_DELTA_SUM], crit),

  metric, IF(mt="Downgrade IN (ex-Auto)", delta, ABS(delta)),

  data, HSTACK(fac, ownc, bank, prev, curr, delta, metric),
  sorted, SORTBY(data, metric, -1),

  TAKE(sorted, MIN(topN, ROWS(sorted)))
)


let
    Source = pq_MoM_Account_Detail_Excel,

    // -----------------------------
    // Canonical Event Dimensions
    // Priority: FOR_EVENT â†’ CURR â†’ PREV
    // -----------------------------
    AddFacility = Table.AddColumn(Source, "FACILITY_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "FACILITY_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_FACILITY_ID")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_FACILITY_ID")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddBank = Table.AddColumn(AddFacility, "BANK_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "BANK_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    AddOwner = Table.AddColumn(AddBank, "OWNER_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "OWNER_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    // -----------------------------
    // Month End
    // -----------------------------
    AddME = Table.AddColumn(AddOwner, "ME_DATE", each
        let
            c = try Date.From(Record.Field(_, "CURR_EOM")) otherwise null,
            p = try Date.From(Record.Field(_, "PREV_EOM")) otherwise null
        in
            if c <> null then c else p
    , type date),

    // -----------------------------
    // Keep Only What We Need
    // -----------------------------
    KeepCols = Table.SelectColumns(AddME,{
        "ME_DATE",
        "BANK_EVENT",
        "FACILITY_EVENT",
        "OWNER_EVENT",
        "MOVEMENT_TYPE",
        "PREV_SSB",
        "CURR_SSB",
        "MOM_DELTA",
        "REVIEWABLE_FLAG"
    }),

    Types = Table.TransformColumnTypes(KeepCols,{
        {"ME_DATE", type date},
        {"BANK_EVENT", type text},
        {"FACILITY_EVENT", type text},
        {"OWNER_EVENT", type text},
        {"MOVEMENT_TYPE", type text},
        {"PREV_SSB", type number},
        {"CURR_SSB", type number},
        {"MOM_DELTA", type number},
        {"REVIEWABLE_FLAG", Int64.Type}
    }),

    // -----------------------------
    // Facility-Level Rollup
    // -----------------------------
    Grouped = Table.Group(Types,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE"},
        {
            {"PREV_SSB_SUM", each List.Sum([PREV_SSB]), type number},
            {"CURR_SSB_SUM", each List.Sum([CURR_SSB]), type number},
            {"MOM_DELTA_SUM", each List.Sum([MOM_DELTA]), type number},
            {"REVIEWABLE_FLAG_MAX", each List.Max([REVIEWABLE_FLAG]), Int64.Type}
        }
    )
in
    Grouped





/* ================================== Query 1: MoM_Account_Detail ======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags (account-level) */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags (account-level) */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Posâ†’Neg Flip'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Negâ†’Pos Flip'
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Î”'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Î”'
      ELSE NULL
    END AS Negative_Class

  FROM joined j
),

/* CIS totals (account-level window, as-is) */
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
),

/* Event-scoped fields (same logic you had in final SELECT, moved earlier so we can roll up at facility level) */
event_scoped AS (
  SELECT
    w.*,

    /* Account_Name for the â€œeventâ€ side (curr if exists, else prev) */
    CASE
      WHEN w.has_curr=1 THEN w.Curr_Account_Name
      WHEN w.had_prev=1 THEN w.Prev_Account_Name
      ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
    END AS Account_Name_For_Event,

    /* event scoping */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
      WHEN w.has_curr=1 THEN w.Curr_Bank_Code
      ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
    END AS Bank_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
      WHEN w.has_curr=1 THEN w.Curr_Facility_ID
      ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
    END AS Facility_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
      WHEN w.has_curr=1 THEN w.Curr_CIS
      ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
    END AS CIS_For_Event,

    /* choose event-side CSS/PROD/BANK/RBC for downstream owner logic */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CSS
      WHEN w.has_curr=1 THEN w.Curr_CSS
      ELSE COALESCE(w.Curr_CSS, w.Prev_CSS)
    END AS CSS_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_PROD5
      WHEN w.has_curr=1 THEN w.Curr_PROD5
      ELSE COALESCE(w.Curr_PROD5, w.Prev_PROD5)
    END AS PROD5_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_RBC
      WHEN w.has_curr=1 THEN w.Curr_RBC
      ELSE COALESCE(w.Curr_RBC, w.Prev_RBC)
    END AS RBC_For_Event,

    /* balances */
    (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,

    CASE
      WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
      ELSE COALESCE(w.Prev_SSB,0)
    END AS SSB_For_Event
  FROM with_cis w
),

/* Account-level owner (event-side) with Daniel override moved to the top */
account_owner_event AS (
  SELECT
    e.*,

    CASE
      WHEN e.CSS_For_Event = 'INFL10' THEN 'Daniel'  /* HARD OVERRIDE */
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
      WHEN e.Bank_For_Event='L-SVB' THEN 'Eleanor'
      WHEN UPPER(COALESCE(e.RBC_For_Event,''))='R' THEN 'Autochange'
      WHEN e.Bank_For_Event='L-FCB' THEN 'Connor'
      ELSE 'NOT COVERED'
    END AS Owner_Account_For_Event
  FROM event_scoped e
),

/* Rank accounts within facility to pick representative attributes (largest |SSB_For_Event|) */
ranked_in_facility AS (
  SELECT
    a.*,
    ROW_NUMBER() OVER (
      PARTITION BY a.Bank_For_Event, a.Facility_For_Event
      ORDER BY ABS(COALESCE(a.SSB_For_Event,0)) DESC, a.Account_Key
    ) AS rn_fac
  FROM account_owner_event a
),

/* Facility rollup + facility-level classification + facility owner */
facility_rollup AS (
  SELECT
    Bank_For_Event,
    Facility_For_Event,

    /* Presence tests (avoid net-to-zero masking) */
    SUM(ABS(COALESCE(Prev_SSB,0))) AS Fac_Prev_Abs_SSB,
    SUM(ABS(COALESCE(Curr_SSB,0))) AS Fac_Curr_Abs_SSB,

    /* Positive exposure tests (reviewable gating) */
    SUM(CASE WHEN COALESCE(Prev_SSB,0) > 0 THEN COALESCE(Prev_SSB,0) ELSE 0 END) AS Fac_Prev_Pos_SSB,
    SUM(CASE WHEN COALESCE(Curr_SSB,0) > 0 THEN COALESCE(Curr_SSB,0) ELSE 0 END) AS Fac_Curr_Pos_SSB,

    /* Net balances for delta-based â€œpersisting changeâ€ */
    SUM(COALESCE(Prev_SSB,0)) AS Fac_Prev_Net_SSB,
    SUM(COALESCE(Curr_SSB,0)) AS Fac_Curr_Net_SSB,

    /* Facility-level auto flags: ANY auto within facility */
    MAX(CASE WHEN UPPER(COALESCE(Prev_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Prev_Auto_Any,
    MAX(CASE WHEN UPPER(COALESCE(Curr_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Curr_Auto_Any,

    /* Daniel override: ANY INFL10 in facility => Daniel */
    MAX(CASE WHEN CSS_For_Event='INFL10' THEN 1 ELSE 0 END) AS Fac_INFL10_Any,

    /* Representative attributes from top |SSB_For_Event| row */
    MAX(CASE WHEN rn_fac=1 THEN CIS_For_Event END)         AS Fac_CIS_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN PROD5_For_Event END)       AS Fac_PROD5_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN RBC_For_Event END)         AS Fac_RBC_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN Owner_Account_For_Event END) AS Fac_Owner_From_TopRow,

    /* Representative CIS totals from top row (used in threshold exclusions) */
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Curr_CIS_SSB,0) END) AS Fac_Curr_CIS_SSB,
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Prev_CIS_SSB,0) END) AS Fac_Prev_CIS_SSB

  FROM ranked_in_facility
  GROUP BY Bank_For_Event, Facility_For_Event
),

facility_classified AS (
  SELECT
    fr.*,

    /* facility presence flags */
    CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Had_Prev,
    CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Has_Curr,

    /* facility owner for event */
    CASE
      WHEN fr.Fac_INFL10_Any = 1 THEN 'Daniel'
      ELSE COALESCE(fr.Fac_Owner_From_TopRow, 'NOT COVERED')
    END AS Owner_Facility_For_Event,

    /* FACILITY-level Movement_Type */
    CASE
      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
        THEN 'Autochange Downgrade IN'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
        THEN 'Autochange Exit'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange Persisting Balance Changes'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange No Change'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
        THEN 'Downgrade IN (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
        THEN 'Exit (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Persisting Balance Changes (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'No Change (ex-Auto)'

      ELSE NULL
    END AS Movement_Type_Facility,

    /* FACILITY-level Reviewable_Flag (stamped down) */
    CASE
      WHEN (
        /* only these two types are review-queued */
        (CASE
           WHEN (
             CASE
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
               THEN 'Downgrade IN (ex-Auto)'
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
               THEN 'Exit (ex-Auto)'
               ELSE NULL
             END
           ) IS NOT NULL THEN 1 ELSE 0
         END)=1

        AND (
          /* positive exposure must exist on relevant side */
          ( ( /* Downgrade IN */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Curr_Pos_SSB,0) > 0
            )
            OR
            ( /* Exit */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Prev_Pos_SSB,0) > 0
            )
          )
        )

        AND (
          /* exclusions (mirror your prior logic, applied at facility rep-level) */
          CASE
            /* Downgrade IN exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END

            /* Exit exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END
            ELSE 0
          END = 1
        )
      )
      THEN 1 ELSE 0
    END AS Reviewable_Flag_Facility

  FROM facility_rollup fr
)

/* =========================
   FINAL OUTPUT (ACCOUNT_KEY grain)
   - Movement_Type = facility-level Movement_Type_Facility
   - Owner_For_Event = facility-level Owner_Facility_For_Event
   - Reviewable_Flag = facility-level Reviewable_Flag_Facility
========================= */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  a.Account_Key,

  /* prev attributes */
  a.Prev_Account_Identifier,
  a.Prev_Facility_ID,
  a.Prev_CIS,
  a.Prev_Account_Name,
  a.Prev_CSS,
  a.Prev_PROD5,
  a.Prev_RBC,
  a.Prev_Status,
  a.Prev_GL_L4,
  a.Prev_Bank_Code,
  a.Prev_SSB,
  a.Prev_GL_Balance,
  a.Prev_CO_MTD,

  /* curr attributes */
  a.Curr_Account_Identifier,
  a.Curr_Facility_ID,
  a.Curr_CIS,
  a.Curr_Account_Name,
  a.Curr_CSS,
  a.Curr_PROD5,
  a.Curr_RBC,
  a.Curr_Status,
  a.Curr_GL_L4,
  a.Curr_Bank_Code,
  a.Curr_SSB,
  a.Curr_GL_Balance,
  a.Curr_CO_MTD,

  /* event-side display fields */
  a.Account_Name_For_Event,
  a.Bank_For_Event,
  a.Facility_For_Event,
  a.CIS_For_Event,

  /* balances */
  a.MoM_Delta,
  a.SSB_For_Event,

  /* FACILITY movement typing */
  fc.Movement_Type_Facility AS Movement_Type,

  /* Owners (Curr / Prev) with Daniel override absolute */
  CASE
    WHEN a.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Curr_RBC='R' THEN 'Autochange'
    WHEN a.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN a.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Prev_RBC='R' THEN 'Autochange'
    WHEN a.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* FACILITY owner for event */
  fc.Owner_Facility_For_Event AS Owner_For_Event,

  /* FACILITY reviewable flag */
  fc.Reviewable_Flag_Facility AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  a.Curr_CIS_SSB,
  a.Prev_CIS_SSB,
  a.Negative_Flag,
  a.Negative_Class,
  a.Negative_Flip_Flag

FROM ranked_in_facility a
JOIN facility_classified fc
  ON a.Bank_For_Event = fc.Bank_For_Event
 AND a.Facility_For_Event = fc.Facility_For_Event

/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(a.Prev_SSB,0) = 0 AND COALESCE(a.Curr_SSB,0) = 0)

ORDER BY a.Bank_For_Event, a.Facility_For_Event, a.Account_Key;







SQL logic overview

MoM_Account_Detail is built as a month-over-month join at the account level (prev month vs curr month). After joining, the SQL assigns:

an event classification (MOVEMENT_TYPE) that explains what happened MoM, and

an owner attribution (OWNER_FOR_EVENT) so movement and Top30 rollups can be grouped to the correct owner.

The guiding design principle is:

Movement_Type describes the event.
OWNER_FOR_EVENT describes who should be accountable for reviewing that event.

How MOVEMENT_TYPE is assigned

The SQL assigns MOVEMENT_TYPE using a combination of:

Non-Accrual population status (prev vs curr)

Autochange flagging (system-driven vs manual / credit-driven)

Balance change behavior for persisting NA facilities

Even though you donâ€™t always store an explicit â€œNA flagâ€ field in the extract, the SQL effectively derives NA membership from a status indicator (often PREV_STATUS and CURR_STATUS, or an internal NA flag used in the query).

Conceptual decision tree

Step 1 â€” Determine NA membership by month

Prev NA? (was account/facility in NA last month)

Curr NA? (is account/facility in NA this month)

Then:

A) Downgrade IN (ex-Auto)

Meaning: Not NA last month â†’ NA this month, and not system autochange.

Typical condition pattern:

Prev NA = No AND Curr NA = Yes

AND NOT autochange

Result:

MOVEMENT_TYPE = "Downgrade IN (ex-Auto)"

B) Exit (ex-Auto)

Meaning: NA last month â†’ not NA this month, and not system autochange.

Typical condition pattern:

Prev NA = Yes AND Curr NA = No

AND NOT autochange

Result:

MOVEMENT_TYPE = "Exit (ex-Auto)"

C) Persisting Balance Changes (ex-Auto)

Meaning: NA last month â†’ NA this month, and balance changed (excluding autochange).

Typical condition pattern:

Prev NA = Yes AND Curr NA = Yes

AND NOT autochange

AND MOM_DELTA <> 0 (or a threshold)

Result:

MOVEMENT_TYPE = "Persisting Balance Changes (ex-Auto)"

Note: Many builds split â€œPersisting No Î”â€ vs â€œPersisting Î”â€. In your file, the waterfall uses the Î” version as a bridge component.

D) Autochange movements

Meaning: NA changes driven by system autochange logic.

These are parallel to the â€œex-Autoâ€ events, but flagged as autochange:

MOVEMENT_TYPE = "Autochange Downgrade IN"

MOVEMENT_TYPE = "Autochange Exit"

MOVEMENT_TYPE = "Autochange Persisting Balance Changes"

Why we separate Autochange: It allows the waterfall and Top30 review process to isolate system-driven movement from true credit-review movement.

How OWNER_FOR_EVENT is assigned (Owner attribution)

You have:

OWNER_PREV

OWNER_CURR

OWNER_FOR_EVENT

The SQL chooses OWNER_FOR_EVENT based on the type of event so the movement is attributed to the owner most appropriate for review.

Owner attribution rules (recommended / typical)
1) Exits (ex-Auto)

Owner should come from the NA population you are exiting from, i.e. prior month.

OWNER_FOR_EVENT = OWNER_PREV

Reason:

Exits represent the facility leaving NA; the review is tied to who owned it while it was in NA.

2) Downgrade IN (ex-Auto)

Owner should come from the NA population you are entering into, i.e. current month.

OWNER_FOR_EVENT = OWNER_CURR

Reason:

Downgrades represent new NA entries; the review belongs to the owner now managing the facility in NA.

3) Persisting Balance Changes (ex-Auto)

Owner should generally be the current month owner, unless your orgâ€™s accountability model says otherwise.

OWNER_FOR_EVENT = OWNER_CURR (typical)

Reason:

Persisting changes are â€œactive managementâ€ within current NA book.

4) Autochange movements

Typically attributed consistently (most teams attribute autochange to the book owner in the month it appears):

OWNER_FOR_EVENT = OWNER_CURR (common)

Reason:

Keeps autochange impacts aligned to the current month ownership reporting.

Practical implication

This rule set prevents common ownership confusion:

Exits donâ€™t get attributed to the â€œnewâ€ owner that never had the NA facility.

Downgrades donâ€™t get attributed to the prior owner who didnâ€™t have it in NA.

How the â€œFOR_EVENTâ€ fields relate to movement + owner

Your table includes:

FACILITY_FOR_EVENT, CIS_FOR_EVENT, BANK_FOR_EVENT, ACCOUNT_NAME_FOR_EVENT

These exist because a record can â€œmoveâ€ (bank, facility id changes, etc.) or may only exist in one month.

General rule:

For Exit events, â€œFOR_EVENTâ€ values typically align to PREV context.

For Downgrade IN events, â€œFOR_EVENTâ€ values typically align to CURR context.

For Persisting events, they usually align to CURR (or stable identifiers).

This ensures all rollups and Top30 pulls use a consistent facility identifier for the event.

Why you sometimes see negative SSB_FOR_EVENT

SSB_FOR_EVENT is an event-attributed balance used for drilldowns and Top30 detail. It can be negative due to:

negative balance accounts within a facility

â€œnegative classificationâ€ logic (your NEGATIVE_FLAG / NEGATIVE_CLASS)

event attribution rules that apply sign conventions for certain movements

This is why portfolio Starting/Ending balances should be based on population fields (PREV_SSB / CURR_SSB) rather than SSB_FOR_EVENT.

How this ties to Excel objects

MoM_Account_Detail: account-grain event classification + attribution (Movement_Type, Owner_for_event)

tbl_Facility_Rollup_All: PQ rollup using MOVEMENT_TYPE + OWNER_FOR_EVENT to summarize MoM movement at facility level

Top30 Engine: ranks facilities using MOM_DELTA_SUM by movement type and owner

Owner tabs: pulls account-level details using facility membership in the Top30 list + movement type




=LET(
  t, tbl_Facility_Rollup_All,
  owner, "Daniel",
  mt, "Downgrade IN (ex-Auto)",

  /* 1) Filter to Daniel + Movement_Type + Reviewable */
  f, FILTER(t, (t[OWNER_EVEN]=owner)*(t[MOVEMENT_TYPE]=mt)*(t[REVIEWABLE_FLAG_MAX]=1)),

  /* 2) Facility list */
  facList, UNIQUE(f[FACILITY_EVENT]),

  /* 3) Aggregate CURR_SSB_SUM to facility level */
  facSSB, MAP(facList, LAMBDA(x, SUMIFS(f[CURR_SSB_SUM], f[FACILITY_EVENT], x))),

  /* 4) Sort by SSB desc */
  sortedFac, SORTBY(facList, facSSB, -1),
  sortedSSB, SORTBY(facSSB, facSSB, -1),

  /* 5) Cumulative coverage */
  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, IF(total=0, 0, run/total),

  /* 6) Find N to reach 80% */
  n, IF(total=0, 0, XMATCH(TRUE, cov>=0.8, 0)),

  /* 7) Output table */
  IF(total=0,
     {"FACILITY_EVENT","REVIEWABLE_SSB","CUM_COVERAGE";"â€”",0,0},
     VSTACK(
       {"FACILITY_EVENT","REVIEWABLE_SSB","CUM_COVERAGE"},
       TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
     )
  )
)

=LET(
  t, tbl_Facility_Rollup_All,
  owner, "Daniel",
  mt, "Exit (ex-Auto)",

  f, FILTER(t, (t[OWNER_EVEN]=owner)*(t[MOVEMENT_TYPE]=mt)*(t[REVIEWABLE_FLAG_MAX]=1)),

  facList, UNIQUE(f[FACILITY_EVENT]),
  facSSB, MAP(facList, LAMBDA(x, SUMIFS(f[CURR_SSB_SUM], f[FACILITY_EVENT], x))),

  sortedFac, SORTBY(facList, facSSB, -1),
  sortedSSB, SORTBY(facSSB, facSSB, -1),

  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, IF(total=0, 0, run/total),

  n, IF(total=0, 0, XMATCH(TRUE, cov>=0.8, 0)),

  IF(total=0,
     {"FACILITY_EVENT","REVIEWABLE_SSB","CUM_COVERAGE";"â€”",0,0},
     VSTACK(
       {"FACILITY_EVENT","REVIEWABLE_SSB","CUM_COVERAGE"},
       TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
     )
  )
)









=LET(
  owner,"Daniel",
  mt,"Downgrade IN (ex-Auto)",
  t,Facility_Rollup,
  f,FILTER(t, (t[OWNER]=owner)*(t[Movement_Type]=mt)),
  fac,f[FACILITY_ID],
  ssb,f[Reviewable_SSB],
  sortedFac, SORTBY(fac, ssb, -1),
  sortedSSB, SORTBY(ssb, ssb, -1),
  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, IF(total=0, 0, run/total),
  n, IF(total=0, 0, XMATCH(TRUE, cov>=0.8, 0)),
  IF(total=0,
     {"FACILITY_ID","Reviewable_SSB","Cum_Coverage";"â€”",0,0},
     VSTACK(
       {"FACILITY_ID","Reviewable_SSB","Cum_Coverage"},
       TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
     )
  )
)


=LET(
  owner,"Daniel",
  mt,"Exit (ex-Auto)",
  t,Facility_Rollup,
  f,FILTER(t, (t[OWNER]=owner)*(t[Movement_Type]=mt)),
  fac,f[FACILITY_ID],
  ssb,f[Reviewable_SSB],
  sortedFac, SORTBY(fac, ssb, -1),
  sortedSSB, SORTBY(ssb, ssb, -1),
  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, IF(total=0, 0, run/total),
  n, IF(total=0, 0, XMATCH(TRUE, cov>=0.8, 0)),
  IF(total=0,
     {"FACILITY_ID","Reviewable_SSB","Cum_Coverage";"â€”",0,0},
     VSTACK(
       {"FACILITY_ID","Reviewable_SSB","Cum_Coverage"},
       TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
     )
  )
)







=LET(
  owner,"Daniel",
  t,Facility_Rollup,
  f,FILTER(t, t[OWNER]=owner),
  ssb,CHOOSECOLS(f, XMATCH("REVIEWABLE_SSB", t[#Headers])),
  fac,CHOOSECOLS(f, XMATCH("FACILITY_ID", t[#Headers])),
  sortedFac, SORTBY(fac, ssb, -1),
  sortedSSB, SORTBY(ssb, ssb, -1),
  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, run/total,
  n, XMATCH(TRUE, cov>=0.8, 0),
  TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
)





Netezza SQL
   â†“
MoM_Account_Detail (Account-Level Table)
   â†“
Power Query (Excel-sourced, not ODBC)
   â†“
tbl_Facility_Rollup_All (Facility-Level Aggregation)
   â†“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â†“              â†“                 â†“
Top30 Engine   Owner Tabs        Waterfall
(Facility)    (Account Detail)  (Portfolio Bridge)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â†“
QA & Controls
   â†“
Overall QA Health (PASS / FAIL)






1. How to Run the File (Operator Instructions)

Open the workbook

Enable Editing and Enable Macros

Click the Refresh button

Thatâ€™s it.

The refresh macro:

Re-runs the SQL extract that populates MoM_Account_Detail

Refreshes all Power Query rollups that source from that table

Recalculates Top30 Engine logic, Owner tabs, and the Waterfall

Triggers all QA & Controls validations

No manual refreshes or spot checks are required outside the QA & Controls tab.

2. Data & Logic Overview (Whatâ€™s Under the Hood)
A. Core data table: MoM_Account_Detail (account-level)

This is the source-of-truth table at the account grain and contains:

Current and prior month attributes (CURR_*, PREV_*)

Month-over-month movement (MOM_DELTA)

Event classification (MOVEMENT_TYPE)

Reviewable inclusion logic (REVIEWABLE_FLAG)

Event-attributed balance (SSB_FOR_EVENT)

Key distinction (very important):

PREV_SSB / CURR_SSB â†’ population balances (used for portfolio start/end)

MOM_DELTA â†’ movement (used to explain change)

SSB_FOR_EVENT â†’ event attribution (used for Top30 drilldowns; can be negative)

Because SSB_FOR_EVENT is event-attributed, it is not used for portfolio starting or ending balances.

B. Facility rollup: tbl_Facility_Rollup_All (facility-level)

Built in Power Query from the Excel table version of MoM_Account_Detail.

Grain:

Month Ã— Bank Ã— Facility Ã— Owner Ã— Movement Type

Key measures:

PREV_SSB_SUM

CURR_SSB_SUM

MOM_DELTA_SUM

Reviewable_Flag_Max

This rollup is used for:

Facility-level Top30 selection

Waterfall movement rows

3. Top30 Logic (Whatâ€™s Being Reviewed)
How Top30 facilities are selected

Top30 is selected at the facility level, not account level, using movement:

Exit (ex-Auto) â†’ ranked by ABS(MOM_DELTA_SUM)

Downgrade IN (ex-Auto) â†’ ranked by MOM_DELTA_SUM (largest positive movers)

This avoids distortions caused by negative account balances and ensures Top30 reflects true material movement.

Owner tabs (account-level detail)

Once Top30 facilities are identified, the Owner tabs pull account-level rows where:

Facility âˆˆ Top30 list

REVIEWABLE_FLAG = 1

Correct MOVEMENT_TYPE

Current reporting month

These tabs are drilldowns, not control totals.

4. Waterfall Logic (Portfolio-Level Bridge)

The waterfall is a portfolio population bridge, not a movement-only view.

Starting Balance

Total prior-month Non-Accrual population SSB

Derived from MoM_Account_Detail population fields (not movement rollups)

Movement Rows

Derived from tbl_Facility_Rollup_All[MOM_DELTA_SUM]

Broken out by movement type (Exit, Downgrade IN, Autochange, Persisting, etc.)

Explain the change from start â†’ end

Negative Section

The â€œNegative â€¦â€ rows are memo / diagnostic breakouts

They represent subsets of movement already included above

They are excluded from the reconciliation math to avoid double counting

Ending Balance

Total current-month Non-Accrual population SSB

Derived from MoM_Account_Detail population fields

5. QA & Controls â€” What Each Check Validates

The QA & Controls tab is the authoritative validation layer.
If all checks pass, the file is considered correct.

1ï¸âƒ£ Anchor reconciliation

Purpose: Validate the SQL extract itself

Confirms total current and prior month SSB from MoM_Account_Detail

Reconciles to a simple, independent â€œAnchorâ€ query

Ensures the base population is complete and accurate

2ï¸âƒ£ Facility rollup reconciliation

Purpose: Validate Power Query aggregation

Confirms total current and prior SSB from MoM_Account_Detail

Reconciles to totals in tbl_Facility_Rollup_All

Ensures no loss, duplication, or filtering errors in rollups

3ï¸âƒ£ Top30 reconciliation & coverage reasonableness

Purpose: Validate Top30 logic and drilldowns

Confirms Top30 SSB totals reconcile to individual Owner tabs

Confirms coverage % is reasonable relative to portfolio size

Ensures Top30 lists are subsets of the full population, not overstated

4ï¸âƒ£ Waterfall reconciliation

Purpose: Validate portfolio bridge integrity

Confirms:

Ending Balance = Starting Balance + Net Core Movement


Ensures movement logic fully explains the population change

Confirms no double counting (especially with negative memo rows)

5ï¸âƒ£ Overall QA Health

Purpose: Executive-level signal

Aggregates all checks into a single PASS / FAIL indicator

If PASS â†’ results are ready for review

If FAIL â†’ investigation required before distribution

6. Interpretation Guidance (For Reviewers)

Top30 â‰  total portfolio
Top30 is a focused review set, not a control total.

Negative balances are expected at account level
They are handled correctly at facility and portfolio levels.

Waterfall negatives are informational
They provide transparency but do not alter the bridge math.







Validate the total current and previous month end SOURCE_SYSTEM_BALANCE (SSB) from MoM_Account_Detail reconciles to simple 'Anchor' query

Validate the total current and previous month end SSB from MoM_Account_Detail reconciles to Facility_Rollup

Validate Top30 SSB for current month reconciles to individual 'Owner' tabs for their respective 'Segments' and coverage % is reasonable

Validate Bridge rows reconcile to total ending balance

Overall QA Health






File Preparation Steps
1) Run the MoM_Account_Detail extract (SQL â†’ Excel)

Refresh the MoM_Account_Detail query (your Netezza ODBC query).

Confirm it loads into the Excel table named MoM_Account_Detail.

Validate the month:

CURR_EOM should equal the current month-end youâ€™re reporting.

PREV_EOM should be the prior month-end.

Quick check: Filter MoM_Account_Detail[CURR_EOM] and make sure thereâ€™s only one current month (unless you intentionally pull history).

2) Refresh Power Query rollups (Excel-local; should not hit ODBC)

Confirm the PQ staging query is sourced from the in-workbook table, not ODBC:

In Power Query, the source step should be Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content]

Refresh these queries (in order):

pq_MoM_Account_Detail_Excel (or whatever you named the Excel-table-based source)

pq_Facility_Rollup_All

Confirm output table exists in the workbook as:

tbl_Facility_Rollup_All

Why this matters: You donâ€™t want the rollups re-querying Netezza; they should reference the already-loaded table.

3) Set the reporting month used by the dashboard formulas

On Top30_Engine, set/refresh:

Top30_Engine!B43 = current month end (should match MoM_Account_Detail[CURR_EOM])

(You can keep this as a formula like =MAX(MoM_Account_Detail[CURR_EOM]) if you want it automatic.)

4) Refresh the Top30 lists

On Top30_Engine:

Confirm the Top30 spill blocks refresh correctly (e.g., the block starting at Top30_Engine!A52#).

Confirm no blanks/zeros are being ranked unintentionally.

5) Refresh each Top30_Owner tab

For each owner tab:

Confirm the Top30 list matches the engine block for that owner/movement type.

Confirm the Account Detail spill pulls rows.

Confirm KPI cards populate.

6) Refresh the Waterfall

On the Waterfall tab:

Verify the bank columns populate (L-FCB, L-CIT, L-SVB, Total).

Confirm the checks tie (see â€œChecksâ€ section below).

Logic Overview (SQL â†’ Excel)
A) SQL logic (MoM_Account_Detail)

MoM_Account_Detail is an account-level month-over-month comparison table.

It contains:

Current month attributes (CURR_*)

Prior month attributes (PREV_*)

Event attribution fields (*_FOR_EVENT) that determine how movements are classified

Movement classification (MOVEMENT_TYPE)

Reviewable logic (REVIEWABLE_FLAG)

Balances:

PREV_SSB, CURR_SSB (population balances)

MOM_DELTA (change)

SSB_FOR_EVENT (event-attributed SSB used for drilldowns)

Important distinction:

PREV_SSB / CURR_SSB = population balances (used for portfolio starting/ending)

MOM_DELTA = movement amount (used for bridge explanations)

SSB_FOR_EVENT = event-attributed amount (useful for Top30 drilldowns / account details; can be negative depending on event logic)

B) Excel / Power Query logic
1) Facility rollup (tbl_Facility_Rollup_All)

Power Query groups account rows into facility-level movement summaries:

Grain: ME_DATE Ã— Bank Ã— Facility Ã— Owner Ã— Movement_Type

Measures:

PREV_SSB_SUM (sum of PREV_SSB)

CURR_SSB_SUM (sum of CURR_SSB)

MOM_DELTA_SUM (sum of MOM_DELTA)

Reviewable_Flag_Max (max REVIEWABLE_FLAG)

This rollup is ideal for:

Top30 selection at facility level

Waterfall movement rows by movement type

2) Top30 logic

Top30 is selected at facility level using the rollup measures:

Exit (ex-Auto): rank by ABS(MOM_DELTA_SUM)

Downgrade IN (ex-Auto): rank by MOM_DELTA_SUM (largest positive movers)

Account-level detail is pulled from MoM_Account_Detail using:

Facility âˆˆ Top30 list

REVIEWABLE_FLAG=1

MOVEMENT_TYPE matches

CURR_EOM = Top30_Engine!B43

3) KPI cards on Top30_Owner tabs

KPI cards are owner-level summaries filtered by:

Owner

Movement type

Reviewable flag

Reporting month

(And if you choose, restrict to positive-only values where needed.)

Waterfall Logic (Portfolio Level)
The key point

The waterfall is portfolio population + bridge, not movement-only.

Starting Balance

Must represent the prior month NA population (not a movement subset).

Ending Balance

Must represent the current month NA population.

Bridge rows

Explain how you got from start to end using:

movement type buckets (from tbl_Facility_Rollup_All)

optional negative diagnostics (from MoM_Account_Detail)

Checks and Tie-Outs
The issue you found (and the fix you applied)

Your â€œnegativeâ€ section is a subset breakout of movement already included above.
So if you include negatives in the bridge sum, you double count.

Correct approach (memo-only negative section)

Keep negative rows as informational

Exclude them from the tie-out math

Checks that must tie

Ending - (Starting + Net Core Movement) should equal 0

Your Check1/Check2 should exclude the negative rows (memo section)

Practical Validation Checklist (takes 2 minutes)

Month sanity

Top30_Engine!B43 equals the CURR_EOM in MoM_Account_Detail.

Population sanity

Starting Balance (prior NA population) looks reasonable vs last month.

Ending Balance (current NA population) looks reasonable vs current month close.

Movement sanity

Exits are negative (or displayed as negative) and reduce the balance.

Downgrades increase the balance.

Tie-out

Check cells = 0 (or within rounding tolerance if you have pennies).




=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "Neg: New (No Prior)",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43,
  MoM_Account_Detail[REVIEWABLE_FLAG], 1
)


=SUM(
  SUMIFS(
    MoM_Account_Detail[MOM_DELTA],
    MoM_Account_Detail[NEGATIVE_CLASS], "Neg: Cleared to Zero",
    MoM_Account_Detail[CURR_BANK_CODE], C$1,
    MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43,
    MoM_Account_Detail[REVIEWABLE_FLAG], 1
  ),
  SUMIFS(
    MoM_Account_Detail[MOM_DELTA],
    MoM_Account_Detail[NEGATIVE_CLASS], "Neg: Negâ†’Pos Flip",
    MoM_Account_Detail[CURR_BANK_CODE], C$1,
    MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43,
    MoM_Account_Detail[REVIEWABLE_FLAG], 1
  )
)


=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "Neg: Persisting Î”",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43,
  MoM_Account_Detail[REVIEWABLE_FLAG], 1
)





Neg: Cleared to Zero
Neg: Negâ†’Pos Flip
Neg: New (No Prior)
Neg: Persisting No Î”
Neg: Persisting Î”
Neg: Posâ†’Neg Flip





=SUMIFS(
  tbl_Facility_Rollup_All[MOM_DELTA_SUM],
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Autochange Downgrade IN",
  tbl_Facility_Rollup_All[BANK_EVENT], C$1,
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)


=-ABS(
  SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Autochange Exit",
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  )
)

=SUMIFS(
  tbl_Facility_Rollup_All[MOM_DELTA_SUM],
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Autochange Persisting Balance Changes",
  tbl_Facility_Rollup_All[BANK_EVENT], C$1,
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)

=SUMIFS(
  tbl_Facility_Rollup_All[MOM_DELTA_SUM],
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Persisting Balance Changes (ex-Auto)",
  tbl_Facility_Rollup_All[BANK_EVENT], C$1,
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)

=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "New",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)


=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "Exit",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)

=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "Persisting Net",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)





=LET(
  me, Top30_Engine!$B$43,
  SUMIFS(
    MoM_Account_Detail[PREV_SSB],
    MoM_Account_Detail[CURR_EOM], me,
    MoM_Account_Detail[PREV_BANK_CODE], C$1,
    MoM_Account_Detail[PREV_STATUS], "Y"
  )
)


=LET(
  me, Top30_Engine!$B$43,
  SUMIFS(
    MoM_Account_Detail[CURR_SSB],
    MoM_Account_Detail[CURR_EOM], me,
    MoM_Account_Detail[CURR_BANK_CODE], C$1,
    MoM_Account_Detail[CURR_STATUS], "Y"
  )
)

=LET(
  me, Top30_Engine!$B$43,
  SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  )
)


=LET(
  me, Top30_Engine!$B$43,
  -ABS(SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Exit (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ))
)







=LET(
  me, Top30_Engine!$B$43,
  IFERROR(SUMIFS(
    tbl_Facility_Rollup_All[PREV_SSB_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ),0)
)


=LET(
  me, Top30_Engine!$B$43,
  IFERROR(SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ),0)
)

=LET(
  me, Top30_Engine!$B$43,
  -ABS(IFERROR(SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Exit (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ),0))
)

=LET(
  me, Top30_Engine!$B$43,
  IFERROR(SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Persisting Balance Changes (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ),0)
)









=SUMIFS(
  tbl_Facility_Rollup_All[PREV_SSB_SUM],
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[OWNER_EVENT], $B$2,
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Exit (ex-Auto)",
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)



=SUMIFS(
  tbl_Facility_Rollup_All[CURR_SSB_SUM],
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[OWNER_EVENT], $B$2,
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)





=SUMIFS(
  MoM_Account_Detail[SSB_FOR_EVENT],
  MoM_Account_Detail[OWNER_FOR_EVENT], $B$2,
  MoM_Account_Detail[REVIEWABLE_FLAG], 1,
  MoM_Account_Detail[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)





=SUMIFS(
  MoM_Account_Detail[SSB_FOR_EVENT],
  MoM_Account_Detail[REVIEWABLE_FLAG], 1,
  MoM_Account_Detail[MOVEMENT_TYPE], "Exit (ex-Auto)",
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)


=SUMIFS(
  MoM_Account_Detail[SSB_FOR_EVENT],
  MoM_Account_Detail[REVIEWABLE_FLAG], 1,
  MoM_Account_Detail[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)








=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,3),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)






MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]






=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,3),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],        /* ACCOUNT_NAME */
      MoM_Account_Detail[PREV_CIS],                 /* CIS_CUSTOMER_NUMBER */
      MoM_Account_Detail[FACILITY_FOR_EVENT],       /* FACILITY_ID */
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],  /* ACCOUNT_IDENTIFIER */
      MoM_Account_Detail[ACCOUNT_KEY],              /* ACCOUNT_KEY */
      MoM_Account_Detail[PREV_BANK_CODE],           /* BANK_CODE */
      MoM_Account_Detail[PREV_CSS],                 /* CONTRACT_SOURCE_SYSTEM */
      MoM_Account_Detail[PREV_GL_L4],               /* GL_ACCOUNT_HIER_LEVEL_4 */
      MoM_Account_Detail[PREV_PROD5],               /* PROD_HIER_LEVEL_5 */
      MoM_Account_Detail[PREV_STATUS],              /* STATUS_CODE */
      MoM_Account_Detail[PREV_RBC],                 /* RBC_CODE */
      MoM_Account_Detail[PREV_SSB],                 /* SOURCE_SYSTEM_BALANCE */
      MoM_Account_Detail[PREV_GL_BALANCE]           /* GL_BALANCE */
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)






=LET(
  me, Top30_Engine!$B$1,
  topBlock, $R$50#,
  topFacilities, INDEX(topBlock,,3),

  acct_identifier, IF(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER]<>"",
                      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
                      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER]),

  bank_code, IF(MoM_Account_Detail[BANK_FOR_EVENT]<>"",
                MoM_Account_Detail[BANK_FOR_EVENT],
                IF(MoM_Account_Detail[CURR_BANK_CODE]<>"",
                   MoM_Account_Detail[CURR_BANK_CODE],
                   MoM_Account_Detail[PREV_BANK_CODE])),

  css, IF(MoM_Account_Detail[CURR_CSS]<>"", MoM_Account_Detail[CURR_CSS], MoM_Account_Detail[PREV_CSS]),
  gl4, IF(MoM_Account_Detail[CURR_GL_L4]<>"", MoM_Account_Detail[CURR_GL_L4], MoM_Account_Detail[PREV_GL_L4]),
  prod5, IF(MoM_Account_Detail[CURR_PROD5]<>"", MoM_Account_Detail[CURR_PROD5], MoM_Account_Detail[PREV_PROD5]),
  status, IF(MoM_Account_Detail[CURR_STATUS]<>"", MoM_Account_Detail[CURR_STATUS], MoM_Account_Detail[PREV_STATUS]),
  rbc, IF(MoM_Account_Detail[CURR_RBC]<>"", MoM_Account_Detail[CURR_RBC], MoM_Account_Detail[PREV_RBC]),
  gl_balance, IF(MoM_Account_Detail[CURR_GL_BALANCE]<>"", MoM_Account_Detail[CURR_GL_BALANCE], MoM_Account_Detail[PREV_GL_BALANCE]),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT],   /* ACCOUNT_NAME */
      MoM_Account_Detail[CIS_FOR_EVENT],            /* CIS_CUSTOMER_NUMBER */
      MoM_Account_Detail[FACILITY_FOR_EVENT],       /* FACILITY_ID */
      acct_identifier,                              /* ACCOUNT_IDENTIFIER */
      MoM_Account_Detail[ACCOUNT_KEY],              /* ACCOUNT_KEY */
      bank_code,                                    /* BANK_CODE */
      css,                                          /* CONTRACT_SOURCE_SYSTEM */
      gl4,                                          /* GL_ACCOUNT_HIER_LEVEL_4 */
      prod5,                                        /* PROD_HIER_LEVEL_5 */
      status,                                       /* STATUS_CODE */
      rbc,                                          /* RBC_CODE */
      MoM_Account_Detail[SSB_FOR_EVENT],            /* SOURCE_SYSTEM_BALANCE */
      gl_balance                                    /* GL_BALANCE */
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[OWNER_FOR_EVENT]=$R$46) *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)





=LET(
  topBlock, $R$50#,
  topFacilities, INDEX(topBlock,,3),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE],
      MoM_Account_Detail[MOVEMENT_TYPE],
      MoM_Account_Detail[OWNER_FOR_EVENT2]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(
        MATCH(
          MoM_Account_Detail[FACILITY_FOR_EVENT],
          topFacilities,
          0
        )
      )
      * (MoM_Account_Detail[REVIEWABLE_FLAG]=1)
      * (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)")
      * (MoM_Account_Detail[OWNER_FOR_EVENT2]=$R$46)
    ),

  SORT(filtered, 12, -1)
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  base, IFERROR(FILTER(MoM_Account_Detail, crit), ""),

  h, MoM_Account_Detail[#Headers],

  acct_name, CHOOSECOLS(base, XMATCH("ACCOUNT_NAME_FOR_EVENT", h)),
  cis,       CHOOSECOLS(base, XMATCH("CIS_FOR_EVENT", h)),
  fac,       CHOOSECOLS(base, XMATCH("FACILITY_FOR_EVENT", h)),

  acct_id_c, CHOOSECOLS(base, XMATCH("CURR_ACCOUNT_IDENTIFIER", h)),
  acct_id_p, CHOOSECOLS(base, XMATCH("PREV_ACCOUNT_IDENTIFIER", h)),
  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),

  acct_key,  CHOOSECOLS(base, XMATCH("ACCOUNT_KEY", h)),

  bank_evt,  CHOOSECOLS(base, XMATCH("BANK_FOR_EVENT", h)),
  bank_c,    CHOOSECOLS(base, XMATCH("CURR_BANK_CODE", h)),
  bank_p,    CHOOSECOLS(base, XMATCH("PREV_BANK_CODE", h)),
  bank,      IF(bank_evt<>"", bank_evt, IF(bank_c<>"", bank_c, bank_p)),

  css_c,     CHOOSECOLS(base, XMATCH("CURR_CSS", h)),
  css_p,     CHOOSECOLS(base, XMATCH("PREV_CSS", h)),
  css,       IF(css_c<>"", css_c, css_p),

  gl4_c,     CHOOSECOLS(base, XMATCH("CURR_GL_L4", h)),
  gl4_p,     CHOOSECOLS(base, XMATCH("PREV_GL_L4", h)),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),

  prod5_c,   CHOOSECOLS(base, XMATCH("CURR_PROD5", h)),
  prod5_p,   CHOOSECOLS(base, XMATCH("PREV_PROD5", h)),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),

  status_c,  CHOOSECOLS(base, XMATCH("CURR_STATUS", h)),
  status_p,  CHOOSECOLS(base, XMATCH("PREV_STATUS", h)),
  status,    IF(status_c<>"", status_c, status_p),

  rbc_c,     CHOOSECOLS(base, XMATCH("CURR_RBC", h)),
  rbc_p,     CHOOSECOLS(base, XMATCH("PREV_RBC", h)),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),

  ssb_evt,   CHOOSECOLS(base, XMATCH("SSB_FOR_EVENT", h)),

  glb_c,     CHOOSECOLS(base, XMATCH("CURR_GL_BALANCE", h)),
  glb_p,     CHOOSECOLS(base, XMATCH("PREV_GL_BALANCE", h)),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  IF(base="","",
    HSTACK(acct_name, cis, fac, acct_id, acct_key, bank, css, gl4, prod5, status, rbc, ssb_evt, glb)
  )
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),

  acct_id_c, FILTER(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER], crit),
  acct_id_p, FILTER(MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER], crit),
  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),

  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),

  bank_evt,  FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),
  bank_c,    FILTER(MoM_Account_Detail[CURR_BANK_CODE], crit),
  bank_p,    FILTER(MoM_Account_Detail[PREV_BANK_CODE], crit),
  bank,      IF(bank_evt<>"", bank_evt, IF(bank_c<>"", bank_c, bank_p)),

  css_c,     FILTER(MoM_Account_Detail[CURR_CSS], crit),
  css_p,     FILTER(MoM_Account_Detail[PREV_CSS], crit),
  css,       IF(css_c<>"", css_c, css_p),

  gl4_c,     FILTER(MoM_Account_Detail[CURR_GL_L4], crit),
  gl4_p,     FILTER(MoM_Account_Detail[PREV_GL_L4], crit),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),

  prod5_c,   FILTER(MoM_Account_Detail[CURR_PROD5], crit),
  prod5_p,   FILTER(MoM_Account_Detail[PREV_PROD5], crit),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),

  status_c,  FILTER(MoM_Account_Detail[CURR_STATUS], crit),
  status_p,  FILTER(MoM_Account_Detail[PREV_STATUS], crit),
  status,    IF(status_c<>"", status_c, status_p),

  rbc_c,     FILTER(MoM_Account_Detail[CURR_RBC], crit),
  rbc_p,     FILTER(MoM_Account_Detail[PREV_RBC], crit),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),

  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  glb_c,     FILTER(MoM_Account_Detail[CURR_GL_BALANCE], crit),
  glb_p,     FILTER(MoM_Account_Detail[PREV_GL_BALANCE], crit),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  HSTACK(
    acct_name,
    cis,
    fac,
    acct_id,
    acct_key,
    bank,
    css,
    gl4,
    prod5,
    status,
    rbc,
    ssb_evt,
    glb
  )
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),
  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),
  bank,      FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),
  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  HSTACK(acct_name, cis, fac, acct_key, bank, ssb_evt)
)






=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),
  acct_id_c, FILTER(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER], crit),
  acct_id_p, FILTER(MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER], crit),
  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),

  bank,      FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),

  css_c,     FILTER(MoM_Account_Detail[CURR_CSS], crit),
  css_p,     FILTER(MoM_Account_Detail[PREV_CSS], crit),

  gl4_c,     FILTER(MoM_Account_Detail[CURR_GL_L4], crit),
  gl4_p,     FILTER(MoM_Account_Detail[PREV_GL_L4], crit),

  prod5_c,   FILTER(MoM_Account_Detail[CURR_PROD5], crit),
  prod5_p,   FILTER(MoM_Account_Detail[PREV_PROD5], crit),

  status_c,  FILTER(MoM_Account_Detail[CURR_STATUS], crit),
  status_p,  FILTER(MoM_Account_Detail[PREV_STATUS], crit),

  rbc_c,     FILTER(MoM_Account_Detail[CURR_RBC], crit),
  rbc_p,     FILTER(MoM_Account_Detail[PREV_RBC], crit),

  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  glb_c,     FILTER(MoM_Account_Detail[CURR_GL_BALANCE], crit),
  glb_p,     FILTER(MoM_Account_Detail[PREV_GL_BALANCE], crit),

  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),
  css,       IF(css_c<>"", css_c, css_p),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),
  status,    IF(status_c<>"", status_c, status_p),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  headers, {"ACCOUNT_NAME","CIS_CUSTOMER_NUMBER","FACILITY_ID","ACCOUNT_IDENTIFIER","ACCOUNT_KEY","BANK_CODE","CONTRACT_SOURCE_SYSTEM","GL_ACCOUNT_HIER_LEVEL_4","PROD_HIER_LEVEL_5","STATUS_CODE","RBC_CODE","SOURCE_SYSTEM_BALANCE","GL_BALANCE"},

  data, HSTACK(acct_name,cis,fac,acct_id,acct_key,bank,css,gl4,prod5,status,rbc,ssb_evt,glb),

  VSTACK(headers, data)
)






Here are the columns I want to show for both top30 facilities' account level detail categories (Downgrade IN (ex-Auto) and Exit (ex-Auto)) within the Top30_Owner tabs. You may need to wire the formulas to pull the correct corresponding columns from MoM_Account_Detail.

ACCOUNT_NAME
CIS_CUSTOMER_NUMBER
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
BANK_CODE
CONTRACT_SOURCE_SYSTEM
GL_ACCOUNT_HIER_LEVEL_4
PROD_HIER_LEVEL_5
STATUS_CODE
RBC_CODE
SOURCE_SYSTEM_BALANCE 
GL_BALANCE

Here are the columns I currently have in MoM_Account_Detail:

QUERY_RUN_TIMESTAMP
CURR_EOM
PREV_EOM
ACCOUNT_KEY
PREV_ACCOUNT_IDENTIFIER
PREV_FACILITY_ID
PREV_CIS
PREV_ACCOUNT_NAME
PREV_CSS
PREV_PROD5
PREV_RBC
PREV_STATUS
PREV_GL_L4
PREV_BANK_CODE
PREV_SSB 
PREV_GL_BALANCE
PREV_CO_MTD 
CURR_ACCOUNT_IDENTIFIER
CURR_FACILITY_ID
CURR_CIS
CURR_ACCOUNT_NAME
CURR_CSS
CURR_PROD5
CURR_RBC
CURR_STATUS
CURR_GL_L4
CURR_BANK_CODE
CURR_SSB 
CURR_GL_BALANCE
CURR_CO_MTD 
ACCOUNT_NAME_FOR_EVENT
BANK_FOR_EVENT
FACILITY_FOR_EVENT
CIS_FOR_EVENT
MOM_DELTA 
SSB_FOR_EVENT 
MOVEMENT_TYPE
OWNER_CURR
OWNER_PREV
OWNER_FOR_EVENT
REVIEWABLE_FLAG
CURR_CIS_SSB 
PREV_CIS_SSB 
NEGATIVE_FLAG
NEGATIVE_CLASS
NEGATIVE_FLIP_FLAG
Curr_CO_MTD_Lookup








=LET(
  me, $B$1,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,

  crit,
    (tbl_Facility_Rollup_All[ME_DATE]=me) *
    (tbl_Facility_Rollup_All[MOVEMENT_TYPE]=mt) *
    (tbl_Facility_Rollup_All[Reviewable_Flag_Max]=1) *
    IF(own="ALL", 1, tbl_Facility_Rollup_All[OWNER_EVENT]=own) *
    IF(bk="ALL", 1, tbl_Facility_Rollup_All[BANK_EVENT]=bk),

  fac,   FILTER(tbl_Facility_Rollup_All[FACILITY_EVENT], crit),
  ownc,  FILTER(tbl_Facility_Rollup_All[OWNER_EVENT], crit),
  bank,  FILTER(tbl_Facility_Rollup_All[BANK_EVENT], crit),
  prev,  FILTER(tbl_Facility_Rollup_All[Prev_SSB_SUM], crit),
  curr,  FILTER(tbl_Facility_Rollup_All[Curr_SSB_SUM], crit),
  delta, FILTER(tbl_Facility_Rollup_All[MoM_Delta_SUM], crit),

  metric, IF(mt="Downgrade IN (ex-Auto)", delta, ABS(delta)),

  data, HSTACK(fac, ownc, bank, prev, curr, delta, metric),
  sorted, SORTBY(data, metric, -1),

  TAKE(sorted, MIN(topN, ROWS(sorted)))
)

Facility | Owner | Bank | Prev_SSB | Curr_SSB | MoM_Delta | Magnitude




=LET(
  t, tbl_Facility_Rollup_All,
  me, $B$1,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,

  base, FILTER(
    t,
    (t[ME_DATE]=me) *
    (t[MOVEMENT_TYPE]=mt) *
    (t[Reviewable_Flag_Max]=1) *
    (IF(own="ALL", TRUE, t[OWNER_EVENT]=own)) *
    (IF(bk="ALL", TRUE, t[BANK_EVENT]=bk))
  ),

  metric, IF(mt="Exit (ex-Auto)", ABS(base[MoM_Delta_SUM]), ABS(base[MoM_Delta_SUM])),
  sorted, SORTBY(base, metric, -1),

  HSTACK(
    TAKE(sorted[FACILITY_EVENT], topN),
    TAKE(sorted[OWNER_EVENT], topN),
    TAKE(sorted[BANK_EVENT], topN),
    TAKE(sorted[Prev_SSB_SUM], topN),
    TAKE(sorted[Curr_SSB_SUM], topN),
    TAKE(sorted[MoM_Delta_SUM], topN),
    TAKE(metric, topN)
  )
)






=LET(
  t, tbl_Facility_Rollup_Latest,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,
  onlyRev, TRUE,

  base, FILTER(
    t,
    (t[MOVEMENT_TYPE]=mt) *
    (IF(onlyRev, t[Reviewable_Flag_Max]=1, TRUE)) *
    (IF(own="ALL", TRUE, t[OWNER_EVENT]=own)) *
    (IF(bk="ALL", TRUE, t[BANK_EVENT]=bk))
  ),

  // ranking metric:
  // - Exit: rank by ABS(delta)
  // - Downgrade IN: rank by delta (positive)
  // default: ABS(delta)
  metric, IF(
    mt="Exit (ex-Auto)",
    ABS(CHOOSECOLS(base, XMATCH("MoM_Delta_SUM", t[#Headers]))),
    ABS(CHOOSECOLS(base, XMATCH("MoM_Delta_SUM", t[#Headers])))
  ),

  sorted, SORTBY(base, metric, -1),

  out, HSTACK(
    TAKE(CHOOSECOLS(sorted, XMATCH("FACILITY_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("OWNER_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("BANK_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("Prev_SSB_SUM", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("Curr_SSB_SUM", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("MoM_Delta_SUM", t[#Headers])), topN),
    TAKE(metric, topN)
  ),

  out
)






let
    Source = Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content]
in
    Source





This is a Player Snapshot â€” not a stat sheet.

Traditional hockey stats tell you what happened.
They rarely help explain what to do next.

The IceStat Player Snapshot is designed to give coaches:
â€¢ A clear, blended view of player impact
â€¢ Trend context over time
â€¢ Supporting detail when deeper explanation is needed

Not more numbers â€”
but a clearer picture to support real coaching decisions.

This example uses synthetic data to show how IceStat translates tracked events into coaching context.

Team context and workflow matter just as much â€” more on that soon.







let
    Source = #"MoM_Account_Detail",

    // -----------------------------
    // Canonical Event Dimensions
    // Priority: FOR_EVENT â†’ CURR â†’ PREV
    // -----------------------------
    AddFacility = Table.AddColumn(Source, "FACILITY_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "FACILITY_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_FACILITY_ID")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_FACILITY_ID")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddBank = Table.AddColumn(AddFacility, "BANK_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "BANK_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    AddOwner = Table.AddColumn(AddBank, "OWNER_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "OWNER_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    // -----------------------------
    // Month End
    // -----------------------------
    AddME = Table.AddColumn(AddOwner, "ME_DATE", each
        let
            c = try Date.From(Record.Field(_, "CURR_EOM")) otherwise null,
            p = try Date.From(Record.Field(_, "PREV_EOM")) otherwise null
        in
            if c <> null then c else p
    , type date),

    // -----------------------------
    // Keep Only What We Need
    // -----------------------------
    KeepCols = Table.SelectColumns(AddME,{
        "ME_DATE",
        "BANK_EVENT",
        "FACILITY_EVENT",
        "OWNER_EVENT",
        "MOVEMENT_TYPE",
        "Prev_SSB",
        "Curr_SSB",
        "MoM_Delta",
        "REVIEWABLE_FLAG"
    }),

    Types = Table.TransformColumnTypes(KeepCols,{
        {"ME_DATE", type date},
        {"BANK_EVENT", type text},
        {"FACILITY_EVENT", type text},
        {"OWNER_EVENT", type text},
        {"MOVEMENT_TYPE", type text},
        {"Prev_SSB", type number},
        {"Curr_SSB", type number},
        {"MoM_Delta", type number},
        {"REVIEWABLE_FLAG", Int64.Type}
    }),

    // -----------------------------
    // Facility-Level Rollup
    // -----------------------------
    Grouped = Table.Group(Types,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE"},
        {
            {"Prev_SSB_SUM", each List.Sum([Prev_SSB]), type number},
            {"Curr_SSB_SUM", each List.Sum([Curr_SSB]), type number},
            {"MoM_Delta_SUM", each List.Sum([MoM_Delta]), type number},
            {"Reviewable_Flag_Max", each List.Max([REVIEWABLE_FLAG]), Int64.Type}
        }
    )
in
    Grouped








AddME = Table.AddColumn(AddOwner, "ME_DATE", each
    let
        c = try Date.From(Record.Field(_, "CURR_EOM")) otherwise null,
        p = try Date.From(Record.Field(_, "PREV_EOM")) otherwise null
    in
        if c <> null then c else p
, type date),






let
    Source = Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content],

    // -----------------------------
    // 1) Add "canonical" event columns
    //    Rule: FOR_EVENT -> CURR -> PREV
    // -----------------------------
    AddFacility = Table.AddColumn(Source, "FACILITY_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "FACILITY_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_FACILITY_ID")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_FACILITY_ID")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddBank = Table.AddColumn(AddFacility, "BANK_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "BANK_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_BANK")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_BANK")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddOwner = Table.AddColumn(AddBank, "OWNER_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "OWNER_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_OWNER")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_OWNER")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddME = Table.AddColumn(AddOwner, "ME_DATE", each
        let
            me = try Date.From(Record.Field(_, "END_OF_MONTH_DATE")) otherwise null
        in
            me
    , type date),

    // -----------------------------
    // 2) Keep only what we need (fast + stable)
    //    IMPORTANT: adjust measure column names here if needed
    // -----------------------------
    KeepCols = Table.SelectColumns(AddME,{
        "ME_DATE",
        "BANK_FOR_EVENT_STD",
        "FACILITY_FOR_EVENT_STD",
        "OWNER_FOR_EVENT_STD",
        "MOVEMENT_TYPE",

        // measures (edit if your names differ)
        "SSB_FOR_EVENT",
        "MOM_DELTA",
        "REVIEWABLE_FLAG"
    }),

    Types = Table.TransformColumnTypes(KeepCols,{
        {"ME_DATE", type date},
        {"BANK_FOR_EVENT_STD", type text},
        {"FACILITY_FOR_EVENT_STD", type text},
        {"OWNER_FOR_EVENT_STD", type text},
        {"MOVEMENT_TYPE", type text},
        {"SSB_FOR_EVENT", type number},
        {"MOM_DELTA", type number},
        {"REVIEWABLE_FLAG", Int64.Type}
    }),

    // -----------------------------
    // 3) Roll up to facility level for Top30 + Waterfall
    // -----------------------------
    Grouped = Table.Group(Types,
        {"ME_DATE","BANK_FOR_EVENT_STD","FACILITY_FOR_EVENT_STD","OWNER_FOR_EVENT_STD","MOVEMENT_TYPE"},
        {
            {"SSB_FOR_EVENT_SUM", each List.Sum([SSB_FOR_EVENT]), type number},
            {"MOM_DELTA_SUM", each List.Sum([MOM_DELTA]), type number},
            {"REVIEWABLE_FLAG_MAX", each List.Max([REVIEWABLE_FLAG]), Int64.Type}
        }
    )

in
    Grouped





=SUMIFS(
  tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)


=SUMIFS(
  tbl_Facility_Rollup[Sum of MOM_DELTA],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)

=-SUMIFS(
  tbl_Facility_Rollup[Sum of MOM_DELTA],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[MOVEMENT_TYPE], "Exit (ex-Auto)",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)






=IFERROR(
  SUMIFS(
    tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
    tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
  ),
  0
)


=IFERROR(
  SUMIFS(
    tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[MOVEMENT_TYPE], "Exit (ex-Auto)",
    tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
  ),
  0
)





BANK_FOR_EVENT
FACILITY_FOR_EVENT
MOVEMENT_TYPE
OWNER_FOR_EVENT
Sum of SSB_FOR_EVENT
Sum of MOM_DELTA
Max of REVIEWABLE_FLAG





=SUMIFS(
    tbl_Facility_Rollup[Reviewable_SSB],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[Movement_Type], "Downgrade IN (ex-Auto)"
)





=LET(
  owner, $B$2,
  mt, "Exit (ex-Auto)",
  facs, UNIQUE(FILTER(MoM_Account_Detail[FACILITY_ID],
        (MoM_Account_Detail[OWNER_FOR_EVENT]=owner)*
        (MoM_Account_Detail[Movement_Type]=mt)
  )),
  perFac, BYROW(facs, LAMBDA(f,
        SUMIFS(
          MoM_Account_Detail[CURR_SSB],
          MoM_Account_Detail[FACILITY_ID], f,
          MoM_Account_Detail[Is_Reviewable], 1
        )
  )),
  SUM(perFac)
)






=GETPIVOTDATA(
  "Total Reviewable SSB",
  Facility_Rollup!$A$3,
  "OWNER_FOR_EVENT", $B$2,
  "Movement_Type", "Downgrade IN (ex-Auto)"
)

=GETPIVOTDATA(
  "Total Reviewable SSB",
  Facility_Rollup!$A$3,
  "OWNER_FOR_EVENT", $B$2,
  "Movement_Type", "Exit (ex-Auto)"
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$59#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel, "")),

  facCol, CHOOSECOLS(d, IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), TAKE(d,0)),

  idxRaw, HSTACK(
    IFNA(XMATCH("PREV_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("PREV_CIS", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("PREV_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("PREV_BANK_CODE", hdr), 0),
    IFNA(XMATCH("PREV_CSS", hdr), 0),
    IFNA(XMATCH("PREV_GL_L4", hdr), 0),
    IFNA(XMATCH("PREV_PROD5", hdr), 0),
    IFNA(XMATCH("PREV_STATUS", hdr), 0),
    IFNA(XMATCH("PREV_RBC", hdr), 0),
    IFNA(XMATCH("PREV_SSB", hdr), 0),
    IFNA(XMATCH("PREV_GL_BALANCE", hdr), 0)
  ),
  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, CHOOSECOLS(rows, idx),

  ssbIdx, IFNA(XMATCH("PREV_SSB", hdr), 0),
  sortKey, IF(ssbIdx=0, 0, ABS(IFERROR(--CHOOSECOLS(rows, ssbIdx), 0))),

  IF(ROWS(rows)=0,
     "No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel, "")),

  facCol, CHOOSECOLS(d, IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), TAKE(d,0)),

  idxRaw, HSTACK(
    IFNA(XMATCH("CURR_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("CIS_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("CURR_BANK_CODE", hdr), 0),
    IFNA(XMATCH("CURR_CSS", hdr), 0),
    IFNA(XMATCH("CURR_GL_L4", hdr), 0),
    IFNA(XMATCH("CURR_PROD5", hdr), 0),
    IFNA(XMATCH("CURR_STATUS", hdr), 0),
    IFNA(XMATCH("CURR_RBC", hdr), 0),
    IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_GL_BALANCE", hdr), 0)
  ),
  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, CHOOSECOLS(rows, idx),

  ssbIdx, IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
  sortKey, IF(ssbIdx=0, 0, IFERROR(--CHOOSECOLS(rows, ssbIdx), 0)),

  IF(ROWS(rows)=0,
     "No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), ""),

  idxRaw, HSTACK(
    IFNA(XMATCH("CURR_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("CIS_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("CURR_BANK_CODE", hdr), 0),
    IFNA(XMATCH("CURR_CSS", hdr), 0),
    IFNA(XMATCH("CURR_GL_L4", hdr), 0),
    IFNA(XMATCH("CURR_PROD5", hdr), 0),
    IFNA(XMATCH("CURR_STATUS", hdr), 0),
    IFNA(XMATCH("CURR_RBC", hdr), 0),
    IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_GL_BALANCE", hdr), 0)
  ),

  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, IF(rows="","No matching account rows.", CHOOSECOLS(rows, idx)),

  sortKey, IF(rows="", 0, IFERROR(--CHOOSECOLS(rows, XMATCH("SSB_FOR_EVENT", hdr)), 0)),

  IF(rows="","No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)







=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), ""),

  idxRaw, HSTACK(
    XMATCH("CURR_ACCOUNT_NAME", hdr),
    XMATCH("CIS_FOR_EVENT", hdr),
    XMATCH("FACILITY_FOR_EVENT", hdr),
    XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr),
    XMATCH("ACCOUNT_KEY", hdr),
    XMATCH("CURR_BANK_CODE", hdr),
    XMATCH("CURR_CSS", hdr),
    XMATCH("CURR_GL_L4", hdr),
    XMATCH("CURR_PROD5", hdr),
    XMATCH("CURR_STATUS", hdr),
    XMATCH("CURR_RBC", hdr),
    XMATCH("SSB_FOR_EVENT", hdr),
    XMATCH("CURR_GL_BALANCE", hdr)
  ),
  idx, FILTER(idxRaw, ISNUMBER(idxRaw)),

  out, IF(rows="","No matching account rows.", CHOOSECOLS(rows, idx)),

  ssbCol, IFERROR(CHOOSECOLS(rows, XMATCH("SSB_FOR_EVENT", hdr)), 0),

  IF(rows="","No matching account rows.",
     SORTBY(out, ssbCol, -1)
  )
)





=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],

  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  keep, ISNUMBER(MATCH(facCol, facs, 0)),

  rows, IFERROR(FILTER(d, keep), ""),

  out, CHOOSECOLS(
        rows,
        XMATCH("CURR_ACCOUNT_NAME", hdr),
        XMATCH("CIS_FOR_EVENT", hdr),
        XMATCH("FACILITY_FOR_EVENT", hdr),
        XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr),
        XMATCH("ACCOUNT_KEY", hdr),
        XMATCH("CURR_BANK_CODE", hdr),
        XMATCH("CURR_CSS", hdr),
        XMATCH("CURR_GL_L4", hdr),
        XMATCH("CURR_PROD5", hdr),
        XMATCH("CURR_STATUS", hdr),
        XMATCH("CURR_RBC", hdr),
        XMATCH("SSB_FOR_EVENT", hdr),
        XMATCH("CURR_GL_BALANCE", hdr)
      ),

  IF(rows="","No matching account rows.",
     SORTBY(out, CHOOSECOLS(out,12), -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$8#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  rows, IFERROR(
          FILTER(d,
            (d[OWNER_FOR_EVENT]=ownerSel)*
            (d[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)")*
            ISNUMBER(MATCH(d[FACILITY_FOR_EVENT], facs, 0))
          ),
          ""
        ),

  out, CHOOSECOLS(
        rows,
        XMATCH("CURR_ACCOUNT_NAME", d[#Headers]),
        XMATCH("CIS_FOR_EVENT", d[#Headers]),
        XMATCH("FACILITY_FOR_EVENT", d[#Headers]),
        XMATCH("CURR_ACCOUNT_IDENTIFIER", d[#Headers]),
        XMATCH("ACCOUNT_KEY", d[#Headers]),
        XMATCH("CURR_BANK_CODE", d[#Headers]),
        XMATCH("CURR_CSS", d[#Headers]),
        XMATCH("CURR_GL_L4", d[#Headers]),
        XMATCH("CURR_PROD5", d[#Headers]),
        XMATCH("CURR_STATUS", d[#Headers]),
        XMATCH("CURR_RBC", d[#Headers]),
        XMATCH("SSB_FOR_EVENT", d[#Headers]),
        XMATCH("CURR_GL_BALANCE", d[#Headers])
      ),

  IF(rows="","No matching account rows.",
     SORTBY(out, CHOOSECOLS(out,12), -1)
  )
)














MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]


      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE],




ACCOUNT_NAME
CIS_CUSTOMER_NUMBER
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
BANK_CODE
CONTRACT_SOURCE_SYSTEM
GL_ACCOUNT_HIER_LEVEL_4
PROD_HIER_LEVEL_5
STATUS_CODE
RBC_CODE
 SOURCE_SYSTEM_BALANCE 
 GL_BALANCE





=LET(
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$8#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  out, FILTER(
        d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]="Downgrade IN (ex-Auto)")*
        ISNUMBER(MATCH(d[Facility_For_Event], facs, 0))
  ),
  SORTBY(out, out[SSB_For_Event], -1)
)



=LET(
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$60#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  out, FILTER(
        d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]="Exit (ex-Auto)")*
        ISNUMBER(MATCH(d[Facility_For_Event], facs, 0))
  ),
  SORTBY(out, ABS(out[MoM_Delta]), -1)
)







=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Exit (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       FILTER(t, keep),
  f_delta, FILTER(delta, keep),

  sorted, SORTBY(f, ABS(IFERROR(--f_delta,0)), -1),
  n, MIN(30, ROWS(sorted)),

  TAKE(sorted, n)
)






=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,     FILTER(t, keep),
  f_ssb, FILTER(ssb, keep),

  sorted, SORTBY(f, IFERROR(--f_ssb,0), -1),
  n, MIN(30, ROWS(sorted)),

  TAKE(sorted, n)
)





=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  sortKey, IFERROR(--f_ssb,0),

  IF(f="",
     "No matches for this owner + movement type.",
     TAKE(SORTBY(f, sortKey, -1), 30)
  )
)





=LET(
  top, Top30_Engine!A8#,
  ownerSel, $B$2,
  ownerCol, 4,
  facCol, 2,
  facs, FILTER(CHOOSECOLS(top, facCol), CHOOSECOLS(top, ownerCol)=ownerSel),
  UNIQUE(facs)
)






=LET(
  top, A8#,
  facList, DROP(CHOOSECOLS(top,2),1),
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",
  out, FILTER(d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]=mvSel)*
        ISNUMBER(MATCH(d[Facility_For_Event], facList, 0))
  ),
  SORTBY(out, out[SSB_For_Event], -1)
)






=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  sortKey,
    IF(TRIM(mvSel)="Exit (ex-Auto)",
       ABS(IFERROR(--f_delta,0)),
       IFERROR(--f_ssb,0)
    ),

  IF(f="",
     "No matches for the selected Owner/Movement_Type (or Reviewable <> 1).",
     TAKE(SORTBY(f, sortKey, -1), 30)
  )
)







=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  bank,  CHOOSECOLS(t, XMATCH("BANK_FOR_EVENT", hdr)),
  fac,   CHOOSECOLS(t, XMATCH("FACILITY_FOR_EVENT", hdr)),
  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  rankMetric,
    IF(TRIM(mvSel)="Exit (ex-Auto)",
       ABS(IFERROR(--f_delta,0)),
       IFERROR(--f_ssb,0)
    ),

  IF(f="",
     "No matches for the selected Owner/Movement_Type (or Reviewable <> 1).",
     TAKE(SORTBY(HSTACK(f, rankMetric), rankMetric, -1), 30)
  )
)






rankMetric,
IF(
  TRIM(mvSel)="Exit (ex-Auto)",
  ABS(IFERROR(--f_delta,0)),
  IFERROR(--f_ssb,0)
),





=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  bank,  CHOOSECOLS(t, XMATCH("Bank_For_Event", hdr)),
  fac,   CHOOSECOLS(t, XMATCH("Facility_For_Event", hdr)),
  own,   CHOOSECOLS(t, XMATCH("Owner_For_Event", hdr)),
  mv,    CHOOSECOLS(t, XMATCH("Movement_Type", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Reviewable_Flag", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("SSB_For_Event", hdr)),
  delta, CHOOSECOLS(t, XMATCH("MoM_Delta", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f, IFERROR(FILTER(t, keep), ""),
  f_ssb, IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  rankMetric, IF(mvSel="Exit (ex-Auto)", ABS(f_delta), f_ssb),

  IF(f="","No matches for the selected Owner/Movement_Type (or Reviewable_Flag not = 1).",
     TAKE(SORTBY(HSTACK(f, rankMetric), rankMetric, -1), 30)
  )
)






=LET(
  t, tbl_Facility_Rollup,
  bank, CHOOSECOLS(t,1),
  fac,  CHOOSECOLS(t,2),
  own,  CHOOSECOLS(t,3),
  mv,   CHOOSECOLS(t,4),
  rev,  CHOOSECOLS(t,5),
  ssb,  CHOOSECOLS(t,6),
  delta,CHOOSECOLS(t,7),

  ownerSel, $B$2,
  mvSel, $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),
  f, FILTER(t, keep),

  f_ssb,  FILTER(ssb, keep),
  f_delta,FILTER(delta, keep),

  rankMetric, IF(mvSel="Exit (ex-Auto)", ABS(f_delta), f_ssb),
  sorted, SORTBY(f, rankMetric, -1),
  TAKE(HSTACK(sorted, rankMetric), 30)
)





=LET(
  t, tbl_Facility_Rollup,
  owner, $B$2,
  mv, $B$3,
  f, FILTER(t, (t[Owner_For_Event]=owner)*(t[Movement_Type]=mv)*(t[Reviewable_Flag]>=1)),
  rankMetric, IF(mv="Exit (ex-Auto)", ABS(INDEX(f[MoM_Delta],0)), INDEX(f[SSB_For_Event],0)),
  sorted, SORTBY(f, rankMetric, -1),
  TAKE(HSTACK(sorted, rankMetric), 30)
)







/* ================================== Query 1: MoM_Account_Detail (incl. negatives, charge-offs, status)
   UPDATED:
   - Movement_Type classified at FACILITY level (stamped onto all Account_Key rows)
   - Reviewable_Flag classified at FACILITY level (stamped onto all Account_Key rows)
   - Facility Owner logic with deterministic pick (largest |SSB_For_Event| account), with hard override:
       Daniel gets EVERYTHING where Contract_Source_System = 'INFL10'
   - Presence tests use SUM(ABS(SSB)) to avoid net-to-zero masking
   - Reviewable exposure tests use SUM(positive SSB) as discussed
   Grain of final output remains ACCOUNT_KEY
======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags (account-level) */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags (account-level) */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Posâ†’Neg Flip'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Negâ†’Pos Flip'
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Î”'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Î”'
      ELSE NULL
    END AS Negative_Class

  FROM joined j
),

/* CIS totals (account-level window, as-is) */
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
),

/* Event-scoped fields (same logic you had in final SELECT, moved earlier so we can roll up at facility level) */
event_scoped AS (
  SELECT
    w.*,

    /* Account_Name for the â€œeventâ€ side (curr if exists, else prev) */
    CASE
      WHEN w.has_curr=1 THEN w.Curr_Account_Name
      WHEN w.had_prev=1 THEN w.Prev_Account_Name
      ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
    END AS Account_Name_For_Event,

    /* event scoping */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
      WHEN w.has_curr=1 THEN w.Curr_Bank_Code
      ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
    END AS Bank_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
      WHEN w.has_curr=1 THEN w.Curr_Facility_ID
      ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
    END AS Facility_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
      WHEN w.has_curr=1 THEN w.Curr_CIS
      ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
    END AS CIS_For_Event,

    /* choose event-side CSS/PROD/BANK/RBC for downstream owner logic */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CSS
      WHEN w.has_curr=1 THEN w.Curr_CSS
      ELSE COALESCE(w.Curr_CSS, w.Prev_CSS)
    END AS CSS_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_PROD5
      WHEN w.has_curr=1 THEN w.Curr_PROD5
      ELSE COALESCE(w.Curr_PROD5, w.Prev_PROD5)
    END AS PROD5_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_RBC
      WHEN w.has_curr=1 THEN w.Curr_RBC
      ELSE COALESCE(w.Curr_RBC, w.Prev_RBC)
    END AS RBC_For_Event,

    /* balances */
    (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,

    CASE
      WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
      ELSE COALESCE(w.Prev_SSB,0)
    END AS SSB_For_Event
  FROM with_cis w
),

/* Account-level owner (event-side) with Daniel override moved to the top */
account_owner_event AS (
  SELECT
    e.*,

    CASE
      WHEN e.CSS_For_Event = 'INFL10' THEN 'Daniel'  /* HARD OVERRIDE */
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
      WHEN e.Bank_For_Event='L-SVB' THEN 'Eleanor'
      WHEN UPPER(COALESCE(e.RBC_For_Event,''))='R' THEN 'Autochange'
      WHEN e.Bank_For_Event='L-FCB' THEN 'Connor'
      ELSE 'NOT COVERED'
    END AS Owner_Account_For_Event
  FROM event_scoped e
),

/* Rank accounts within facility to pick representative attributes (largest |SSB_For_Event|) */
ranked_in_facility AS (
  SELECT
    a.*,
    ROW_NUMBER() OVER (
      PARTITION BY a.Bank_For_Event, a.Facility_For_Event
      ORDER BY ABS(COALESCE(a.SSB_For_Event,0)) DESC, a.Account_Key
    ) AS rn_fac
  FROM account_owner_event a
),

/* Facility rollup + facility-level classification + facility owner */
facility_rollup AS (
  SELECT
    Bank_For_Event,
    Facility_For_Event,

    /* Presence tests (avoid net-to-zero masking) */
    SUM(ABS(COALESCE(Prev_SSB,0))) AS Fac_Prev_Abs_SSB,
    SUM(ABS(COALESCE(Curr_SSB,0))) AS Fac_Curr_Abs_SSB,

    /* Positive exposure tests (reviewable gating) */
    SUM(CASE WHEN COALESCE(Prev_SSB,0) > 0 THEN COALESCE(Prev_SSB,0) ELSE 0 END) AS Fac_Prev_Pos_SSB,
    SUM(CASE WHEN COALESCE(Curr_SSB,0) > 0 THEN COALESCE(Curr_SSB,0) ELSE 0 END) AS Fac_Curr_Pos_SSB,

    /* Net balances for delta-based â€œpersisting changeâ€ */
    SUM(COALESCE(Prev_SSB,0)) AS Fac_Prev_Net_SSB,
    SUM(COALESCE(Curr_SSB,0)) AS Fac_Curr_Net_SSB,

    /* Facility-level auto flags: ANY auto within facility */
    MAX(CASE WHEN UPPER(COALESCE(Prev_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Prev_Auto_Any,
    MAX(CASE WHEN UPPER(COALESCE(Curr_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Curr_Auto_Any,

    /* Daniel override: ANY INFL10 in facility => Daniel */
    MAX(CASE WHEN CSS_For_Event='INFL10' THEN 1 ELSE 0 END) AS Fac_INFL10_Any,

    /* Representative attributes from top |SSB_For_Event| row */
    MAX(CASE WHEN rn_fac=1 THEN CIS_For_Event END)         AS Fac_CIS_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN PROD5_For_Event END)       AS Fac_PROD5_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN RBC_For_Event END)         AS Fac_RBC_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN Owner_Account_For_Event END) AS Fac_Owner_From_TopRow,

    /* Representative CIS totals from top row (used in threshold exclusions) */
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Curr_CIS_SSB,0) END) AS Fac_Curr_CIS_SSB,
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Prev_CIS_SSB,0) END) AS Fac_Prev_CIS_SSB

  FROM ranked_in_facility
  GROUP BY Bank_For_Event, Facility_For_Event
),

facility_classified AS (
  SELECT
    fr.*,

    /* facility presence flags */
    CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Had_Prev,
    CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Has_Curr,

    /* facility owner for event */
    CASE
      WHEN fr.Fac_INFL10_Any = 1 THEN 'Daniel'
      ELSE COALESCE(fr.Fac_Owner_From_TopRow, 'NOT COVERED')
    END AS Owner_Facility_For_Event,

    /* FACILITY-level Movement_Type */
    CASE
      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
        THEN 'Autochange Downgrade IN'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
        THEN 'Autochange Exit'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange Persisting Balance Changes'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange No Change'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
        THEN 'Downgrade IN (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
        THEN 'Exit (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Persisting Balance Changes (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'No Change (ex-Auto)'

      ELSE NULL
    END AS Movement_Type_Facility,

    /* FACILITY-level Reviewable_Flag (stamped down) */
    CASE
      WHEN (
        /* only these two types are review-queued */
        (CASE
           WHEN (
             CASE
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
               THEN 'Downgrade IN (ex-Auto)'
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
               THEN 'Exit (ex-Auto)'
               ELSE NULL
             END
           ) IS NOT NULL THEN 1 ELSE 0
         END)=1

        AND (
          /* positive exposure must exist on relevant side */
          ( ( /* Downgrade IN */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Curr_Pos_SSB,0) > 0
            )
            OR
            ( /* Exit */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Prev_Pos_SSB,0) > 0
            )
          )
        )

        AND (
          /* exclusions (mirror your prior logic, applied at facility rep-level) */
          CASE
            /* Downgrade IN exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END

            /* Exit exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END
            ELSE 0
          END = 1
        )
      )
      THEN 1 ELSE 0
    END AS Reviewable_Flag_Facility

  FROM facility_rollup fr
)

/* =========================
   FINAL OUTPUT (ACCOUNT_KEY grain)
   - Movement_Type now = facility-level Movement_Type_Facility
   - Owner_For_Event now = facility-level Owner_Facility_For_Event
   - Reviewable_Flag now = facility-level Reviewable_Flag_Facility
   - Owner_Curr / Owner_Prev also updated so Daniel override is absolute
========================= */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  a.Account_Key,

  /* prev attributes */
  a.Prev_Account_Identifier,
  a.Prev_Facility_ID,
  a.Prev_CIS,
  a.Prev_Account_Name,
  a.Prev_CSS,
  a.Prev_PROD5,
  a.Prev_RBC,
  a.Prev_Status,
  a.Prev_GL_L4,
  a.Prev_Bank_Code,
  a.Prev_SSB,
  a.Prev_GL_Balance,
  a.Prev_CO_MTD,

  /* curr attributes */
  a.Curr_Account_Identifier,
  a.Curr_Facility_ID,
  a.Curr_CIS,
  a.Curr_Account_Name,
  a.Curr_CSS,
  a.Curr_PROD5,
  a.Curr_RBC,
  a.Curr_Status,
  a.Curr_GL_L4,
  a.Curr_Bank_Code,
  a.Curr_SSB,
  a.Curr_GL_Balance,
  a.Curr_CO_MTD,

  /* event-side display fields */
  a.Account_Name_For_Event,
  a.Bank_For_Event,
  a.Facility_For_Event,
  a.CIS_For_Event,

  /* balances */
  a.MoM_Delta,
  a.SSB_For_Event,

  /* FACILITY movement typing */
  fc.Movement_Type_Facility AS Movement_Type,

  /* Owners (Curr / Prev) with Daniel override absolute */
  CASE
    WHEN a.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Curr_RBC='R' THEN 'Autochange'
    WHEN a.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN a.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Prev_RBC='R' THEN 'Autochange'
    WHEN a.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* FACILITY owner for event */
  fc.Owner_Facility_For_Event AS Owner_For_Event,

  /* FACILITY reviewable flag */
  fc.Reviewable_Flag_Facility AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  a.Curr_CIS_SSB,
  a.Prev_CIS_SSB,
  a.Negative_Flag,
  a.Negative_Class,
  a.Negative_Flip_Flag

FROM ranked_in_facility a
JOIN facility_classified fc
  ON a.Bank_For_Event = fc.Bank_For_Event
 AND a.Facility_For_Event = fc.Facility_For_Event

/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(a.Prev_SSB,0) = 0 AND COALESCE(a.Curr_SSB,0) = 0)

ORDER BY a.Bank_For_Event, a.Facility_For_Event, a.Account_Key;








Below is my full query for the RC_Code analysis. I was wanting to run the model on one single RC_Code. Can you give me a version that only outputs the analysis for 1 single RC_Code that I will manually input? 

/* ========== RC_Code Anomaly Detection â€” REG12-only, Thresholded, PBI-safe ========== */
/* Key features:
   - Uses only 12-month regression per RC (no REG36, MA6, MA12, no seasonality)
   - Limits history (min_me) to control runtime
   - Applies exposure_min_for_model on latest balance
   - Adds TOTAL_PORTFOLIO pseudo-RC
   - Outputs PI bands, Severity_0_100, Persistent_Outlier_3of6, Reason_Code
   - Flags Is_Material_Residual_500M for |Residual| >= threshold
*/

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,            -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,   -- >= $1B latest
    500000000.0::FLOAT8                AS material_resid_threshold  -- >= $500M residual
),

/* 1) Base RC-level balances (time filtered) */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b,
       params p
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Portfolio total per month as pseudo-RC */
base_total AS (
  SELECT
    'TOTAL_PORTFOLIO'               AS RC_CODE,
    'Total Loans - Portfolio'       AS RC_DESCRIPTION,
    month_end,
    SUM(bal_num)::FLOAT8            AS bal_num
  FROM base_rc
  GROUP BY month_end
),

/* 3) Combine RC-level + portfolio-level */
base_all AS (
  SELECT * FROM base_rc
  UNION ALL
  SELECT * FROM base_total
),

/* 4) Latest month & latest exposure per RC */
latest_me AS (
  SELECT
    RC_CODE,
    MAX(month_end) AS max_me
  FROM base_all
  GROUP BY RC_CODE
),

latest_exp AS (
  SELECT
    b.RC_CODE,
    b.bal_num AS latest_bal
  FROM base_all b
  JOIN latest_me m
    ON m.RC_CODE = b.RC_CODE
   AND m.max_me  = b.month_end
),

/* 5) RCs that pass exposure threshold */
material_rc AS (
  SELECT
    e.RC_CODE
  FROM latest_exp e
  CROSS JOIN params p
  WHERE e.latest_bal >= p.exposure_min_for_model
),

/* 6) Filter base to material RCs + portfolio */
base AS (
  SELECT b.*
  FROM base_all b
  WHERE b.RC_CODE IN (SELECT RC_CODE FROM material_rc)
),

/* 7) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 8) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 9) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 10) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 11) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 12) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    -- residual distribution stats
    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    -- MoM distribution stats
    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    -- RMSE per RC (for PI bands)
    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 13) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 14) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),


print(" - GL_balances_prior_matrix.csv")
