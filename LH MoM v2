let
    Source = pq_Facility_Rollup_All,

    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"}
    ),

    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"BANK_EVENT", type text},
            {"FACILITY_EVENT", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // Keep reviewable only for review tables / top30 ranking
    ReviewableOnly = Table.SelectRows(Types, each [REVIEWABLE_FLAG_MAX] = 1),

    AddAbs = Table.AddColumn(ReviewableOnly, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),

    // Sort for ranking within month-end
    SortForRank = Table.Sort(AddAbs, {{"ME_DATE", Order.Ascending}, {"BAL_CHANGE_ABS", Order.Descending}}),

    // Rank by month-end
    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "MONTH_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(t2, "TOP30_FLAG", each if [MONTH_RANK] <= 30 then "Y" else "N", type text)
                    in
                        t3
                , type table}
            }
        ),

    Expanded = Table.ExpandTableColumn(
        Grouped,
        "Data",
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"},
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"}
    ),

    Rename = Table.RenameColumns(Expanded, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddRunTs = Table.AddColumn(Rename, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = pq_Facility_Rollup_All,

    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE","FACILITY_EVENT","PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"}
    ),

    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"FACILITY_EVENT", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // Dedupe: 1 row per facility per month-end
    // Use MAX to avoid double-counting if the facility appears multiple times
    FacilityDedup =
        Table.Group(
            Types,
            {"ME_DATE","FACILITY_EVENT"},
            {
                {"PREV_SSB_FAC", each List.Max([PREV_SSB_SUM]), type number},
                {"CURR_SSB_FAC", each List.Max([CURR_SSB_SUM]), type number},
                {"MOM_DELTA_FAC", each List.Max([MOM_DELTA_SUM]), type number},
                {"REVIEWABLE_FLAG_MAX", each List.Max([REVIEWABLE_FLAG_MAX]), Int64.Type}
            }
        ),

    Rename = Table.RenameColumns(FacilityDedup, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddAbs = Table.AddColumn(Rename, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_FAC]), type number),
    AddRunTs = Table.AddColumn(AddAbs, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = Excel.CurrentWorkbook(){[Name="tbl_Neg_NA"]}[Content],

    Types = Table.TransformColumnTypes(
        Source,
        {
            {"END_OF_MONTH_DATE", type date},
            {"CIS_CUSTOMER_NUMBER", type text},
            {"ACCOUNT_KEY", type text},
            {"ACCOUNT_IDENTIFIER", type text},
            {"FACILITY_ID", type text},
            {"ACCOUNT_NAME", type text},
            {"CONTRACT_SOURCE_SYSTEM", type text},
            {"PROD_HIER_LEVEL_5", type text},
            {"RBC_CODE", type text},
            {"STATUS_CODE_DESCRIPTION", type text},
            {"GL_ACCOUNT_HIER_LEVEL_4", type text},
            {"GL_ACCOUNT_CODE", type text},
            {"NON_ACCRUAL_FLAG", type text},
            {"SSB", type number},
            {"CO_MTD", type number},
            {"IS_NA", Int64.Type},
            {"IS_NEGATIVE_SSB", Int64.Type},
            {"CIS_NEG_NA_SSB", type number}
        }
    ),

    Renamed = Table.RenameColumns(Types, {{"END_OF_MONTH_DATE", "CURR_EOM_DATE"}}),

    KeepCols = Table.SelectColumns(
        Renamed,
        {
            "CURR_EOM_DATE",
            "CIS_CUSTOMER_NUMBER",
            "FACILITY_ID",
            "ACCOUNT_KEY",
            "ACCOUNT_IDENTIFIER",
            "ACCOUNT_NAME",
            "CONTRACT_SOURCE_SYSTEM",
            "PROD_HIER_LEVEL_5",
            "RBC_CODE",
            "STATUS_CODE_DESCRIPTION",
            "GL_ACCOUNT_HIER_LEVEL_4",
            "GL_ACCOUNT_CODE",
            "NON_ACCRUAL_FLAG",
            "SSB",
            "CO_MTD",
            "IS_NA",
            "IS_NEGATIVE_SSB",
            "CIS_NEG_NA_SSB"
        }
    ),

    AddRunTs = Table.AddColumn(KeepCols, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs






let
    Source = Excel.CurrentWorkbook(){[Name="tbl_Chargeoff"]}[Content],

    // Types (force IDs to text)
    Types = Table.TransformColumnTypes(
        Source,
        {
            {"QUERY_RUN_TIMESTAMP", type datetime},
            {"END_OF_MONTH_DATE", type date},
            {"CIS_CUSTOMER_NUMBER", type text},
            {"ACCOUNT_NAME", type text},
            {"CONTRACT_SOURCE_SYSTEM", type text},
            {"FACILITY_ID", type text},
            {"ACCOUNT_IDENTIFIER", type text},
            {"ACCOUNT_KEY", type text},
            {"CHARGE_OFF_AMOUNT_MTD", type number},
            {"BANK_CODE", type text}
        }
    ),

    // Rename to stable PBI feed contract
    Renamed = Table.RenameColumns(
        Types,
        {
            {"END_OF_MONTH_DATE", "CURR_EOM_DATE"},
            {"CHARGE_OFF_AMOUNT_MTD", "CHARGEOFF_MTD_AMT"}
        }
    ),

    // Keep only what we need
    KeepCols = Table.SelectColumns(
        Renamed,
        {
            "CURR_EOM_DATE",
            "QUERY_RUN_TIMESTAMP",
            "BANK_CODE",
            "CONTRACT_SOURCE_SYSTEM",
            "FACILITY_ID",
            "ACCOUNT_KEY",
            "ACCOUNT_IDENTIFIER",
            "ACCOUNT_NAME",
            "CIS_CUSTOMER_NUMBER",
            "CHARGEOFF_MTD_AMT"
        }
    ),

    // Add refresh timestamp (optional; you already have QUERY_RUN_TIMESTAMP)
    AddRunTs = Table.AddColumn(KeepCols, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





QUERY_RUN_TIMESTAMP
END_OF_MONTH_DATE
CIS_CUSTOMER_NUMBER
ACCOUNT_NAME
CONTRACT_SOURCE_SYSTEM
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
CHARGE_OFF_AMOUNT_MTD
BANK_CODE

END_OF_MONTH_DATE
CIS_CUSTOMER_NUMBER
ACCOUNT_KEY
ACCOUNT_IDENTIFIER
FACILITY_ID
ACCOUNT_NAME
CONTRACT_SOURCE_SYSTEM
PROD_HIER_LEVEL_5
RBC_CODE
STATUS_CODE_DESCRIPTION
GL_ACCOUNT_HIER_LEVEL_4
GL_ACCOUNT_CODE
NON_ACCRUAL_FLAG
SSB
CO_MTD
IS_NA
IS_NEGATIVE_SSB
CIS_CLUSTER_SSB
CIS_CLUSTER_CO_MTD
CIS_NEG_NA_SSB






let
    Source = pq_Facility_Rollup_All,

    Types = Table.TransformColumnTypes(
        Source,
        {
            {"ME_DATE", type date},
            {"MOVEMENT_TYPE", type text},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    Reviewable = Table.SelectRows(Types, each [REVIEWABLE_FLAG_MAX] = 1),

    Grouped = Table.Group(
        Reviewable,
        {"ME_DATE"},
        {
            {"REVIEWABLE_TOTAL_DELTA", each List.Sum([MOM_DELTA_SUM]), type number},
            {"EXIT_EX_AUTO_DELTA", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Exit (ex-Auto)")[MOM_DELTA_SUM]), type number},
            {"DOWNGRADE_IN_EX_AUTO_DELTA", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)")[MOM_DELTA_SUM]), type number}
        }
    ),

    AddOther = Table.AddColumn(
        Grouped,
        "OTHER_REVIEWABLE_DELTA",
        each [REVIEWABLE_TOTAL_DELTA] - ([EXIT_EX_AUTO_DELTA] + [DOWNGRADE_IN_EX_AUTO_DELTA]),
        type number
    ),

    Rename = Table.RenameColumns(Grouped, {{"ME_DATE","CURR_EOM_DATE"}}),
    AddRunTs = Table.AddColumn(AddOther, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content],

    // --- EDIT THESE 4 NAMES TO MATCH YOUR TABLE ---
    Types = Table.TransformColumnTypes(
        Source,
        {
            {"CURR_EOM", type date},
            {"PREV_EOM", type date},
            {"CURR_SSB", type number},
            {"PREV_SSB", type number}
        }
    ),

    // Deduplicate at account_key if needed (prevents double counting)
    // If each row is already unique per ACCOUNT_KEY, this still works.
    Dedup = Table.Group(
        Types,
        {"CURR_EOM","PREV_EOM","ACCOUNT_KEY"},
        {
            {"CURR_SSB_ACCT", each List.Max([CURR_SSB]), type number},
            {"PREV_SSB_ACCT", each List.Max([PREV_SSB]), type number}
        }
    ),

    OneRow = Table.Group(
        Dedup,
        {"CURR_EOM","PREV_EOM"},
        {
            {"PORTFOLIO_CURR_NA_BAL", each List.Sum([CURR_SSB_ACCT]), type number},
            {"PORTFOLIO_PREV_NA_BAL", each List.Sum([PREV_SSB_ACCT]), type number}
        }
    ),

    AddDelta = Table.AddColumn(OneRow, "PORTFOLIO_MOM_DELTA", each [PORTFOLIO_CURR_NA_BAL] - [PORTFOLIO_PREV_NA_BAL], type number),

    Rename = Table.RenameColumns(AddDelta, {{"CURR_EOM","CURR_EOM_DATE"},{"PREV_EOM","PREV_EOM_DATE"}}),

    AddRunTs = Table.AddColumn(Rename, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = PBI_Feed_FacilityReview_Current,

    // One row per CURR_EOM_DATE (you currently only have 1 date anyway, but this is robust)
    Grouped = Table.Group(
        Source,
        {"CURR_EOM_DATE"},
        {
            {"TOTAL_CURR_SSB_SUM", each List.Sum([CURR_SSB_SUM]), type number},
            {"TOTAL_PREV_SSB_SUM", each List.Sum([PREV_SSB_SUM]), type number},
            {"TOTAL_MOM_DELTA_SUM", each List.Sum([MOM_DELTA_SUM]), type number},
            {"REVIEWABLE_FACILITY_COUNT", each Table.RowCount(_), Int64.Type},

            // Movement buckets (edit these strings ONLY if your MOVEMENT_TYPE labels differ)
            {"EXIT_EX_AUTO_DELTA", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Exit (ex-Auto)")[MOM_DELTA_SUM]), type number},
            {"DOWNGRADE_IN_EX_AUTO_DELTA", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)")[MOM_DELTA_SUM]), type number}
        }
    ),

    AddOther = Table.AddColumn(
        Grouped,
        "OTHER_NET_DELTA",
        each [TOTAL_MOM_DELTA_SUM] - ([EXIT_EX_AUTO_DELTA] + [DOWNGRADE_IN_EX_AUTO_DELTA]),
        type number
    ),

    // Add PREV_EOM_DATE if you want it shown in the executive subtitle:
    // Since it is not in your rollup, we set it as null for now.
    // If you have a reliable place to pull PREV_EOM_DATE (e.g., a parameter table), we can wire it in.
    AddPrevDate = Table.AddColumn(AddOther, "PREV_EOM_DATE", each null, type date),

    AddRunTs = Table.AddColumn(AddPrevDate, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = pq_Facility_Rollup_All,

    // Keep only known columns (stable feed contract)
    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"}
    ),

    // Type enforcement (FACILITY_EVENT as text is important)
    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"BANK_EVENT", type text},
            {"FACILITY_EVENT", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // Keep reviewable only (recommended for exec feed)
    ReviewableOnly = Table.SelectRows(Types, each [REVIEWABLE_FLAG_MAX] = 1),

    // Add abs change for ranking / sorting
    AddAbs = Table.AddColumn(ReviewableOnly, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),

    // Rank Top30 within the month-end by BAL_CHANGE_ABS
    SortForRank = Table.Sort(AddAbs, {{"ME_DATE", Order.Ascending}, {"BAL_CHANGE_ABS", Order.Descending}}),

    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "MONTH_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(t2, "TOP30_FLAG", each if [MONTH_RANK] <= 30 then "Y" else "N", type text)
                    in
                        t3
                , type table}
            }
        ),

    Expanded = Table.ExpandTableColumn(
        Grouped,
        "Data",
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"},
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"}
    ),

    // Rename ME_DATE -> CURR_EOM_DATE to make "snapshot" explicit
    RenameCols = Table.RenameColumns(Expanded, {{"ME_DATE", "CURR_EOM_DATE"}}),

    // Refresh timestamp
    AddRunTs = Table.AddColumn(RenameCols, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs






let
    Source = PBI_Feed_FacilityReview,

    Grouped = Table.Group(
        Source,
        {"ME_DATE"},
        {
            {"TOTAL_NON_ACCRUAL_BAL", each List.Sum([CURR_SSB_SUM]), type number},
            {"TOTAL_NON_ACCRUAL_BAL_PRIOR", each List.Sum([PREV_SSB_SUM]), type number},
            {"MOM_CHANGE_BAL", each List.Sum([MOM_DELTA_SUM]), type number},
            {"REVIEWABLE_FACILITY_COUNT", each Table.RowCount(_), Int64.Type},

            // Movement buckets (edit strings if your MOVEMENT_TYPE labels differ)
            {"EXIT_EX_AUTO_BAL", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Exit (ex-Auto)")[MOM_DELTA_SUM]), type number},
            {"DOWNGRADE_IN_EX_AUTO_BAL", each List.Sum(Table.SelectRows(_, each [MOVEMENT_TYPE] = "Downgrade IN (ex-Auto)")[MOM_DELTA_SUM]), type number}
        }
    ),

    AddOther = Table.AddColumn(
        Grouped,
        "OTHER_NET_MOVEMENT_BAL",
        each [MOM_CHANGE_BAL] - ([EXIT_EX_AUTO_BAL] + [DOWNGRADE_IN_EX_AUTO_BAL]),
        type number
    ),

    AddRunTs = Table.AddColumn(AddOther, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs





let
    Source = pq_Facility_Rollup_All,

    // Keep only available columns
    KeepCols = Table.SelectColumns(
        Source,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","REVIEWABLE_FLAG_MAX"}
    ),

    // Types (treat FACILITY_EVENT as text to preserve formatting)
    Types = Table.TransformColumnTypes(
        KeepCols,
        {
            {"ME_DATE", type date},
            {"BANK_EVENT", type text},
            {"FACILITY_EVENT", type text},
            {"OWNER_EVENT", type text},
            {"MOVEMENT_TYPE", type text},
            {"PREV_SSB_SUM", type number},
            {"CURR_SSB_SUM", type number},
            {"MOM_DELTA_SUM", type number},
            {"REVIEWABLE_FLAG_MAX", Int64.Type}
        }
    ),

    // Filter to reviewable rows (recommended for the exec dataset)
    ReviewableOnly = Table.SelectRows(Types, each [REVIEWABLE_FLAG_MAX] = 1),

    // Add absolute change for ranking
    AddAbs = Table.AddColumn(ReviewableOnly, "BAL_CHANGE_ABS", each Number.Abs([MOM_DELTA_SUM]), type number),

    // Rank TOP30 per month-end by BAL_CHANGE_ABS
    SortForRank = Table.Sort(AddAbs, {{"ME_DATE", Order.Ascending}, {"BAL_CHANGE_ABS", Order.Descending}}),

    Grouped =
        Table.Group(
            SortForRank,
            {"ME_DATE"},
            {
                {"Data", (t) =>
                    let
                        t2 = Table.AddIndexColumn(t, "MONTH_RANK", 1, 1, Int64.Type),
                        t3 = Table.AddColumn(t2, "TOP30_FLAG", each if [MONTH_RANK] <= 30 then "Y" else "N", type text)
                    in
                        t3
                , type table}
            }
        ),

    Expanded = Table.ExpandTableColumn(
        Grouped,
        "Data",
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"},
        {"BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE","REVIEWABLE_FLAG_MAX",
         "PREV_SSB_SUM","CURR_SSB_SUM","MOM_DELTA_SUM","BAL_CHANGE_ABS","MONTH_RANK","TOP30_FLAG"}
    ),

    // Add refresh timestamp
    AddRunTs = Table.AddColumn(Expanded, "RUN_TIMESTAMP", each DateTime.LocalNow(), type datetime)

in
    AddRunTs







ME_DATE
BANK_EVENT
FACILITY_EVENT
OWNER_EVENT
MOVEMENT_TYPE
PREV_SSB_SUM
CURR_SSB_SUM
MOM_DELTA_SUM
REVIEWABLE_FLAG_MAX







Process & Methodology

EXECUTIVE SUMMARY (READ THIS FIRST)

WHAT THIS FILE PRODUCES
This workbook delivers a controlled, reconcilable view of the Non-Accrual (NA) portfolio, including:
• A portfolio-level bridge explaining month-over-month NA balance change
• Top30 facility review lists for material Downgrades IN and Exits
• Owner-specific drilldowns to support targeted review and accountability

WHY THE OUTPUTS CAN BE TRUSTED
• Single source of truth: All results originate from one SQL extract (MoM_Account_Detail)
• Deterministic pipeline: SQL → Excel table → Power Query rollups → Excel formulas
• No manual manipulation: One-button refresh minimizes human error
• Built-in controls: Multiple reconciliation checks must pass before use
• Transparency: Exceptions (e.g., negative balances) are surfaced, not hidden

DECISION RULE
If Overall QA Health = PASS, outputs are approved for review and distribution.
If FAIL, results should not be used until resolved.

------------------------------------------------------------

1. OUTPUTS & KEY DEFINITIONS

• NA Population: Accounts flagged as Non-Accrual at month end
• Movement_Type: Facility-level classification explaining NA population change
• Reviewable_Flag: Identifies facilities queued for Top30 review
• Owner_For_Event: Single accountable owner per facility
• Top30: Prioritized review list, not portfolio totals

------------------------------------------------------------

2. END-TO-END DATA FLOW

SQL (Netezza)
→ MoM_Account_Detail (Excel Table)
→ Power Query Facility Rollup
→ Top30 Engine
→ Owner Drilldowns
→ Waterfall
→ QA & Controls (PASS/FAIL)

------------------------------------------------------------

3. SQL LOGIC OVERVIEW

Month Selection
• CURR_EOM: latest NA month
• PREV_EOM: prior NA month

Population Scope
• NA accounts only
• Relevant GL categories
• Positive and negative balances retained

Account-Level Construction
• Collapse to one row per ACCOUNT_KEY per month
• Full outer join across months
• MOM_DELTA = CURR_SSB − PREV_SSB
• Negative diagnostics retained

Event-Scoped Identifiers
• FOR_EVENT → CURR → PREV logic ensures correct grouping

------------------------------------------------------------

4. FACILITY-LEVEL CLASSIFICATION

Movement_Type
• Downgrade IN (ex-Auto)
• Exit (ex-Auto)
• Persisting Balance Changes (ex-Auto)
• Autochange variants
• No Change variants

Owner_For_Event
• Derived from representative account (largest |SSB_FOR_EVENT|)
• Absolute overrides applied at facility level

Reviewable_Flag
• Only Downgrade IN and Exit (ex-Auto)
• Requires positive exposure
• Coverage thresholds applied
• Autochange excluded

------------------------------------------------------------

5. EXCEL LOGIC

Power Query Rollup
• Groups by Month, Bank, Facility, Owner, Movement_Type
• Sums PREV_SSB, CURR_SSB, MOM_DELTA

Top30 Engine
• Downgrade IN ranked by MOM_DELTA
• Exit ranked by ABS(MOM_DELTA)

Owner Tabs
• Drilldowns using unified facility key logic
• Account-level context only

------------------------------------------------------------

6. WATERFALL LOGIC

• Starting balance = Prior NA population
• Movement rows explain change
• Ending balance = Current NA population
• Negative rows are diagnostic only

------------------------------------------------------------

7. QA & CONTROLS

• Anchor reconciliation
• Rollup reconciliation
• Top30 reconciliation
• Waterfall tie-out
• Overall QA Health (PASS/FAIL)





=LET(
  me, Top30_Engine!$B$2,
  topBlock, Top30_Engine!$A$11#,
  topFacilities, INDEX(topBlock,,1),

  facKey,
    IF(MoM_Account_Detail[FACILITY_FOR_EVENT]<>"",
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      IF(MoM_Account_Detail[CURR_FACILITY_ID]<>"",
        MoM_Account_Detail[CURR_FACILITY_ID],
        MoM_Account_Detail[PREV_FACILITY_ID]
      )
    ),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      facKey,
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(facKey, topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)

=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,1),

  facKey,
    IF(MoM_Account_Detail[FACILITY_FOR_EVENT]<>"",
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      IF(MoM_Account_Detail[CURR_FACILITY_ID]<>"",
        MoM_Account_Detail[CURR_FACILITY_ID],
        MoM_Account_Detail[PREV_FACILITY_ID]
      )
    ),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      facKey,
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(facKey, topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)










=LET(
  me, Top30_Engine!$B$2,
  topBlock, Top30_Engine!$A$11#,
  topFacilities, INDEX(topBlock,,1),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)


=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,1),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)









=LET(
  me, $B$2,
  mt, $B$3,
  own, $B$4,
  bk, $B$5,
  topN, $B$7,

  crit,
    (tbl_Facility_Rollup_All[ME_DATE]=me) *
    (tbl_Facility_Rollup_All[MOVEMENT_TYPE]=mt) *
    (tbl_Facility_Rollup_All[REVIEWABLE_FLAG_MAX]=1) *
    IF(own="ALL", 1, tbl_Facility_Rollup_All[OWNER_EVENT]=own) *
    IF(bk="ALL", 1, tbl_Facility_Rollup_All[BANK_EVENT]=bk),

  fac,   FILTER(tbl_Facility_Rollup_All[FACILITY_EVENT], crit),
  ownc,  FILTER(tbl_Facility_Rollup_All[OWNER_EVENT], crit),
  bank,  FILTER(tbl_Facility_Rollup_All[BANK_EVENT], crit),
  prev,  FILTER(tbl_Facility_Rollup_All[PREV_SSB_SUM], crit),
  curr,  FILTER(tbl_Facility_Rollup_All[CURR_SSB_SUM], crit),
  delta, FILTER(tbl_Facility_Rollup_All[MOM_DELTA_SUM], crit),

  metric, IF(mt="Downgrade IN (ex-Auto)", delta, ABS(delta)),

  data, HSTACK(fac, ownc, bank, prev, curr, delta, metric),
  sorted, SORTBY(data, metric, -1),

  TAKE(sorted, MIN(topN, ROWS(sorted)))
)

=LET(
  me, $B$43,
  mt, $B$44,
  own, $B$45,
  bk, $B$46,
  topN, $B$48,

  crit,
    (tbl_Facility_Rollup_All[ME_DATE]=me) *
    (tbl_Facility_Rollup_All[MOVEMENT_TYPE]=mt) *
    (tbl_Facility_Rollup_All[REVIEWABLE_FLAG_MAX]=1) *
    IF(own="ALL", 1, tbl_Facility_Rollup_All[OWNER_EVENT]=own) *
    IF(bk="ALL", 1, tbl_Facility_Rollup_All[BANK_EVENT]=bk),

  fac,   FILTER(tbl_Facility_Rollup_All[FACILITY_EVENT], crit),
  ownc,  FILTER(tbl_Facility_Rollup_All[OWNER_EVENT], crit),
  bank,  FILTER(tbl_Facility_Rollup_All[BANK_EVENT], crit),
  prev,  FILTER(tbl_Facility_Rollup_All[PREV_SSB_SUM], crit),
  curr,  FILTER(tbl_Facility_Rollup_All[CURR_SSB_SUM], crit),
  delta, FILTER(tbl_Facility_Rollup_All[MOM_DELTA_SUM], crit),

  metric, IF(mt="Downgrade IN (ex-Auto)", delta, ABS(delta)),

  data, HSTACK(fac, ownc, bank, prev, curr, delta, metric),
  sorted, SORTBY(data, metric, -1),

  TAKE(sorted, MIN(topN, ROWS(sorted)))
)


let
    Source = pq_MoM_Account_Detail_Excel,

    // -----------------------------
    // Canonical Event Dimensions
    // Priority: FOR_EVENT → CURR → PREV
    // -----------------------------
    AddFacility = Table.AddColumn(Source, "FACILITY_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "FACILITY_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_FACILITY_ID")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_FACILITY_ID")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddBank = Table.AddColumn(AddFacility, "BANK_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "BANK_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    AddOwner = Table.AddColumn(AddBank, "OWNER_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "OWNER_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    // -----------------------------
    // Month End
    // -----------------------------
    AddME = Table.AddColumn(AddOwner, "ME_DATE", each
        let
            c = try Date.From(Record.Field(_, "CURR_EOM")) otherwise null,
            p = try Date.From(Record.Field(_, "PREV_EOM")) otherwise null
        in
            if c <> null then c else p
    , type date),

    // -----------------------------
    // Keep Only What We Need
    // -----------------------------
    KeepCols = Table.SelectColumns(AddME,{
        "ME_DATE",
        "BANK_EVENT",
        "FACILITY_EVENT",
        "OWNER_EVENT",
        "MOVEMENT_TYPE",
        "PREV_SSB",
        "CURR_SSB",
        "MOM_DELTA",
        "REVIEWABLE_FLAG"
    }),

    Types = Table.TransformColumnTypes(KeepCols,{
        {"ME_DATE", type date},
        {"BANK_EVENT", type text},
        {"FACILITY_EVENT", type text},
        {"OWNER_EVENT", type text},
        {"MOVEMENT_TYPE", type text},
        {"PREV_SSB", type number},
        {"CURR_SSB", type number},
        {"MOM_DELTA", type number},
        {"REVIEWABLE_FLAG", Int64.Type}
    }),

    // -----------------------------
    // Facility-Level Rollup
    // -----------------------------
    Grouped = Table.Group(Types,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE"},
        {
            {"PREV_SSB_SUM", each List.Sum([PREV_SSB]), type number},
            {"CURR_SSB_SUM", each List.Sum([CURR_SSB]), type number},
            {"MOM_DELTA_SUM", each List.Sum([MOM_DELTA]), type number},
            {"REVIEWABLE_FLAG_MAX", each List.Max([REVIEWABLE_FLAG]), Int64.Type}
        }
    )
in
    Grouped





/* ================================== Query 1: MoM_Account_Detail ======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags (account-level) */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags (account-level) */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Pos→Neg Flip'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Neg→Pos Flip'
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Δ'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Δ'
      ELSE NULL
    END AS Negative_Class

  FROM joined j
),

/* CIS totals (account-level window, as-is) */
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
),

/* Event-scoped fields (same logic you had in final SELECT, moved earlier so we can roll up at facility level) */
event_scoped AS (
  SELECT
    w.*,

    /* Account_Name for the “event” side (curr if exists, else prev) */
    CASE
      WHEN w.has_curr=1 THEN w.Curr_Account_Name
      WHEN w.had_prev=1 THEN w.Prev_Account_Name
      ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
    END AS Account_Name_For_Event,

    /* event scoping */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
      WHEN w.has_curr=1 THEN w.Curr_Bank_Code
      ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
    END AS Bank_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
      WHEN w.has_curr=1 THEN w.Curr_Facility_ID
      ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
    END AS Facility_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
      WHEN w.has_curr=1 THEN w.Curr_CIS
      ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
    END AS CIS_For_Event,

    /* choose event-side CSS/PROD/BANK/RBC for downstream owner logic */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CSS
      WHEN w.has_curr=1 THEN w.Curr_CSS
      ELSE COALESCE(w.Curr_CSS, w.Prev_CSS)
    END AS CSS_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_PROD5
      WHEN w.has_curr=1 THEN w.Curr_PROD5
      ELSE COALESCE(w.Curr_PROD5, w.Prev_PROD5)
    END AS PROD5_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_RBC
      WHEN w.has_curr=1 THEN w.Curr_RBC
      ELSE COALESCE(w.Curr_RBC, w.Prev_RBC)
    END AS RBC_For_Event,

    /* balances */
    (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,

    CASE
      WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
      ELSE COALESCE(w.Prev_SSB,0)
    END AS SSB_For_Event
  FROM with_cis w
),

/* Account-level owner (event-side) with Daniel override moved to the top */
account_owner_event AS (
  SELECT
    e.*,

    CASE
      WHEN e.CSS_For_Event = 'INFL10' THEN 'Daniel'  /* HARD OVERRIDE */
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
      WHEN e.Bank_For_Event='L-SVB' THEN 'Eleanor'
      WHEN UPPER(COALESCE(e.RBC_For_Event,''))='R' THEN 'Autochange'
      WHEN e.Bank_For_Event='L-FCB' THEN 'Connor'
      ELSE 'NOT COVERED'
    END AS Owner_Account_For_Event
  FROM event_scoped e
),

/* Rank accounts within facility to pick representative attributes (largest |SSB_For_Event|) */
ranked_in_facility AS (
  SELECT
    a.*,
    ROW_NUMBER() OVER (
      PARTITION BY a.Bank_For_Event, a.Facility_For_Event
      ORDER BY ABS(COALESCE(a.SSB_For_Event,0)) DESC, a.Account_Key
    ) AS rn_fac
  FROM account_owner_event a
),

/* Facility rollup + facility-level classification + facility owner */
facility_rollup AS (
  SELECT
    Bank_For_Event,
    Facility_For_Event,

    /* Presence tests (avoid net-to-zero masking) */
    SUM(ABS(COALESCE(Prev_SSB,0))) AS Fac_Prev_Abs_SSB,
    SUM(ABS(COALESCE(Curr_SSB,0))) AS Fac_Curr_Abs_SSB,

    /* Positive exposure tests (reviewable gating) */
    SUM(CASE WHEN COALESCE(Prev_SSB,0) > 0 THEN COALESCE(Prev_SSB,0) ELSE 0 END) AS Fac_Prev_Pos_SSB,
    SUM(CASE WHEN COALESCE(Curr_SSB,0) > 0 THEN COALESCE(Curr_SSB,0) ELSE 0 END) AS Fac_Curr_Pos_SSB,

    /* Net balances for delta-based “persisting change” */
    SUM(COALESCE(Prev_SSB,0)) AS Fac_Prev_Net_SSB,
    SUM(COALESCE(Curr_SSB,0)) AS Fac_Curr_Net_SSB,

    /* Facility-level auto flags: ANY auto within facility */
    MAX(CASE WHEN UPPER(COALESCE(Prev_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Prev_Auto_Any,
    MAX(CASE WHEN UPPER(COALESCE(Curr_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Curr_Auto_Any,

    /* Daniel override: ANY INFL10 in facility => Daniel */
    MAX(CASE WHEN CSS_For_Event='INFL10' THEN 1 ELSE 0 END) AS Fac_INFL10_Any,

    /* Representative attributes from top |SSB_For_Event| row */
    MAX(CASE WHEN rn_fac=1 THEN CIS_For_Event END)         AS Fac_CIS_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN PROD5_For_Event END)       AS Fac_PROD5_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN RBC_For_Event END)         AS Fac_RBC_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN Owner_Account_For_Event END) AS Fac_Owner_From_TopRow,

    /* Representative CIS totals from top row (used in threshold exclusions) */
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Curr_CIS_SSB,0) END) AS Fac_Curr_CIS_SSB,
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Prev_CIS_SSB,0) END) AS Fac_Prev_CIS_SSB

  FROM ranked_in_facility
  GROUP BY Bank_For_Event, Facility_For_Event
),

facility_classified AS (
  SELECT
    fr.*,

    /* facility presence flags */
    CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Had_Prev,
    CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Has_Curr,

    /* facility owner for event */
    CASE
      WHEN fr.Fac_INFL10_Any = 1 THEN 'Daniel'
      ELSE COALESCE(fr.Fac_Owner_From_TopRow, 'NOT COVERED')
    END AS Owner_Facility_For_Event,

    /* FACILITY-level Movement_Type */
    CASE
      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
        THEN 'Autochange Downgrade IN'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
        THEN 'Autochange Exit'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange Persisting Balance Changes'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange No Change'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
        THEN 'Downgrade IN (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
        THEN 'Exit (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Persisting Balance Changes (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'No Change (ex-Auto)'

      ELSE NULL
    END AS Movement_Type_Facility,

    /* FACILITY-level Reviewable_Flag (stamped down) */
    CASE
      WHEN (
        /* only these two types are review-queued */
        (CASE
           WHEN (
             CASE
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
               THEN 'Downgrade IN (ex-Auto)'
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
               THEN 'Exit (ex-Auto)'
               ELSE NULL
             END
           ) IS NOT NULL THEN 1 ELSE 0
         END)=1

        AND (
          /* positive exposure must exist on relevant side */
          ( ( /* Downgrade IN */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Curr_Pos_SSB,0) > 0
            )
            OR
            ( /* Exit */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Prev_Pos_SSB,0) > 0
            )
          )
        )

        AND (
          /* exclusions (mirror your prior logic, applied at facility rep-level) */
          CASE
            /* Downgrade IN exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END

            /* Exit exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END
            ELSE 0
          END = 1
        )
      )
      THEN 1 ELSE 0
    END AS Reviewable_Flag_Facility

  FROM facility_rollup fr
)

/* =========================
   FINAL OUTPUT (ACCOUNT_KEY grain)
   - Movement_Type = facility-level Movement_Type_Facility
   - Owner_For_Event = facility-level Owner_Facility_For_Event
   - Reviewable_Flag = facility-level Reviewable_Flag_Facility
========================= */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  a.Account_Key,

  /* prev attributes */
  a.Prev_Account_Identifier,
  a.Prev_Facility_ID,
  a.Prev_CIS,
  a.Prev_Account_Name,
  a.Prev_CSS,
  a.Prev_PROD5,
  a.Prev_RBC,
  a.Prev_Status,
  a.Prev_GL_L4,
  a.Prev_Bank_Code,
  a.Prev_SSB,
  a.Prev_GL_Balance,
  a.Prev_CO_MTD,

  /* curr attributes */
  a.Curr_Account_Identifier,
  a.Curr_Facility_ID,
  a.Curr_CIS,
  a.Curr_Account_Name,
  a.Curr_CSS,
  a.Curr_PROD5,
  a.Curr_RBC,
  a.Curr_Status,
  a.Curr_GL_L4,
  a.Curr_Bank_Code,
  a.Curr_SSB,
  a.Curr_GL_Balance,
  a.Curr_CO_MTD,

  /* event-side display fields */
  a.Account_Name_For_Event,
  a.Bank_For_Event,
  a.Facility_For_Event,
  a.CIS_For_Event,

  /* balances */
  a.MoM_Delta,
  a.SSB_For_Event,

  /* FACILITY movement typing */
  fc.Movement_Type_Facility AS Movement_Type,

  /* Owners (Curr / Prev) with Daniel override absolute */
  CASE
    WHEN a.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Curr_RBC='R' THEN 'Autochange'
    WHEN a.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN a.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Prev_RBC='R' THEN 'Autochange'
    WHEN a.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* FACILITY owner for event */
  fc.Owner_Facility_For_Event AS Owner_For_Event,

  /* FACILITY reviewable flag */
  fc.Reviewable_Flag_Facility AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  a.Curr_CIS_SSB,
  a.Prev_CIS_SSB,
  a.Negative_Flag,
  a.Negative_Class,
  a.Negative_Flip_Flag

FROM ranked_in_facility a
JOIN facility_classified fc
  ON a.Bank_For_Event = fc.Bank_For_Event
 AND a.Facility_For_Event = fc.Facility_For_Event

/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(a.Prev_SSB,0) = 0 AND COALESCE(a.Curr_SSB,0) = 0)

ORDER BY a.Bank_For_Event, a.Facility_For_Event, a.Account_Key;







SQL logic overview

MoM_Account_Detail is built as a month-over-month join at the account level (prev month vs curr month). After joining, the SQL assigns:

an event classification (MOVEMENT_TYPE) that explains what happened MoM, and

an owner attribution (OWNER_FOR_EVENT) so movement and Top30 rollups can be grouped to the correct owner.

The guiding design principle is:

Movement_Type describes the event.
OWNER_FOR_EVENT describes who should be accountable for reviewing that event.

How MOVEMENT_TYPE is assigned

The SQL assigns MOVEMENT_TYPE using a combination of:

Non-Accrual population status (prev vs curr)

Autochange flagging (system-driven vs manual / credit-driven)

Balance change behavior for persisting NA facilities

Even though you don’t always store an explicit “NA flag” field in the extract, the SQL effectively derives NA membership from a status indicator (often PREV_STATUS and CURR_STATUS, or an internal NA flag used in the query).

Conceptual decision tree

Step 1 — Determine NA membership by month

Prev NA? (was account/facility in NA last month)

Curr NA? (is account/facility in NA this month)

Then:

A) Downgrade IN (ex-Auto)

Meaning: Not NA last month → NA this month, and not system autochange.

Typical condition pattern:

Prev NA = No AND Curr NA = Yes

AND NOT autochange

Result:

MOVEMENT_TYPE = "Downgrade IN (ex-Auto)"

B) Exit (ex-Auto)

Meaning: NA last month → not NA this month, and not system autochange.

Typical condition pattern:

Prev NA = Yes AND Curr NA = No

AND NOT autochange

Result:

MOVEMENT_TYPE = "Exit (ex-Auto)"

C) Persisting Balance Changes (ex-Auto)

Meaning: NA last month → NA this month, and balance changed (excluding autochange).

Typical condition pattern:

Prev NA = Yes AND Curr NA = Yes

AND NOT autochange

AND MOM_DELTA <> 0 (or a threshold)

Result:

MOVEMENT_TYPE = "Persisting Balance Changes (ex-Auto)"

Note: Many builds split “Persisting No Δ” vs “Persisting Δ”. In your file, the waterfall uses the Δ version as a bridge component.

D) Autochange movements

Meaning: NA changes driven by system autochange logic.

These are parallel to the “ex-Auto” events, but flagged as autochange:

MOVEMENT_TYPE = "Autochange Downgrade IN"

MOVEMENT_TYPE = "Autochange Exit"

MOVEMENT_TYPE = "Autochange Persisting Balance Changes"

Why we separate Autochange: It allows the waterfall and Top30 review process to isolate system-driven movement from true credit-review movement.

How OWNER_FOR_EVENT is assigned (Owner attribution)

You have:

OWNER_PREV

OWNER_CURR

OWNER_FOR_EVENT

The SQL chooses OWNER_FOR_EVENT based on the type of event so the movement is attributed to the owner most appropriate for review.

Owner attribution rules (recommended / typical)
1) Exits (ex-Auto)

Owner should come from the NA population you are exiting from, i.e. prior month.

OWNER_FOR_EVENT = OWNER_PREV

Reason:

Exits represent the facility leaving NA; the review is tied to who owned it while it was in NA.

2) Downgrade IN (ex-Auto)

Owner should come from the NA population you are entering into, i.e. current month.

OWNER_FOR_EVENT = OWNER_CURR

Reason:

Downgrades represent new NA entries; the review belongs to the owner now managing the facility in NA.

3) Persisting Balance Changes (ex-Auto)

Owner should generally be the current month owner, unless your org’s accountability model says otherwise.

OWNER_FOR_EVENT = OWNER_CURR (typical)

Reason:

Persisting changes are “active management” within current NA book.

4) Autochange movements

Typically attributed consistently (most teams attribute autochange to the book owner in the month it appears):

OWNER_FOR_EVENT = OWNER_CURR (common)

Reason:

Keeps autochange impacts aligned to the current month ownership reporting.

Practical implication

This rule set prevents common ownership confusion:

Exits don’t get attributed to the “new” owner that never had the NA facility.

Downgrades don’t get attributed to the prior owner who didn’t have it in NA.

How the “FOR_EVENT” fields relate to movement + owner

Your table includes:

FACILITY_FOR_EVENT, CIS_FOR_EVENT, BANK_FOR_EVENT, ACCOUNT_NAME_FOR_EVENT

These exist because a record can “move” (bank, facility id changes, etc.) or may only exist in one month.

General rule:

For Exit events, “FOR_EVENT” values typically align to PREV context.

For Downgrade IN events, “FOR_EVENT” values typically align to CURR context.

For Persisting events, they usually align to CURR (or stable identifiers).

This ensures all rollups and Top30 pulls use a consistent facility identifier for the event.

Why you sometimes see negative SSB_FOR_EVENT

SSB_FOR_EVENT is an event-attributed balance used for drilldowns and Top30 detail. It can be negative due to:

negative balance accounts within a facility

“negative classification” logic (your NEGATIVE_FLAG / NEGATIVE_CLASS)

event attribution rules that apply sign conventions for certain movements

This is why portfolio Starting/Ending balances should be based on population fields (PREV_SSB / CURR_SSB) rather than SSB_FOR_EVENT.

How this ties to Excel objects

MoM_Account_Detail: account-grain event classification + attribution (Movement_Type, Owner_for_event)

tbl_Facility_Rollup_All: PQ rollup using MOVEMENT_TYPE + OWNER_FOR_EVENT to summarize MoM movement at facility level

Top30 Engine: ranks facilities using MOM_DELTA_SUM by movement type and owner

Owner tabs: pulls account-level details using facility membership in the Top30 list + movement type




=LET(
  t, tbl_Facility_Rollup_All,
  owner, "Daniel",
  mt, "Downgrade IN (ex-Auto)",

  /* 1) Filter to Daniel + Movement_Type + Reviewable */
  f, FILTER(t, (t[OWNER_EVEN]=owner)*(t[MOVEMENT_TYPE]=mt)*(t[REVIEWABLE_FLAG_MAX]=1)),

  /* 2) Facility list */
  facList, UNIQUE(f[FACILITY_EVENT]),

  /* 3) Aggregate CURR_SSB_SUM to facility level */
  facSSB, MAP(facList, LAMBDA(x, SUMIFS(f[CURR_SSB_SUM], f[FACILITY_EVENT], x))),

  /* 4) Sort by SSB desc */
  sortedFac, SORTBY(facList, facSSB, -1),
  sortedSSB, SORTBY(facSSB, facSSB, -1),

  /* 5) Cumulative coverage */
  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, IF(total=0, 0, run/total),

  /* 6) Find N to reach 80% */
  n, IF(total=0, 0, XMATCH(TRUE, cov>=0.8, 0)),

  /* 7) Output table */
  IF(total=0,
     {"FACILITY_EVENT","REVIEWABLE_SSB","CUM_COVERAGE";"—",0,0},
     VSTACK(
       {"FACILITY_EVENT","REVIEWABLE_SSB","CUM_COVERAGE"},
       TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
     )
  )
)

=LET(
  t, tbl_Facility_Rollup_All,
  owner, "Daniel",
  mt, "Exit (ex-Auto)",

  f, FILTER(t, (t[OWNER_EVEN]=owner)*(t[MOVEMENT_TYPE]=mt)*(t[REVIEWABLE_FLAG_MAX]=1)),

  facList, UNIQUE(f[FACILITY_EVENT]),
  facSSB, MAP(facList, LAMBDA(x, SUMIFS(f[CURR_SSB_SUM], f[FACILITY_EVENT], x))),

  sortedFac, SORTBY(facList, facSSB, -1),
  sortedSSB, SORTBY(facSSB, facSSB, -1),

  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, IF(total=0, 0, run/total),

  n, IF(total=0, 0, XMATCH(TRUE, cov>=0.8, 0)),

  IF(total=0,
     {"FACILITY_EVENT","REVIEWABLE_SSB","CUM_COVERAGE";"—",0,0},
     VSTACK(
       {"FACILITY_EVENT","REVIEWABLE_SSB","CUM_COVERAGE"},
       TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
     )
  )
)









=LET(
  owner,"Daniel",
  mt,"Downgrade IN (ex-Auto)",
  t,Facility_Rollup,
  f,FILTER(t, (t[OWNER]=owner)*(t[Movement_Type]=mt)),
  fac,f[FACILITY_ID],
  ssb,f[Reviewable_SSB],
  sortedFac, SORTBY(fac, ssb, -1),
  sortedSSB, SORTBY(ssb, ssb, -1),
  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, IF(total=0, 0, run/total),
  n, IF(total=0, 0, XMATCH(TRUE, cov>=0.8, 0)),
  IF(total=0,
     {"FACILITY_ID","Reviewable_SSB","Cum_Coverage";"—",0,0},
     VSTACK(
       {"FACILITY_ID","Reviewable_SSB","Cum_Coverage"},
       TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
     )
  )
)


=LET(
  owner,"Daniel",
  mt,"Exit (ex-Auto)",
  t,Facility_Rollup,
  f,FILTER(t, (t[OWNER]=owner)*(t[Movement_Type]=mt)),
  fac,f[FACILITY_ID],
  ssb,f[Reviewable_SSB],
  sortedFac, SORTBY(fac, ssb, -1),
  sortedSSB, SORTBY(ssb, ssb, -1),
  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, IF(total=0, 0, run/total),
  n, IF(total=0, 0, XMATCH(TRUE, cov>=0.8, 0)),
  IF(total=0,
     {"FACILITY_ID","Reviewable_SSB","Cum_Coverage";"—",0,0},
     VSTACK(
       {"FACILITY_ID","Reviewable_SSB","Cum_Coverage"},
       TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
     )
  )
)







=LET(
  owner,"Daniel",
  t,Facility_Rollup,
  f,FILTER(t, t[OWNER]=owner),
  ssb,CHOOSECOLS(f, XMATCH("REVIEWABLE_SSB", t[#Headers])),
  fac,CHOOSECOLS(f, XMATCH("FACILITY_ID", t[#Headers])),
  sortedFac, SORTBY(fac, ssb, -1),
  sortedSSB, SORTBY(ssb, ssb, -1),
  total, SUM(sortedSSB),
  run, SCAN(0, sortedSSB, LAMBDA(a,v, a+v)),
  cov, run/total,
  n, XMATCH(TRUE, cov>=0.8, 0),
  TAKE(HSTACK(sortedFac, sortedSSB, cov), n)
)





Netezza SQL
   ↓
MoM_Account_Detail (Account-Level Table)
   ↓
Power Query (Excel-sourced, not ODBC)
   ↓
tbl_Facility_Rollup_All (Facility-Level Aggregation)
   ↓
────────────────────────────────────
↓              ↓                 ↓
Top30 Engine   Owner Tabs        Waterfall
(Facility)    (Account Detail)  (Portfolio Bridge)
────────────────────────────────────
   ↓
QA & Controls
   ↓
Overall QA Health (PASS / FAIL)






1. How to Run the File (Operator Instructions)

Open the workbook

Enable Editing and Enable Macros

Click the Refresh button

That’s it.

The refresh macro:

Re-runs the SQL extract that populates MoM_Account_Detail

Refreshes all Power Query rollups that source from that table

Recalculates Top30 Engine logic, Owner tabs, and the Waterfall

Triggers all QA & Controls validations

No manual refreshes or spot checks are required outside the QA & Controls tab.

2. Data & Logic Overview (What’s Under the Hood)
A. Core data table: MoM_Account_Detail (account-level)

This is the source-of-truth table at the account grain and contains:

Current and prior month attributes (CURR_*, PREV_*)

Month-over-month movement (MOM_DELTA)

Event classification (MOVEMENT_TYPE)

Reviewable inclusion logic (REVIEWABLE_FLAG)

Event-attributed balance (SSB_FOR_EVENT)

Key distinction (very important):

PREV_SSB / CURR_SSB → population balances (used for portfolio start/end)

MOM_DELTA → movement (used to explain change)

SSB_FOR_EVENT → event attribution (used for Top30 drilldowns; can be negative)

Because SSB_FOR_EVENT is event-attributed, it is not used for portfolio starting or ending balances.

B. Facility rollup: tbl_Facility_Rollup_All (facility-level)

Built in Power Query from the Excel table version of MoM_Account_Detail.

Grain:

Month × Bank × Facility × Owner × Movement Type

Key measures:

PREV_SSB_SUM

CURR_SSB_SUM

MOM_DELTA_SUM

Reviewable_Flag_Max

This rollup is used for:

Facility-level Top30 selection

Waterfall movement rows

3. Top30 Logic (What’s Being Reviewed)
How Top30 facilities are selected

Top30 is selected at the facility level, not account level, using movement:

Exit (ex-Auto) → ranked by ABS(MOM_DELTA_SUM)

Downgrade IN (ex-Auto) → ranked by MOM_DELTA_SUM (largest positive movers)

This avoids distortions caused by negative account balances and ensures Top30 reflects true material movement.

Owner tabs (account-level detail)

Once Top30 facilities are identified, the Owner tabs pull account-level rows where:

Facility ∈ Top30 list

REVIEWABLE_FLAG = 1

Correct MOVEMENT_TYPE

Current reporting month

These tabs are drilldowns, not control totals.

4. Waterfall Logic (Portfolio-Level Bridge)

The waterfall is a portfolio population bridge, not a movement-only view.

Starting Balance

Total prior-month Non-Accrual population SSB

Derived from MoM_Account_Detail population fields (not movement rollups)

Movement Rows

Derived from tbl_Facility_Rollup_All[MOM_DELTA_SUM]

Broken out by movement type (Exit, Downgrade IN, Autochange, Persisting, etc.)

Explain the change from start → end

Negative Section

The “Negative …” rows are memo / diagnostic breakouts

They represent subsets of movement already included above

They are excluded from the reconciliation math to avoid double counting

Ending Balance

Total current-month Non-Accrual population SSB

Derived from MoM_Account_Detail population fields

5. QA & Controls — What Each Check Validates

The QA & Controls tab is the authoritative validation layer.
If all checks pass, the file is considered correct.

1️⃣ Anchor reconciliation

Purpose: Validate the SQL extract itself

Confirms total current and prior month SSB from MoM_Account_Detail

Reconciles to a simple, independent “Anchor” query

Ensures the base population is complete and accurate

2️⃣ Facility rollup reconciliation

Purpose: Validate Power Query aggregation

Confirms total current and prior SSB from MoM_Account_Detail

Reconciles to totals in tbl_Facility_Rollup_All

Ensures no loss, duplication, or filtering errors in rollups

3️⃣ Top30 reconciliation & coverage reasonableness

Purpose: Validate Top30 logic and drilldowns

Confirms Top30 SSB totals reconcile to individual Owner tabs

Confirms coverage % is reasonable relative to portfolio size

Ensures Top30 lists are subsets of the full population, not overstated

4️⃣ Waterfall reconciliation

Purpose: Validate portfolio bridge integrity

Confirms:

Ending Balance = Starting Balance + Net Core Movement


Ensures movement logic fully explains the population change

Confirms no double counting (especially with negative memo rows)

5️⃣ Overall QA Health

Purpose: Executive-level signal

Aggregates all checks into a single PASS / FAIL indicator

If PASS → results are ready for review

If FAIL → investigation required before distribution

6. Interpretation Guidance (For Reviewers)

Top30 ≠ total portfolio
Top30 is a focused review set, not a control total.

Negative balances are expected at account level
They are handled correctly at facility and portfolio levels.

Waterfall negatives are informational
They provide transparency but do not alter the bridge math.







Validate the total current and previous month end SOURCE_SYSTEM_BALANCE (SSB) from MoM_Account_Detail reconciles to simple 'Anchor' query

Validate the total current and previous month end SSB from MoM_Account_Detail reconciles to Facility_Rollup

Validate Top30 SSB for current month reconciles to individual 'Owner' tabs for their respective 'Segments' and coverage % is reasonable

Validate Bridge rows reconcile to total ending balance

Overall QA Health






File Preparation Steps
1) Run the MoM_Account_Detail extract (SQL → Excel)

Refresh the MoM_Account_Detail query (your Netezza ODBC query).

Confirm it loads into the Excel table named MoM_Account_Detail.

Validate the month:

CURR_EOM should equal the current month-end you’re reporting.

PREV_EOM should be the prior month-end.

Quick check: Filter MoM_Account_Detail[CURR_EOM] and make sure there’s only one current month (unless you intentionally pull history).

2) Refresh Power Query rollups (Excel-local; should not hit ODBC)

Confirm the PQ staging query is sourced from the in-workbook table, not ODBC:

In Power Query, the source step should be Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content]

Refresh these queries (in order):

pq_MoM_Account_Detail_Excel (or whatever you named the Excel-table-based source)

pq_Facility_Rollup_All

Confirm output table exists in the workbook as:

tbl_Facility_Rollup_All

Why this matters: You don’t want the rollups re-querying Netezza; they should reference the already-loaded table.

3) Set the reporting month used by the dashboard formulas

On Top30_Engine, set/refresh:

Top30_Engine!B43 = current month end (should match MoM_Account_Detail[CURR_EOM])

(You can keep this as a formula like =MAX(MoM_Account_Detail[CURR_EOM]) if you want it automatic.)

4) Refresh the Top30 lists

On Top30_Engine:

Confirm the Top30 spill blocks refresh correctly (e.g., the block starting at Top30_Engine!A52#).

Confirm no blanks/zeros are being ranked unintentionally.

5) Refresh each Top30_Owner tab

For each owner tab:

Confirm the Top30 list matches the engine block for that owner/movement type.

Confirm the Account Detail spill pulls rows.

Confirm KPI cards populate.

6) Refresh the Waterfall

On the Waterfall tab:

Verify the bank columns populate (L-FCB, L-CIT, L-SVB, Total).

Confirm the checks tie (see “Checks” section below).

Logic Overview (SQL → Excel)
A) SQL logic (MoM_Account_Detail)

MoM_Account_Detail is an account-level month-over-month comparison table.

It contains:

Current month attributes (CURR_*)

Prior month attributes (PREV_*)

Event attribution fields (*_FOR_EVENT) that determine how movements are classified

Movement classification (MOVEMENT_TYPE)

Reviewable logic (REVIEWABLE_FLAG)

Balances:

PREV_SSB, CURR_SSB (population balances)

MOM_DELTA (change)

SSB_FOR_EVENT (event-attributed SSB used for drilldowns)

Important distinction:

PREV_SSB / CURR_SSB = population balances (used for portfolio starting/ending)

MOM_DELTA = movement amount (used for bridge explanations)

SSB_FOR_EVENT = event-attributed amount (useful for Top30 drilldowns / account details; can be negative depending on event logic)

B) Excel / Power Query logic
1) Facility rollup (tbl_Facility_Rollup_All)

Power Query groups account rows into facility-level movement summaries:

Grain: ME_DATE × Bank × Facility × Owner × Movement_Type

Measures:

PREV_SSB_SUM (sum of PREV_SSB)

CURR_SSB_SUM (sum of CURR_SSB)

MOM_DELTA_SUM (sum of MOM_DELTA)

Reviewable_Flag_Max (max REVIEWABLE_FLAG)

This rollup is ideal for:

Top30 selection at facility level

Waterfall movement rows by movement type

2) Top30 logic

Top30 is selected at facility level using the rollup measures:

Exit (ex-Auto): rank by ABS(MOM_DELTA_SUM)

Downgrade IN (ex-Auto): rank by MOM_DELTA_SUM (largest positive movers)

Account-level detail is pulled from MoM_Account_Detail using:

Facility ∈ Top30 list

REVIEWABLE_FLAG=1

MOVEMENT_TYPE matches

CURR_EOM = Top30_Engine!B43

3) KPI cards on Top30_Owner tabs

KPI cards are owner-level summaries filtered by:

Owner

Movement type

Reviewable flag

Reporting month

(And if you choose, restrict to positive-only values where needed.)

Waterfall Logic (Portfolio Level)
The key point

The waterfall is portfolio population + bridge, not movement-only.

Starting Balance

Must represent the prior month NA population (not a movement subset).

Ending Balance

Must represent the current month NA population.

Bridge rows

Explain how you got from start to end using:

movement type buckets (from tbl_Facility_Rollup_All)

optional negative diagnostics (from MoM_Account_Detail)

Checks and Tie-Outs
The issue you found (and the fix you applied)

Your “negative” section is a subset breakout of movement already included above.
So if you include negatives in the bridge sum, you double count.

Correct approach (memo-only negative section)

Keep negative rows as informational

Exclude them from the tie-out math

Checks that must tie

Ending - (Starting + Net Core Movement) should equal 0

Your Check1/Check2 should exclude the negative rows (memo section)

Practical Validation Checklist (takes 2 minutes)

Month sanity

Top30_Engine!B43 equals the CURR_EOM in MoM_Account_Detail.

Population sanity

Starting Balance (prior NA population) looks reasonable vs last month.

Ending Balance (current NA population) looks reasonable vs current month close.

Movement sanity

Exits are negative (or displayed as negative) and reduce the balance.

Downgrades increase the balance.

Tie-out

Check cells = 0 (or within rounding tolerance if you have pennies).




=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "Neg: New (No Prior)",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43,
  MoM_Account_Detail[REVIEWABLE_FLAG], 1
)


=SUM(
  SUMIFS(
    MoM_Account_Detail[MOM_DELTA],
    MoM_Account_Detail[NEGATIVE_CLASS], "Neg: Cleared to Zero",
    MoM_Account_Detail[CURR_BANK_CODE], C$1,
    MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43,
    MoM_Account_Detail[REVIEWABLE_FLAG], 1
  ),
  SUMIFS(
    MoM_Account_Detail[MOM_DELTA],
    MoM_Account_Detail[NEGATIVE_CLASS], "Neg: Neg→Pos Flip",
    MoM_Account_Detail[CURR_BANK_CODE], C$1,
    MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43,
    MoM_Account_Detail[REVIEWABLE_FLAG], 1
  )
)


=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "Neg: Persisting Δ",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43,
  MoM_Account_Detail[REVIEWABLE_FLAG], 1
)





Neg: Cleared to Zero
Neg: Neg→Pos Flip
Neg: New (No Prior)
Neg: Persisting No Δ
Neg: Persisting Δ
Neg: Pos→Neg Flip





=SUMIFS(
  tbl_Facility_Rollup_All[MOM_DELTA_SUM],
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Autochange Downgrade IN",
  tbl_Facility_Rollup_All[BANK_EVENT], C$1,
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)


=-ABS(
  SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Autochange Exit",
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  )
)

=SUMIFS(
  tbl_Facility_Rollup_All[MOM_DELTA_SUM],
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Autochange Persisting Balance Changes",
  tbl_Facility_Rollup_All[BANK_EVENT], C$1,
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)

=SUMIFS(
  tbl_Facility_Rollup_All[MOM_DELTA_SUM],
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Persisting Balance Changes (ex-Auto)",
  tbl_Facility_Rollup_All[BANK_EVENT], C$1,
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)

=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "New",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)


=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "Exit",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)

=SUMIFS(
  MoM_Account_Detail[MOM_DELTA],
  MoM_Account_Detail[NEGATIVE_CLASS], "Persisting Net",
  MoM_Account_Detail[CURR_BANK_CODE], C$1,
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)





=LET(
  me, Top30_Engine!$B$43,
  SUMIFS(
    MoM_Account_Detail[PREV_SSB],
    MoM_Account_Detail[CURR_EOM], me,
    MoM_Account_Detail[PREV_BANK_CODE], C$1,
    MoM_Account_Detail[PREV_STATUS], "Y"
  )
)


=LET(
  me, Top30_Engine!$B$43,
  SUMIFS(
    MoM_Account_Detail[CURR_SSB],
    MoM_Account_Detail[CURR_EOM], me,
    MoM_Account_Detail[CURR_BANK_CODE], C$1,
    MoM_Account_Detail[CURR_STATUS], "Y"
  )
)

=LET(
  me, Top30_Engine!$B$43,
  SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  )
)


=LET(
  me, Top30_Engine!$B$43,
  -ABS(SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Exit (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ))
)







=LET(
  me, Top30_Engine!$B$43,
  IFERROR(SUMIFS(
    tbl_Facility_Rollup_All[PREV_SSB_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ),0)
)


=LET(
  me, Top30_Engine!$B$43,
  IFERROR(SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ),0)
)

=LET(
  me, Top30_Engine!$B$43,
  -ABS(IFERROR(SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Exit (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ),0))
)

=LET(
  me, Top30_Engine!$B$43,
  IFERROR(SUMIFS(
    tbl_Facility_Rollup_All[MOM_DELTA_SUM],
    tbl_Facility_Rollup_All[ME_DATE], me,
    tbl_Facility_Rollup_All[BANK_EVENT], C$1,
    tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Persisting Balance Changes (ex-Auto)",
    tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
  ),0)
)









=SUMIFS(
  tbl_Facility_Rollup_All[PREV_SSB_SUM],
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[OWNER_EVENT], $B$2,
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Exit (ex-Auto)",
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)



=SUMIFS(
  tbl_Facility_Rollup_All[CURR_SSB_SUM],
  tbl_Facility_Rollup_All[ME_DATE], Top30_Engine!$B$43,
  tbl_Facility_Rollup_All[OWNER_EVENT], $B$2,
  tbl_Facility_Rollup_All[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  tbl_Facility_Rollup_All[Reviewable_Flag_Max], 1
)





=SUMIFS(
  MoM_Account_Detail[SSB_FOR_EVENT],
  MoM_Account_Detail[OWNER_FOR_EVENT], $B$2,
  MoM_Account_Detail[REVIEWABLE_FLAG], 1,
  MoM_Account_Detail[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)





=SUMIFS(
  MoM_Account_Detail[SSB_FOR_EVENT],
  MoM_Account_Detail[REVIEWABLE_FLAG], 1,
  MoM_Account_Detail[MOVEMENT_TYPE], "Exit (ex-Auto)",
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)


=SUMIFS(
  MoM_Account_Detail[SSB_FOR_EVENT],
  MoM_Account_Detail[REVIEWABLE_FLAG], 1,
  MoM_Account_Detail[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  MoM_Account_Detail[CURR_EOM], Top30_Engine!$B$43
)








=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,3),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)






MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]






=LET(
  me, Top30_Engine!$B$43,
  topBlock, Top30_Engine!$A$52#,
  topFacilities, INDEX(topBlock,,3),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],        /* ACCOUNT_NAME */
      MoM_Account_Detail[PREV_CIS],                 /* CIS_CUSTOMER_NUMBER */
      MoM_Account_Detail[FACILITY_FOR_EVENT],       /* FACILITY_ID */
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],  /* ACCOUNT_IDENTIFIER */
      MoM_Account_Detail[ACCOUNT_KEY],              /* ACCOUNT_KEY */
      MoM_Account_Detail[PREV_BANK_CODE],           /* BANK_CODE */
      MoM_Account_Detail[PREV_CSS],                 /* CONTRACT_SOURCE_SYSTEM */
      MoM_Account_Detail[PREV_GL_L4],               /* GL_ACCOUNT_HIER_LEVEL_4 */
      MoM_Account_Detail[PREV_PROD5],               /* PROD_HIER_LEVEL_5 */
      MoM_Account_Detail[PREV_STATUS],              /* STATUS_CODE */
      MoM_Account_Detail[PREV_RBC],                 /* RBC_CODE */
      MoM_Account_Detail[PREV_SSB],                 /* SOURCE_SYSTEM_BALANCE */
      MoM_Account_Detail[PREV_GL_BALANCE]           /* GL_BALANCE */
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)






=LET(
  me, Top30_Engine!$B$1,
  topBlock, $R$50#,
  topFacilities, INDEX(topBlock,,3),

  acct_identifier, IF(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER]<>"",
                      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
                      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER]),

  bank_code, IF(MoM_Account_Detail[BANK_FOR_EVENT]<>"",
                MoM_Account_Detail[BANK_FOR_EVENT],
                IF(MoM_Account_Detail[CURR_BANK_CODE]<>"",
                   MoM_Account_Detail[CURR_BANK_CODE],
                   MoM_Account_Detail[PREV_BANK_CODE])),

  css, IF(MoM_Account_Detail[CURR_CSS]<>"", MoM_Account_Detail[CURR_CSS], MoM_Account_Detail[PREV_CSS]),
  gl4, IF(MoM_Account_Detail[CURR_GL_L4]<>"", MoM_Account_Detail[CURR_GL_L4], MoM_Account_Detail[PREV_GL_L4]),
  prod5, IF(MoM_Account_Detail[CURR_PROD5]<>"", MoM_Account_Detail[CURR_PROD5], MoM_Account_Detail[PREV_PROD5]),
  status, IF(MoM_Account_Detail[CURR_STATUS]<>"", MoM_Account_Detail[CURR_STATUS], MoM_Account_Detail[PREV_STATUS]),
  rbc, IF(MoM_Account_Detail[CURR_RBC]<>"", MoM_Account_Detail[CURR_RBC], MoM_Account_Detail[PREV_RBC]),
  gl_balance, IF(MoM_Account_Detail[CURR_GL_BALANCE]<>"", MoM_Account_Detail[CURR_GL_BALANCE], MoM_Account_Detail[PREV_GL_BALANCE]),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13},
      MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT],   /* ACCOUNT_NAME */
      MoM_Account_Detail[CIS_FOR_EVENT],            /* CIS_CUSTOMER_NUMBER */
      MoM_Account_Detail[FACILITY_FOR_EVENT],       /* FACILITY_ID */
      acct_identifier,                              /* ACCOUNT_IDENTIFIER */
      MoM_Account_Detail[ACCOUNT_KEY],              /* ACCOUNT_KEY */
      bank_code,                                    /* BANK_CODE */
      css,                                          /* CONTRACT_SOURCE_SYSTEM */
      gl4,                                          /* GL_ACCOUNT_HIER_LEVEL_4 */
      prod5,                                        /* PROD_HIER_LEVEL_5 */
      status,                                       /* STATUS_CODE */
      rbc,                                          /* RBC_CODE */
      MoM_Account_Detail[SSB_FOR_EVENT],            /* SOURCE_SYSTEM_BALANCE */
      gl_balance                                    /* GL_BALANCE */
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], topFacilities, 0)) *
      (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
      (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)") *
      (MoM_Account_Detail[OWNER_FOR_EVENT]=$R$46) *
      (MoM_Account_Detail[CURR_EOM]=me)
    ),

  SORT(filtered, 12, -1)
)





=LET(
  topBlock, $R$50#,
  topFacilities, INDEX(topBlock,,3),

  detailCols,
    CHOOSE(
      {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE],
      MoM_Account_Detail[MOVEMENT_TYPE],
      MoM_Account_Detail[OWNER_FOR_EVENT2]
    ),

  filtered,
    FILTER(
      detailCols,
      ISNUMBER(
        MATCH(
          MoM_Account_Detail[FACILITY_FOR_EVENT],
          topFacilities,
          0
        )
      )
      * (MoM_Account_Detail[REVIEWABLE_FLAG]=1)
      * (MoM_Account_Detail[MOVEMENT_TYPE]="Exit (ex-Auto)")
      * (MoM_Account_Detail[OWNER_FOR_EVENT2]=$R$46)
    ),

  SORT(filtered, 12, -1)
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  base, IFERROR(FILTER(MoM_Account_Detail, crit), ""),

  h, MoM_Account_Detail[#Headers],

  acct_name, CHOOSECOLS(base, XMATCH("ACCOUNT_NAME_FOR_EVENT", h)),
  cis,       CHOOSECOLS(base, XMATCH("CIS_FOR_EVENT", h)),
  fac,       CHOOSECOLS(base, XMATCH("FACILITY_FOR_EVENT", h)),

  acct_id_c, CHOOSECOLS(base, XMATCH("CURR_ACCOUNT_IDENTIFIER", h)),
  acct_id_p, CHOOSECOLS(base, XMATCH("PREV_ACCOUNT_IDENTIFIER", h)),
  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),

  acct_key,  CHOOSECOLS(base, XMATCH("ACCOUNT_KEY", h)),

  bank_evt,  CHOOSECOLS(base, XMATCH("BANK_FOR_EVENT", h)),
  bank_c,    CHOOSECOLS(base, XMATCH("CURR_BANK_CODE", h)),
  bank_p,    CHOOSECOLS(base, XMATCH("PREV_BANK_CODE", h)),
  bank,      IF(bank_evt<>"", bank_evt, IF(bank_c<>"", bank_c, bank_p)),

  css_c,     CHOOSECOLS(base, XMATCH("CURR_CSS", h)),
  css_p,     CHOOSECOLS(base, XMATCH("PREV_CSS", h)),
  css,       IF(css_c<>"", css_c, css_p),

  gl4_c,     CHOOSECOLS(base, XMATCH("CURR_GL_L4", h)),
  gl4_p,     CHOOSECOLS(base, XMATCH("PREV_GL_L4", h)),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),

  prod5_c,   CHOOSECOLS(base, XMATCH("CURR_PROD5", h)),
  prod5_p,   CHOOSECOLS(base, XMATCH("PREV_PROD5", h)),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),

  status_c,  CHOOSECOLS(base, XMATCH("CURR_STATUS", h)),
  status_p,  CHOOSECOLS(base, XMATCH("PREV_STATUS", h)),
  status,    IF(status_c<>"", status_c, status_p),

  rbc_c,     CHOOSECOLS(base, XMATCH("CURR_RBC", h)),
  rbc_p,     CHOOSECOLS(base, XMATCH("PREV_RBC", h)),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),

  ssb_evt,   CHOOSECOLS(base, XMATCH("SSB_FOR_EVENT", h)),

  glb_c,     CHOOSECOLS(base, XMATCH("CURR_GL_BALANCE", h)),
  glb_p,     CHOOSECOLS(base, XMATCH("PREV_GL_BALANCE", h)),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  IF(base="","",
    HSTACK(acct_name, cis, fac, acct_id, acct_key, bank, css, gl4, prod5, status, rbc, ssb_evt, glb)
  )
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),

  acct_id_c, FILTER(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER], crit),
  acct_id_p, FILTER(MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER], crit),
  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),

  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),

  bank_evt,  FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),
  bank_c,    FILTER(MoM_Account_Detail[CURR_BANK_CODE], crit),
  bank_p,    FILTER(MoM_Account_Detail[PREV_BANK_CODE], crit),
  bank,      IF(bank_evt<>"", bank_evt, IF(bank_c<>"", bank_c, bank_p)),

  css_c,     FILTER(MoM_Account_Detail[CURR_CSS], crit),
  css_p,     FILTER(MoM_Account_Detail[PREV_CSS], crit),
  css,       IF(css_c<>"", css_c, css_p),

  gl4_c,     FILTER(MoM_Account_Detail[CURR_GL_L4], crit),
  gl4_p,     FILTER(MoM_Account_Detail[PREV_GL_L4], crit),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),

  prod5_c,   FILTER(MoM_Account_Detail[CURR_PROD5], crit),
  prod5_p,   FILTER(MoM_Account_Detail[PREV_PROD5], crit),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),

  status_c,  FILTER(MoM_Account_Detail[CURR_STATUS], crit),
  status_p,  FILTER(MoM_Account_Detail[PREV_STATUS], crit),
  status,    IF(status_c<>"", status_c, status_p),

  rbc_c,     FILTER(MoM_Account_Detail[CURR_RBC], crit),
  rbc_p,     FILTER(MoM_Account_Detail[PREV_RBC], crit),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),

  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  glb_c,     FILTER(MoM_Account_Detail[CURR_GL_BALANCE], crit),
  glb_p,     FILTER(MoM_Account_Detail[PREV_GL_BALANCE], crit),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  HSTACK(
    acct_name,
    cis,
    fac,
    acct_id,
    acct_key,
    bank,
    css,
    gl4,
    prod5,
    status,
    rbc,
    ssb_evt,
    glb
  )
)





=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),
  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),
  bank,      FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),
  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  HSTACK(acct_name, cis, fac, acct_key, bank, ssb_evt)
)






=LET(
  me, Top30_Engine!$B$1,
  owner, $B$2,
  mt, "Exit (ex-Auto)",

  facs, FILTER(Top30_Engine!A7:A10000, (Top30_Engine!A7:A10000<>"")*(Top30_Engine!B7:B10000=owner)),

  crit,
    (MoM_Account_Detail[CURR_EOM]=me) *
    (MoM_Account_Detail[OWNER_FOR_EVENT]=owner) *
    (MoM_Account_Detail[MOVEMENT_TYPE]=mt) *
    (MoM_Account_Detail[REVIEWABLE_FLAG]=1) *
    ISNUMBER(MATCH(MoM_Account_Detail[FACILITY_FOR_EVENT], facs, 0)),

  acct_name, FILTER(MoM_Account_Detail[ACCOUNT_NAME_FOR_EVENT], crit),
  cis,       FILTER(MoM_Account_Detail[CIS_FOR_EVENT], crit),
  fac,       FILTER(MoM_Account_Detail[FACILITY_FOR_EVENT], crit),
  acct_id_c, FILTER(MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER], crit),
  acct_id_p, FILTER(MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER], crit),
  acct_key,  FILTER(MoM_Account_Detail[ACCOUNT_KEY], crit),

  bank,      FILTER(MoM_Account_Detail[BANK_FOR_EVENT], crit),

  css_c,     FILTER(MoM_Account_Detail[CURR_CSS], crit),
  css_p,     FILTER(MoM_Account_Detail[PREV_CSS], crit),

  gl4_c,     FILTER(MoM_Account_Detail[CURR_GL_L4], crit),
  gl4_p,     FILTER(MoM_Account_Detail[PREV_GL_L4], crit),

  prod5_c,   FILTER(MoM_Account_Detail[CURR_PROD5], crit),
  prod5_p,   FILTER(MoM_Account_Detail[PREV_PROD5], crit),

  status_c,  FILTER(MoM_Account_Detail[CURR_STATUS], crit),
  status_p,  FILTER(MoM_Account_Detail[PREV_STATUS], crit),

  rbc_c,     FILTER(MoM_Account_Detail[CURR_RBC], crit),
  rbc_p,     FILTER(MoM_Account_Detail[PREV_RBC], crit),

  ssb_evt,   FILTER(MoM_Account_Detail[SSB_FOR_EVENT], crit),

  glb_c,     FILTER(MoM_Account_Detail[CURR_GL_BALANCE], crit),
  glb_p,     FILTER(MoM_Account_Detail[PREV_GL_BALANCE], crit),

  acct_id,   IF(acct_id_c<>"", acct_id_c, acct_id_p),
  css,       IF(css_c<>"", css_c, css_p),
  gl4,       IF(gl4_c<>"", gl4_c, gl4_p),
  prod5,     IF(prod5_c<>"", prod5_c, prod5_p),
  status,    IF(status_c<>"", status_c, status_p),
  rbc,       IF(rbc_c<>"", rbc_c, rbc_p),
  glb,       IF(glb_c<>"", glb_c, glb_p),

  headers, {"ACCOUNT_NAME","CIS_CUSTOMER_NUMBER","FACILITY_ID","ACCOUNT_IDENTIFIER","ACCOUNT_KEY","BANK_CODE","CONTRACT_SOURCE_SYSTEM","GL_ACCOUNT_HIER_LEVEL_4","PROD_HIER_LEVEL_5","STATUS_CODE","RBC_CODE","SOURCE_SYSTEM_BALANCE","GL_BALANCE"},

  data, HSTACK(acct_name,cis,fac,acct_id,acct_key,bank,css,gl4,prod5,status,rbc,ssb_evt,glb),

  VSTACK(headers, data)
)






Here are the columns I want to show for both top30 facilities' account level detail categories (Downgrade IN (ex-Auto) and Exit (ex-Auto)) within the Top30_Owner tabs. You may need to wire the formulas to pull the correct corresponding columns from MoM_Account_Detail.

ACCOUNT_NAME
CIS_CUSTOMER_NUMBER
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
BANK_CODE
CONTRACT_SOURCE_SYSTEM
GL_ACCOUNT_HIER_LEVEL_4
PROD_HIER_LEVEL_5
STATUS_CODE
RBC_CODE
SOURCE_SYSTEM_BALANCE 
GL_BALANCE

Here are the columns I currently have in MoM_Account_Detail:

QUERY_RUN_TIMESTAMP
CURR_EOM
PREV_EOM
ACCOUNT_KEY
PREV_ACCOUNT_IDENTIFIER
PREV_FACILITY_ID
PREV_CIS
PREV_ACCOUNT_NAME
PREV_CSS
PREV_PROD5
PREV_RBC
PREV_STATUS
PREV_GL_L4
PREV_BANK_CODE
PREV_SSB 
PREV_GL_BALANCE
PREV_CO_MTD 
CURR_ACCOUNT_IDENTIFIER
CURR_FACILITY_ID
CURR_CIS
CURR_ACCOUNT_NAME
CURR_CSS
CURR_PROD5
CURR_RBC
CURR_STATUS
CURR_GL_L4
CURR_BANK_CODE
CURR_SSB 
CURR_GL_BALANCE
CURR_CO_MTD 
ACCOUNT_NAME_FOR_EVENT
BANK_FOR_EVENT
FACILITY_FOR_EVENT
CIS_FOR_EVENT
MOM_DELTA 
SSB_FOR_EVENT 
MOVEMENT_TYPE
OWNER_CURR
OWNER_PREV
OWNER_FOR_EVENT
REVIEWABLE_FLAG
CURR_CIS_SSB 
PREV_CIS_SSB 
NEGATIVE_FLAG
NEGATIVE_CLASS
NEGATIVE_FLIP_FLAG
Curr_CO_MTD_Lookup








=LET(
  me, $B$1,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,

  crit,
    (tbl_Facility_Rollup_All[ME_DATE]=me) *
    (tbl_Facility_Rollup_All[MOVEMENT_TYPE]=mt) *
    (tbl_Facility_Rollup_All[Reviewable_Flag_Max]=1) *
    IF(own="ALL", 1, tbl_Facility_Rollup_All[OWNER_EVENT]=own) *
    IF(bk="ALL", 1, tbl_Facility_Rollup_All[BANK_EVENT]=bk),

  fac,   FILTER(tbl_Facility_Rollup_All[FACILITY_EVENT], crit),
  ownc,  FILTER(tbl_Facility_Rollup_All[OWNER_EVENT], crit),
  bank,  FILTER(tbl_Facility_Rollup_All[BANK_EVENT], crit),
  prev,  FILTER(tbl_Facility_Rollup_All[Prev_SSB_SUM], crit),
  curr,  FILTER(tbl_Facility_Rollup_All[Curr_SSB_SUM], crit),
  delta, FILTER(tbl_Facility_Rollup_All[MoM_Delta_SUM], crit),

  metric, IF(mt="Downgrade IN (ex-Auto)", delta, ABS(delta)),

  data, HSTACK(fac, ownc, bank, prev, curr, delta, metric),
  sorted, SORTBY(data, metric, -1),

  TAKE(sorted, MIN(topN, ROWS(sorted)))
)

Facility | Owner | Bank | Prev_SSB | Curr_SSB | MoM_Delta | Magnitude




=LET(
  t, tbl_Facility_Rollup_All,
  me, $B$1,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,

  base, FILTER(
    t,
    (t[ME_DATE]=me) *
    (t[MOVEMENT_TYPE]=mt) *
    (t[Reviewable_Flag_Max]=1) *
    (IF(own="ALL", TRUE, t[OWNER_EVENT]=own)) *
    (IF(bk="ALL", TRUE, t[BANK_EVENT]=bk))
  ),

  metric, IF(mt="Exit (ex-Auto)", ABS(base[MoM_Delta_SUM]), ABS(base[MoM_Delta_SUM])),
  sorted, SORTBY(base, metric, -1),

  HSTACK(
    TAKE(sorted[FACILITY_EVENT], topN),
    TAKE(sorted[OWNER_EVENT], topN),
    TAKE(sorted[BANK_EVENT], topN),
    TAKE(sorted[Prev_SSB_SUM], topN),
    TAKE(sorted[Curr_SSB_SUM], topN),
    TAKE(sorted[MoM_Delta_SUM], topN),
    TAKE(metric, topN)
  )
)






=LET(
  t, tbl_Facility_Rollup_Latest,
  mt, $B$2,
  own, $B$3,
  bk, $B$4,
  topN, $B$6,
  onlyRev, TRUE,

  base, FILTER(
    t,
    (t[MOVEMENT_TYPE]=mt) *
    (IF(onlyRev, t[Reviewable_Flag_Max]=1, TRUE)) *
    (IF(own="ALL", TRUE, t[OWNER_EVENT]=own)) *
    (IF(bk="ALL", TRUE, t[BANK_EVENT]=bk))
  ),

  // ranking metric:
  // - Exit: rank by ABS(delta)
  // - Downgrade IN: rank by delta (positive)
  // default: ABS(delta)
  metric, IF(
    mt="Exit (ex-Auto)",
    ABS(CHOOSECOLS(base, XMATCH("MoM_Delta_SUM", t[#Headers]))),
    ABS(CHOOSECOLS(base, XMATCH("MoM_Delta_SUM", t[#Headers])))
  ),

  sorted, SORTBY(base, metric, -1),

  out, HSTACK(
    TAKE(CHOOSECOLS(sorted, XMATCH("FACILITY_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("OWNER_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("BANK_EVENT", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("Prev_SSB_SUM", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("Curr_SSB_SUM", t[#Headers])), topN),
    TAKE(CHOOSECOLS(sorted, XMATCH("MoM_Delta_SUM", t[#Headers])), topN),
    TAKE(metric, topN)
  ),

  out
)






let
    Source = Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content]
in
    Source





This is a Player Snapshot — not a stat sheet.

Traditional hockey stats tell you what happened.
They rarely help explain what to do next.

The IceStat Player Snapshot is designed to give coaches:
• A clear, blended view of player impact
• Trend context over time
• Supporting detail when deeper explanation is needed

Not more numbers —
but a clearer picture to support real coaching decisions.

This example uses synthetic data to show how IceStat translates tracked events into coaching context.

Team context and workflow matter just as much — more on that soon.







let
    Source = #"MoM_Account_Detail",

    // -----------------------------
    // Canonical Event Dimensions
    // Priority: FOR_EVENT → CURR → PREV
    // -----------------------------
    AddFacility = Table.AddColumn(Source, "FACILITY_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "FACILITY_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_FACILITY_ID")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_FACILITY_ID")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddBank = Table.AddColumn(AddFacility, "BANK_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "BANK_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    AddOwner = Table.AddColumn(AddBank, "OWNER_EVENT", each
        let
            fe = try Text.From(Record.Field(_, "OWNER_FOR_EVENT")) otherwise null
        in
            fe
    , type text),

    // -----------------------------
    // Month End
    // -----------------------------
    AddME = Table.AddColumn(AddOwner, "ME_DATE", each
        let
            c = try Date.From(Record.Field(_, "CURR_EOM")) otherwise null,
            p = try Date.From(Record.Field(_, "PREV_EOM")) otherwise null
        in
            if c <> null then c else p
    , type date),

    // -----------------------------
    // Keep Only What We Need
    // -----------------------------
    KeepCols = Table.SelectColumns(AddME,{
        "ME_DATE",
        "BANK_EVENT",
        "FACILITY_EVENT",
        "OWNER_EVENT",
        "MOVEMENT_TYPE",
        "Prev_SSB",
        "Curr_SSB",
        "MoM_Delta",
        "REVIEWABLE_FLAG"
    }),

    Types = Table.TransformColumnTypes(KeepCols,{
        {"ME_DATE", type date},
        {"BANK_EVENT", type text},
        {"FACILITY_EVENT", type text},
        {"OWNER_EVENT", type text},
        {"MOVEMENT_TYPE", type text},
        {"Prev_SSB", type number},
        {"Curr_SSB", type number},
        {"MoM_Delta", type number},
        {"REVIEWABLE_FLAG", Int64.Type}
    }),

    // -----------------------------
    // Facility-Level Rollup
    // -----------------------------
    Grouped = Table.Group(Types,
        {"ME_DATE","BANK_EVENT","FACILITY_EVENT","OWNER_EVENT","MOVEMENT_TYPE"},
        {
            {"Prev_SSB_SUM", each List.Sum([Prev_SSB]), type number},
            {"Curr_SSB_SUM", each List.Sum([Curr_SSB]), type number},
            {"MoM_Delta_SUM", each List.Sum([MoM_Delta]), type number},
            {"Reviewable_Flag_Max", each List.Max([REVIEWABLE_FLAG]), Int64.Type}
        }
    )
in
    Grouped








AddME = Table.AddColumn(AddOwner, "ME_DATE", each
    let
        c = try Date.From(Record.Field(_, "CURR_EOM")) otherwise null,
        p = try Date.From(Record.Field(_, "PREV_EOM")) otherwise null
    in
        if c <> null then c else p
, type date),






let
    Source = Excel.CurrentWorkbook(){[Name="MoM_Account_Detail"]}[Content],

    // -----------------------------
    // 1) Add "canonical" event columns
    //    Rule: FOR_EVENT -> CURR -> PREV
    // -----------------------------
    AddFacility = Table.AddColumn(Source, "FACILITY_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "FACILITY_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_FACILITY_ID")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_FACILITY_ID")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddBank = Table.AddColumn(AddFacility, "BANK_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "BANK_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_BANK")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_BANK")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddOwner = Table.AddColumn(AddBank, "OWNER_FOR_EVENT_STD", each
        let
            fe = try Text.From(Record.Field(_, "OWNER_FOR_EVENT")) otherwise null,
            ce = try Text.From(Record.Field(_, "CURR_OWNER")) otherwise null,
            pe = try Text.From(Record.Field(_, "PREV_OWNER")) otherwise null
        in
            if fe <> null and Text.Trim(fe) <> "" then fe
            else if ce <> null and Text.Trim(ce) <> "" then ce
            else pe
    , type text),

    AddME = Table.AddColumn(AddOwner, "ME_DATE", each
        let
            me = try Date.From(Record.Field(_, "END_OF_MONTH_DATE")) otherwise null
        in
            me
    , type date),

    // -----------------------------
    // 2) Keep only what we need (fast + stable)
    //    IMPORTANT: adjust measure column names here if needed
    // -----------------------------
    KeepCols = Table.SelectColumns(AddME,{
        "ME_DATE",
        "BANK_FOR_EVENT_STD",
        "FACILITY_FOR_EVENT_STD",
        "OWNER_FOR_EVENT_STD",
        "MOVEMENT_TYPE",

        // measures (edit if your names differ)
        "SSB_FOR_EVENT",
        "MOM_DELTA",
        "REVIEWABLE_FLAG"
    }),

    Types = Table.TransformColumnTypes(KeepCols,{
        {"ME_DATE", type date},
        {"BANK_FOR_EVENT_STD", type text},
        {"FACILITY_FOR_EVENT_STD", type text},
        {"OWNER_FOR_EVENT_STD", type text},
        {"MOVEMENT_TYPE", type text},
        {"SSB_FOR_EVENT", type number},
        {"MOM_DELTA", type number},
        {"REVIEWABLE_FLAG", Int64.Type}
    }),

    // -----------------------------
    // 3) Roll up to facility level for Top30 + Waterfall
    // -----------------------------
    Grouped = Table.Group(Types,
        {"ME_DATE","BANK_FOR_EVENT_STD","FACILITY_FOR_EVENT_STD","OWNER_FOR_EVENT_STD","MOVEMENT_TYPE"},
        {
            {"SSB_FOR_EVENT_SUM", each List.Sum([SSB_FOR_EVENT]), type number},
            {"MOM_DELTA_SUM", each List.Sum([MOM_DELTA]), type number},
            {"REVIEWABLE_FLAG_MAX", each List.Max([REVIEWABLE_FLAG]), Int64.Type}
        }
    )

in
    Grouped





=SUMIFS(
  tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)


=SUMIFS(
  tbl_Facility_Rollup[Sum of MOM_DELTA],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)

=-SUMIFS(
  tbl_Facility_Rollup[Sum of MOM_DELTA],
  tbl_Facility_Rollup[BANK_FOR_EVENT], "L-FCB",
  tbl_Facility_Rollup[MOVEMENT_TYPE], "Exit (ex-Auto)",
  tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
)






=IFERROR(
  SUMIFS(
    tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[MOVEMENT_TYPE], "Downgrade IN (ex-Auto)",
    tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
  ),
  0
)


=IFERROR(
  SUMIFS(
    tbl_Facility_Rollup[Sum of SSB_FOR_EVENT],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[MOVEMENT_TYPE], "Exit (ex-Auto)",
    tbl_Facility_Rollup[Max of REVIEWABLE_FLAG], 1
  ),
  0
)





BANK_FOR_EVENT
FACILITY_FOR_EVENT
MOVEMENT_TYPE
OWNER_FOR_EVENT
Sum of SSB_FOR_EVENT
Sum of MOM_DELTA
Max of REVIEWABLE_FLAG





=SUMIFS(
    tbl_Facility_Rollup[Reviewable_SSB],
    tbl_Facility_Rollup[OWNER_FOR_EVENT], $B$2,
    tbl_Facility_Rollup[Movement_Type], "Downgrade IN (ex-Auto)"
)





=LET(
  owner, $B$2,
  mt, "Exit (ex-Auto)",
  facs, UNIQUE(FILTER(MoM_Account_Detail[FACILITY_ID],
        (MoM_Account_Detail[OWNER_FOR_EVENT]=owner)*
        (MoM_Account_Detail[Movement_Type]=mt)
  )),
  perFac, BYROW(facs, LAMBDA(f,
        SUMIFS(
          MoM_Account_Detail[CURR_SSB],
          MoM_Account_Detail[FACILITY_ID], f,
          MoM_Account_Detail[Is_Reviewable], 1
        )
  )),
  SUM(perFac)
)






=GETPIVOTDATA(
  "Total Reviewable SSB",
  Facility_Rollup!$A$3,
  "OWNER_FOR_EVENT", $B$2,
  "Movement_Type", "Downgrade IN (ex-Auto)"
)

=GETPIVOTDATA(
  "Total Reviewable SSB",
  Facility_Rollup!$A$3,
  "OWNER_FOR_EVENT", $B$2,
  "Movement_Type", "Exit (ex-Auto)"
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$59#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel, "")),

  facCol, CHOOSECOLS(d, IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), TAKE(d,0)),

  idxRaw, HSTACK(
    IFNA(XMATCH("PREV_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("PREV_CIS", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("PREV_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("PREV_BANK_CODE", hdr), 0),
    IFNA(XMATCH("PREV_CSS", hdr), 0),
    IFNA(XMATCH("PREV_GL_L4", hdr), 0),
    IFNA(XMATCH("PREV_PROD5", hdr), 0),
    IFNA(XMATCH("PREV_STATUS", hdr), 0),
    IFNA(XMATCH("PREV_RBC", hdr), 0),
    IFNA(XMATCH("PREV_SSB", hdr), 0),
    IFNA(XMATCH("PREV_GL_BALANCE", hdr), 0)
  ),
  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, CHOOSECOLS(rows, idx),

  ssbIdx, IFNA(XMATCH("PREV_SSB", hdr), 0),
  sortKey, IF(ssbIdx=0, 0, ABS(IFERROR(--CHOOSECOLS(rows, ssbIdx), 0))),

  IF(ROWS(rows)=0,
     "No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel, "")),

  facCol, CHOOSECOLS(d, IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), TAKE(d,0)),

  idxRaw, HSTACK(
    IFNA(XMATCH("CURR_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("CIS_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("CURR_BANK_CODE", hdr), 0),
    IFNA(XMATCH("CURR_CSS", hdr), 0),
    IFNA(XMATCH("CURR_GL_L4", hdr), 0),
    IFNA(XMATCH("CURR_PROD5", hdr), 0),
    IFNA(XMATCH("CURR_STATUS", hdr), 0),
    IFNA(XMATCH("CURR_RBC", hdr), 0),
    IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_GL_BALANCE", hdr), 0)
  ),
  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, CHOOSECOLS(rows, idx),

  ssbIdx, IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
  sortKey, IF(ssbIdx=0, 0, IFERROR(--CHOOSECOLS(rows, ssbIdx), 0)),

  IF(ROWS(rows)=0,
     "No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), ""),

  idxRaw, HSTACK(
    IFNA(XMATCH("CURR_ACCOUNT_NAME", hdr), 0),
    IFNA(XMATCH("CIS_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("FACILITY_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr), 0),
    IFNA(XMATCH("ACCOUNT_KEY", hdr), 0),
    IFNA(XMATCH("CURR_BANK_CODE", hdr), 0),
    IFNA(XMATCH("CURR_CSS", hdr), 0),
    IFNA(XMATCH("CURR_GL_L4", hdr), 0),
    IFNA(XMATCH("CURR_PROD5", hdr), 0),
    IFNA(XMATCH("CURR_STATUS", hdr), 0),
    IFNA(XMATCH("CURR_RBC", hdr), 0),
    IFNA(XMATCH("SSB_FOR_EVENT", hdr), 0),
    IFNA(XMATCH("CURR_GL_BALANCE", hdr), 0)
  ),

  idx, TOROW(FILTER(idxRaw, idxRaw>0)),

  out, IF(rows="","No matching account rows.", CHOOSECOLS(rows, idx)),

  sortKey, IF(rows="", 0, IFERROR(--CHOOSECOLS(rows, XMATCH("SSB_FOR_EVENT", hdr)), 0)),

  IF(rows="","No matching account rows.",
     SORTBY(out, sortKey, -1)
  )
)







=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],
  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  rows, IFERROR(FILTER(d, ISNUMBER(MATCH(facCol, facs, 0))), ""),

  idxRaw, HSTACK(
    XMATCH("CURR_ACCOUNT_NAME", hdr),
    XMATCH("CIS_FOR_EVENT", hdr),
    XMATCH("FACILITY_FOR_EVENT", hdr),
    XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr),
    XMATCH("ACCOUNT_KEY", hdr),
    XMATCH("CURR_BANK_CODE", hdr),
    XMATCH("CURR_CSS", hdr),
    XMATCH("CURR_GL_L4", hdr),
    XMATCH("CURR_PROD5", hdr),
    XMATCH("CURR_STATUS", hdr),
    XMATCH("CURR_RBC", hdr),
    XMATCH("SSB_FOR_EVENT", hdr),
    XMATCH("CURR_GL_BALANCE", hdr)
  ),
  idx, FILTER(idxRaw, ISNUMBER(idxRaw)),

  out, IF(rows="","No matching account rows.", CHOOSECOLS(rows, idx)),

  ssbCol, IFERROR(CHOOSECOLS(rows, XMATCH("SSB_FOR_EVENT", hdr)), 0),

  IF(rows="","No matching account rows.",
     SORTBY(out, ssbCol, -1)
  )
)





=LET(
  d, MoM_Account_Detail,
  hdr, MoM_Account_Detail[#Headers],

  ownerSel, $B$2,

  top, Top30_Engine!$A$7#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  facCol, CHOOSECOLS(d, XMATCH("FACILITY_FOR_EVENT", hdr)),
  keep, ISNUMBER(MATCH(facCol, facs, 0)),

  rows, IFERROR(FILTER(d, keep), ""),

  out, CHOOSECOLS(
        rows,
        XMATCH("CURR_ACCOUNT_NAME", hdr),
        XMATCH("CIS_FOR_EVENT", hdr),
        XMATCH("FACILITY_FOR_EVENT", hdr),
        XMATCH("CURR_ACCOUNT_IDENTIFIER", hdr),
        XMATCH("ACCOUNT_KEY", hdr),
        XMATCH("CURR_BANK_CODE", hdr),
        XMATCH("CURR_CSS", hdr),
        XMATCH("CURR_GL_L4", hdr),
        XMATCH("CURR_PROD5", hdr),
        XMATCH("CURR_STATUS", hdr),
        XMATCH("CURR_RBC", hdr),
        XMATCH("SSB_FOR_EVENT", hdr),
        XMATCH("CURR_GL_BALANCE", hdr)
      ),

  IF(rows="","No matching account rows.",
     SORTBY(out, CHOOSECOLS(out,12), -1)
  )
)






=LET(
  d, MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$8#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  rows, IFERROR(
          FILTER(d,
            (d[OWNER_FOR_EVENT]=ownerSel)*
            (d[MOVEMENT_TYPE]="Downgrade IN (ex-Auto)")*
            ISNUMBER(MATCH(d[FACILITY_FOR_EVENT], facs, 0))
          ),
          ""
        ),

  out, CHOOSECOLS(
        rows,
        XMATCH("CURR_ACCOUNT_NAME", d[#Headers]),
        XMATCH("CIS_FOR_EVENT", d[#Headers]),
        XMATCH("FACILITY_FOR_EVENT", d[#Headers]),
        XMATCH("CURR_ACCOUNT_IDENTIFIER", d[#Headers]),
        XMATCH("ACCOUNT_KEY", d[#Headers]),
        XMATCH("CURR_BANK_CODE", d[#Headers]),
        XMATCH("CURR_CSS", d[#Headers]),
        XMATCH("CURR_GL_L4", d[#Headers]),
        XMATCH("CURR_PROD5", d[#Headers]),
        XMATCH("CURR_STATUS", d[#Headers]),
        XMATCH("CURR_RBC", d[#Headers]),
        XMATCH("SSB_FOR_EVENT", d[#Headers]),
        XMATCH("CURR_GL_BALANCE", d[#Headers])
      ),

  IF(rows="","No matching account rows.",
     SORTBY(out, CHOOSECOLS(out,12), -1)
  )
)














MoM_Account_Detail[CURR_ACCOUNT_NAME],
      MoM_Account_Detail[CIS_FOR_EVENT],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[CURR_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[CURR_BANK_CODE],
      MoM_Account_Detail[CURR_CSS],
      MoM_Account_Detail[CURR_GL_L4],
      MoM_Account_Detail[CURR_PROD5],
      MoM_Account_Detail[CURR_STATUS],
      MoM_Account_Detail[CURR_RBC],
      MoM_Account_Detail[SSB_FOR_EVENT],
      MoM_Account_Detail[CURR_GL_BALANCE]


      MoM_Account_Detail[PREV_ACCOUNT_NAME],
      MoM_Account_Detail[PREV_CIS],
      MoM_Account_Detail[FACILITY_FOR_EVENT],
      MoM_Account_Detail[PREV_ACCOUNT_IDENTIFIER],
      MoM_Account_Detail[ACCOUNT_KEY],
      MoM_Account_Detail[PREV_BANK_CODE],
      MoM_Account_Detail[PREV_CSS],
      MoM_Account_Detail[PREV_GL_L4],
      MoM_Account_Detail[PREV_PROD5],
      MoM_Account_Detail[PREV_STATUS],
      MoM_Account_Detail[PREV_RBC],
      MoM_Account_Detail[PREV_SSB],
      MoM_Account_Detail[PREV_GL_BALANCE],




ACCOUNT_NAME
CIS_CUSTOMER_NUMBER
FACILITY_ID
ACCOUNT_IDENTIFIER
ACCOUNT_KEY
BANK_CODE
CONTRACT_SOURCE_SYSTEM
GL_ACCOUNT_HIER_LEVEL_4
PROD_HIER_LEVEL_5
STATUS_CODE
RBC_CODE
 SOURCE_SYSTEM_BALANCE 
 GL_BALANCE





=LET(
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$8#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  out, FILTER(
        d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]="Downgrade IN (ex-Auto)")*
        ISNUMBER(MATCH(d[Facility_For_Event], facs, 0))
  ),
  SORTBY(out, out[SSB_For_Event], -1)
)



=LET(
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,

  top, Top30_Engine!$A$60#,
  facs, UNIQUE(FILTER(CHOOSECOLS(top,2), CHOOSECOLS(top,4)=ownerSel)),

  out, FILTER(
        d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]="Exit (ex-Auto)")*
        ISNUMBER(MATCH(d[Facility_For_Event], facs, 0))
  ),
  SORTBY(out, ABS(out[MoM_Delta]), -1)
)







=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Exit (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       FILTER(t, keep),
  f_delta, FILTER(delta, keep),

  sorted, SORTBY(f, ABS(IFERROR(--f_delta,0)), -1),
  n, MIN(30, ROWS(sorted)),

  TAKE(sorted, n)
)






=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,     FILTER(t, keep),
  f_ssb, FILTER(ssb, keep),

  sorted, SORTBY(f, IFERROR(--f_ssb,0), -1),
  n, MIN(30, ROWS(sorted)),

  TAKE(sorted, n)
)





=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  sortKey, IFERROR(--f_ssb,0),

  IF(f="",
     "No matches for this owner + movement type.",
     TAKE(SORTBY(f, sortKey, -1), 30)
  )
)





=LET(
  top, Top30_Engine!A8#,
  ownerSel, $B$2,
  ownerCol, 4,
  facCol, 2,
  facs, FILTER(CHOOSECOLS(top, facCol), CHOOSECOLS(top, ownerCol)=ownerSel),
  UNIQUE(facs)
)






=LET(
  top, A8#,
  facList, DROP(CHOOSECOLS(top,2),1),
  d, tbl_MoM_Account_Detail,
  ownerSel, $B$2,
  mvSel, "Downgrade IN (ex-Auto)",
  out, FILTER(d,
        (d[Owner_For_Event]=ownerSel)*
        (d[Movement_Type]=mvSel)*
        ISNUMBER(MATCH(d[Facility_For_Event], facList, 0))
  ),
  SORTBY(out, out[SSB_For_Event], -1)
)






=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  sortKey,
    IF(TRIM(mvSel)="Exit (ex-Auto)",
       ABS(IFERROR(--f_delta,0)),
       IFERROR(--f_ssb,0)
    ),

  IF(f="",
     "No matches for the selected Owner/Movement_Type (or Reviewable <> 1).",
     TAKE(SORTBY(f, sortKey, -1), 30)
  )
)







=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  bank,  CHOOSECOLS(t, XMATCH("BANK_FOR_EVENT", hdr)),
  fac,   CHOOSECOLS(t, XMATCH("FACILITY_FOR_EVENT", hdr)),
  mv,    CHOOSECOLS(t, XMATCH("MOVEMENT_TYPE", hdr)),
  own,   CHOOSECOLS(t, XMATCH("OWNER_FOR_EVENT", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("Sum of SSB_FOR_EVENT", hdr)),
  delta, CHOOSECOLS(t, XMATCH("Sum of MOM_DELTA", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Max of REVIEWABLE_FLAG", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f,       IFERROR(FILTER(t, keep), ""),
  f_ssb,   IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  rankMetric,
    IF(TRIM(mvSel)="Exit (ex-Auto)",
       ABS(IFERROR(--f_delta,0)),
       IFERROR(--f_ssb,0)
    ),

  IF(f="",
     "No matches for the selected Owner/Movement_Type (or Reviewable <> 1).",
     TAKE(SORTBY(HSTACK(f, rankMetric), rankMetric, -1), 30)
  )
)






rankMetric,
IF(
  TRIM(mvSel)="Exit (ex-Auto)",
  ABS(IFERROR(--f_delta,0)),
  IFERROR(--f_ssb,0)
),





=LET(
  t, tbl_Facility_Rollup,
  hdr, tbl_Facility_Rollup[#Headers],

  bank,  CHOOSECOLS(t, XMATCH("Bank_For_Event", hdr)),
  fac,   CHOOSECOLS(t, XMATCH("Facility_For_Event", hdr)),
  own,   CHOOSECOLS(t, XMATCH("Owner_For_Event", hdr)),
  mv,    CHOOSECOLS(t, XMATCH("Movement_Type", hdr)),
  rev,   CHOOSECOLS(t, XMATCH("Reviewable_Flag", hdr)),
  ssb,   CHOOSECOLS(t, XMATCH("SSB_For_Event", hdr)),
  delta, CHOOSECOLS(t, XMATCH("MoM_Delta", hdr)),

  ownerSel, $B$2,
  mvSel,    $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),

  f, IFERROR(FILTER(t, keep), ""),
  f_ssb, IFERROR(FILTER(ssb, keep), ""),
  f_delta, IFERROR(FILTER(delta, keep), ""),

  rankMetric, IF(mvSel="Exit (ex-Auto)", ABS(f_delta), f_ssb),

  IF(f="","No matches for the selected Owner/Movement_Type (or Reviewable_Flag not = 1).",
     TAKE(SORTBY(HSTACK(f, rankMetric), rankMetric, -1), 30)
  )
)






=LET(
  t, tbl_Facility_Rollup,
  bank, CHOOSECOLS(t,1),
  fac,  CHOOSECOLS(t,2),
  own,  CHOOSECOLS(t,3),
  mv,   CHOOSECOLS(t,4),
  rev,  CHOOSECOLS(t,5),
  ssb,  CHOOSECOLS(t,6),
  delta,CHOOSECOLS(t,7),

  ownerSel, $B$2,
  mvSel, $B$3,

  keep, (own=ownerSel)*(mv=mvSel)*(rev>=1),
  f, FILTER(t, keep),

  f_ssb,  FILTER(ssb, keep),
  f_delta,FILTER(delta, keep),

  rankMetric, IF(mvSel="Exit (ex-Auto)", ABS(f_delta), f_ssb),
  sorted, SORTBY(f, rankMetric, -1),
  TAKE(HSTACK(sorted, rankMetric), 30)
)





=LET(
  t, tbl_Facility_Rollup,
  owner, $B$2,
  mv, $B$3,
  f, FILTER(t, (t[Owner_For_Event]=owner)*(t[Movement_Type]=mv)*(t[Reviewable_Flag]>=1)),
  rankMetric, IF(mv="Exit (ex-Auto)", ABS(INDEX(f[MoM_Delta],0)), INDEX(f[SSB_For_Event],0)),
  sorted, SORTBY(f, rankMetric, -1),
  TAKE(HSTACK(sorted, rankMetric), 30)
)







/* ================================== Query 1: MoM_Account_Detail (incl. negatives, charge-offs, status)
   UPDATED:
   - Movement_Type classified at FACILITY level (stamped onto all Account_Key rows)
   - Reviewable_Flag classified at FACILITY level (stamped onto all Account_Key rows)
   - Facility Owner logic with deterministic pick (largest |SSB_For_Event| account), with hard override:
       Daniel gets EVERYTHING where Contract_Source_System = 'INFL10'
   - Presence tests use SUM(ABS(SSB)) to avoid net-to-zero masking
   - Reviewable exposure tests use SUM(positive SSB) as discussed
   Grain of final output remains ACCOUNT_KEY
======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags (account-level) */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags (account-level) */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Pos→Neg Flip'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Neg→Pos Flip'
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Δ'
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Δ'
      ELSE NULL
    END AS Negative_Class

  FROM joined j
),

/* CIS totals (account-level window, as-is) */
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
),

/* Event-scoped fields (same logic you had in final SELECT, moved earlier so we can roll up at facility level) */
event_scoped AS (
  SELECT
    w.*,

    /* Account_Name for the “event” side (curr if exists, else prev) */
    CASE
      WHEN w.has_curr=1 THEN w.Curr_Account_Name
      WHEN w.had_prev=1 THEN w.Prev_Account_Name
      ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
    END AS Account_Name_For_Event,

    /* event scoping */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
      WHEN w.has_curr=1 THEN w.Curr_Bank_Code
      ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
    END AS Bank_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
      WHEN w.has_curr=1 THEN w.Curr_Facility_ID
      ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
    END AS Facility_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
      WHEN w.has_curr=1 THEN w.Curr_CIS
      ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
    END AS CIS_For_Event,

    /* choose event-side CSS/PROD/BANK/RBC for downstream owner logic */
    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CSS
      WHEN w.has_curr=1 THEN w.Curr_CSS
      ELSE COALESCE(w.Curr_CSS, w.Prev_CSS)
    END AS CSS_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_PROD5
      WHEN w.has_curr=1 THEN w.Curr_PROD5
      ELSE COALESCE(w.Curr_PROD5, w.Prev_PROD5)
    END AS PROD5_For_Event,

    CASE
      WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_RBC
      WHEN w.has_curr=1 THEN w.Curr_RBC
      ELSE COALESCE(w.Curr_RBC, w.Prev_RBC)
    END AS RBC_For_Event,

    /* balances */
    (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,

    CASE
      WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
      ELSE COALESCE(w.Prev_SSB,0)
    END AS SSB_For_Event
  FROM with_cis w
),

/* Account-level owner (event-side) with Daniel override moved to the top */
account_owner_event AS (
  SELECT
    e.*,

    CASE
      WHEN e.CSS_For_Event = 'INFL10' THEN 'Daniel'  /* HARD OVERRIDE */
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
      WHEN e.PROD5_For_Event='Business RE Term Loans'
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
      WHEN e.PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
           AND e.Bank_For_Event='L-CIT'
           AND COALESCE(e.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
      WHEN e.Bank_For_Event='L-SVB' THEN 'Eleanor'
      WHEN UPPER(COALESCE(e.RBC_For_Event,''))='R' THEN 'Autochange'
      WHEN e.Bank_For_Event='L-FCB' THEN 'Connor'
      ELSE 'NOT COVERED'
    END AS Owner_Account_For_Event
  FROM event_scoped e
),

/* Rank accounts within facility to pick representative attributes (largest |SSB_For_Event|) */
ranked_in_facility AS (
  SELECT
    a.*,
    ROW_NUMBER() OVER (
      PARTITION BY a.Bank_For_Event, a.Facility_For_Event
      ORDER BY ABS(COALESCE(a.SSB_For_Event,0)) DESC, a.Account_Key
    ) AS rn_fac
  FROM account_owner_event a
),

/* Facility rollup + facility-level classification + facility owner */
facility_rollup AS (
  SELECT
    Bank_For_Event,
    Facility_For_Event,

    /* Presence tests (avoid net-to-zero masking) */
    SUM(ABS(COALESCE(Prev_SSB,0))) AS Fac_Prev_Abs_SSB,
    SUM(ABS(COALESCE(Curr_SSB,0))) AS Fac_Curr_Abs_SSB,

    /* Positive exposure tests (reviewable gating) */
    SUM(CASE WHEN COALESCE(Prev_SSB,0) > 0 THEN COALESCE(Prev_SSB,0) ELSE 0 END) AS Fac_Prev_Pos_SSB,
    SUM(CASE WHEN COALESCE(Curr_SSB,0) > 0 THEN COALESCE(Curr_SSB,0) ELSE 0 END) AS Fac_Curr_Pos_SSB,

    /* Net balances for delta-based “persisting change” */
    SUM(COALESCE(Prev_SSB,0)) AS Fac_Prev_Net_SSB,
    SUM(COALESCE(Curr_SSB,0)) AS Fac_Curr_Net_SSB,

    /* Facility-level auto flags: ANY auto within facility */
    MAX(CASE WHEN UPPER(COALESCE(Prev_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Prev_Auto_Any,
    MAX(CASE WHEN UPPER(COALESCE(Curr_RBC,''))='R' THEN 1 ELSE 0 END) AS Fac_Curr_Auto_Any,

    /* Daniel override: ANY INFL10 in facility => Daniel */
    MAX(CASE WHEN CSS_For_Event='INFL10' THEN 1 ELSE 0 END) AS Fac_INFL10_Any,

    /* Representative attributes from top |SSB_For_Event| row */
    MAX(CASE WHEN rn_fac=1 THEN CIS_For_Event END)         AS Fac_CIS_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN PROD5_For_Event END)       AS Fac_PROD5_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN RBC_For_Event END)         AS Fac_RBC_For_Event,
    MAX(CASE WHEN rn_fac=1 THEN Owner_Account_For_Event END) AS Fac_Owner_From_TopRow,

    /* Representative CIS totals from top row (used in threshold exclusions) */
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Curr_CIS_SSB,0) END) AS Fac_Curr_CIS_SSB,
    MAX(CASE WHEN rn_fac=1 THEN COALESCE(Prev_CIS_SSB,0) END) AS Fac_Prev_CIS_SSB

  FROM ranked_in_facility
  GROUP BY Bank_For_Event, Facility_For_Event
),

facility_classified AS (
  SELECT
    fr.*,

    /* facility presence flags */
    CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Had_Prev,
    CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END AS Fac_Has_Curr,

    /* facility owner for event */
    CASE
      WHEN fr.Fac_INFL10_Any = 1 THEN 'Daniel'
      ELSE COALESCE(fr.Fac_Owner_From_TopRow, 'NOT COVERED')
    END AS Owner_Facility_For_Event,

    /* FACILITY-level Movement_Type */
    CASE
      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
        THEN 'Autochange Downgrade IN'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
        THEN 'Autochange Exit'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange Persisting Balance Changes'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=1
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Autochange No Change'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
        THEN 'Downgrade IN (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
       AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
        THEN 'Exit (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) <> COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'Persisting Balance Changes (ex-Auto)'

      WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
       AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
       AND COALESCE(fr.Fac_Curr_Net_SSB,0) = COALESCE(fr.Fac_Prev_Net_SSB,0)
        THEN 'No Change (ex-Auto)'

      ELSE NULL
    END AS Movement_Type_Facility,

    /* FACILITY-level Reviewable_Flag (stamped down) */
    CASE
      WHEN (
        /* only these two types are review-queued */
        (CASE
           WHEN (
             CASE
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
               THEN 'Downgrade IN (ex-Auto)'
               WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=1
                AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0) > 0 THEN 1 ELSE 0 END)=0
                AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
               THEN 'Exit (ex-Auto)'
               ELSE NULL
             END
           ) IS NOT NULL THEN 1 ELSE 0
         END)=1

        AND (
          /* positive exposure must exist on relevant side */
          ( ( /* Downgrade IN */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Curr_Pos_SSB,0) > 0
            )
            OR
            ( /* Exit */ (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                                   AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                                   AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                                   THEN 1 ELSE 0 END)=1
              AND COALESCE(fr.Fac_Prev_Pos_SSB,0) > 0
            )
          )
        )

        AND (
          /* exclusions (mirror your prior logic, applied at facility rep-level) */
          CASE
            /* Downgrade IN exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND COALESCE(fr.Fac_Curr_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Curr_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END

            /* Exit exclusions */
            WHEN (CASE WHEN (CASE WHEN COALESCE(fr.Fac_Prev_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=1
                           AND (CASE WHEN COALESCE(fr.Fac_Curr_Abs_SSB,0)>0 THEN 1 ELSE 0 END)=0
                           AND COALESCE(fr.Fac_Prev_Auto_Any,0)=0
                      THEN 1 ELSE 0 END)=1
            THEN
              CASE
                WHEN fr.Fac_PROD5_For_Event='Business RE Term Loans'
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 500000 THEN 0
                WHEN fr.Fac_PROD5_For_Event IN ('Business Non-RE Term Loans','Business Commitment Draw')
                     AND fr.Bank_For_Event='L-CIT'
                     AND COALESCE(fr.Fac_Prev_CIS_SSB,0) <= 250000 THEN 0
                WHEN UPPER(COALESCE(fr.Fac_RBC_For_Event,''))='R' THEN 0
                ELSE 1
              END
            ELSE 0
          END = 1
        )
      )
      THEN 1 ELSE 0
    END AS Reviewable_Flag_Facility

  FROM facility_rollup fr
)

/* =========================
   FINAL OUTPUT (ACCOUNT_KEY grain)
   - Movement_Type now = facility-level Movement_Type_Facility
   - Owner_For_Event now = facility-level Owner_Facility_For_Event
   - Reviewable_Flag now = facility-level Reviewable_Flag_Facility
   - Owner_Curr / Owner_Prev also updated so Daniel override is absolute
========================= */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  a.Account_Key,

  /* prev attributes */
  a.Prev_Account_Identifier,
  a.Prev_Facility_ID,
  a.Prev_CIS,
  a.Prev_Account_Name,
  a.Prev_CSS,
  a.Prev_PROD5,
  a.Prev_RBC,
  a.Prev_Status,
  a.Prev_GL_L4,
  a.Prev_Bank_Code,
  a.Prev_SSB,
  a.Prev_GL_Balance,
  a.Prev_CO_MTD,

  /* curr attributes */
  a.Curr_Account_Identifier,
  a.Curr_Facility_ID,
  a.Curr_CIS,
  a.Curr_Account_Name,
  a.Curr_CSS,
  a.Curr_PROD5,
  a.Curr_RBC,
  a.Curr_Status,
  a.Curr_GL_L4,
  a.Curr_Bank_Code,
  a.Curr_SSB,
  a.Curr_GL_Balance,
  a.Curr_CO_MTD,

  /* event-side display fields */
  a.Account_Name_For_Event,
  a.Bank_For_Event,
  a.Facility_For_Event,
  a.CIS_For_Event,

  /* balances */
  a.MoM_Delta,
  a.SSB_For_Event,

  /* FACILITY movement typing */
  fc.Movement_Type_Facility AS Movement_Type,

  /* Owners (Curr / Prev) with Daniel override absolute */
  CASE
    WHEN a.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Curr_PROD5='Business RE Term Loans'
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Curr_Bank_Code='L-CIT'
         AND COALESCE(a.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Curr_RBC='R' THEN 'Autochange'
    WHEN a.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN a.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN a.Prev_PROD5='Business RE Term Loans'
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN a.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND a.Prev_Bank_Code='L-CIT'
         AND COALESCE(a.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN a.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN a.Prev_RBC='R' THEN 'Autochange'
    WHEN a.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* FACILITY owner for event */
  fc.Owner_Facility_For_Event AS Owner_For_Event,

  /* FACILITY reviewable flag */
  fc.Reviewable_Flag_Facility AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  a.Curr_CIS_SSB,
  a.Prev_CIS_SSB,
  a.Negative_Flag,
  a.Negative_Class,
  a.Negative_Flip_Flag

FROM ranked_in_facility a
JOIN facility_classified fc
  ON a.Bank_For_Event = fc.Bank_For_Event
 AND a.Facility_For_Event = fc.Facility_For_Event

/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(a.Prev_SSB,0) = 0 AND COALESCE(a.Curr_SSB,0) = 0)

ORDER BY a.Bank_For_Event, a.Facility_For_Event, a.Account_Key;








Below is my full query for the RC_Code analysis. I was wanting to run the model on one single RC_Code. Can you give me a version that only outputs the analysis for 1 single RC_Code that I will manually input? 

/* ========== RC_Code Anomaly Detection — REG12-only, Thresholded, PBI-safe ========== */
/* Key features:
   - Uses only 12-month regression per RC (no REG36, MA6, MA12, no seasonality)
   - Limits history (min_me) to control runtime
   - Applies exposure_min_for_model on latest balance
   - Adds TOTAL_PORTFOLIO pseudo-RC
   - Outputs PI bands, Severity_0_100, Persistent_Outlier_3of6, Reason_Code
   - Flags Is_Material_Residual_500M for |Residual| >= threshold
*/

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,            -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,   -- >= $1B latest
    500000000.0::FLOAT8                AS material_resid_threshold  -- >= $500M residual
),

/* 1) Base RC-level balances (time filtered) */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b,
       params p
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Portfolio total per month as pseudo-RC */
base_total AS (
  SELECT
    'TOTAL_PORTFOLIO'               AS RC_CODE,
    'Total Loans - Portfolio'       AS RC_DESCRIPTION,
    month_end,
    SUM(bal_num)::FLOAT8            AS bal_num
  FROM base_rc
  GROUP BY month_end
),

/* 3) Combine RC-level + portfolio-level */
base_all AS (
  SELECT * FROM base_rc
  UNION ALL
  SELECT * FROM base_total
),

/* 4) Latest month & latest exposure per RC */
latest_me AS (
  SELECT
    RC_CODE,
    MAX(month_end) AS max_me
  FROM base_all
  GROUP BY RC_CODE
),

latest_exp AS (
  SELECT
    b.RC_CODE,
    b.bal_num AS latest_bal
  FROM base_all b
  JOIN latest_me m
    ON m.RC_CODE = b.RC_CODE
   AND m.max_me  = b.month_end
),

/* 5) RCs that pass exposure threshold */
material_rc AS (
  SELECT
    e.RC_CODE
  FROM latest_exp e
  CROSS JOIN params p
  WHERE e.latest_bal >= p.exposure_min_for_model
),

/* 6) Filter base to material RCs + portfolio */
base AS (
  SELECT b.*
  FROM base_all b
  WHERE b.RC_CODE IN (SELECT RC_CODE FROM material_rc)
),

/* 7) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 8) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 9) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 10) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 11) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 12) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    -- residual distribution stats
    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    -- MoM distribution stats
    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    -- RMSE per RC (for PI bands)
    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 13) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 14) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 15) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 16) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 17) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 18) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  /* Flag big residuals */
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.RC_CODE, r.month_end;





/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE, LAST 12 MONTHS ONLY ========== */

WITH
/* 0) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR(50) AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Find the latest month_end for this RC (Total Loans only) */
rc_max_me AS (
  SELECT
    CAST(MAX(b.END_OF_MONTH_DATE) AS DATE) AS max_me
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.RC_CODE = m.manual_rc_code
),

/* 2) Base RC-level balances — ONLY last 12 months relative to max_me */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN manual_rc m
  CROSS JOIN rc_max_me mx
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.RC_CODE = m.manual_rc_code
    AND CAST(b.END_OF_MONTH_DATE AS DATE) >= ADD_MONTHS(mx.max_me, -11)
    AND CAST(b.END_OF_MONTH_DATE AS DATE) <= mx.max_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 3) Index per RC, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 4) REG12 parameters (computed on these 12 rows) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM idx_tm
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS forecast
  FROM idx_tm l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    f.*,
    t.prev_bal,
    t.pos3_count,

    (f.bal_num - f.forecast)::FLOAT8 AS Resid,
    ABS(f.bal_num - f.forecast)::FLOAT8 AS AbsResid,

    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      ELSE ABS(f.bal_num - t.prev_bal)
    END::FLOAT8 AS MoM_Abs,

    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
      ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(f.bal_num - f.forecast)) OVER (PARTITION BY f.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(f.bal_num - f.forecast)) OVER (PARTITION BY f.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN t.prev_bal IS NULL THEN NULL ELSE ABS(f.bal_num - t.prev_bal) END
    ) OVER (PARTITION BY f.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN t.prev_bal IS NULL THEN NULL ELSE ABS(f.bal_num - t.prev_bal) END
    ) OVER (PARTITION BY f.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN t.prev_bal IS NULL THEN NULL
        WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
        ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
      END
    ) OVER (PARTITION BY f.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN t.prev_bal IS NULL THEN NULL
        WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
        ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
      END
    ) OVER (PARTITION BY f.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (f.bal_num - f.forecast)*(f.bal_num - f.forecast) )
      OVER (PARTITION BY f.RC_CODE)
    ) AS rmse
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 8) P95 AbsResid & MoM_Abs (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 9) Severity */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 10) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 11) Reason_Code */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code
FROM reasoned r
ORDER BY r.month_end;









/* ================================== Query 1: MoM_Account_Detail (incl. negatives, charge-offs, status) @ ACCOUNT_KEY grain ======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives (no SSB>0 filter) */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM NA-pop collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM NA-pop collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + CIS totals + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* ---- Negative logic ---- */
    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      /* 1) Positive → Negative flip */
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Pos→Neg Flip'

      /* 2) Negative → Positive flip */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Neg→Pos Flip'

      /* 3) New negative (no prior exposure, now negative) */
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'

      /* 4) Cleared negative (was negative, now zero) */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'

      /* 5) Persisting negative with delta */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Δ'

      /* 6) Persisting negative, no delta */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Δ'

      ELSE NULL
    END AS Negative_Class

  FROM joined j
  
),
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
)

/* 6) Final projection: includes Account_Name, negative flags, and filters out pure zero rows */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  w.Account_Key,

  /* prev attributes */
  w.Prev_Account_Identifier,
  w.Prev_Facility_ID,
  w.Prev_CIS,
  w.Prev_Account_Name,
  w.Prev_CSS,
  w.Prev_PROD5,
  w.Prev_RBC,
  w.Prev_Status,
  w.Prev_GL_L4,
  w.Prev_Bank_Code,
  w.Prev_SSB,
  w.Prev_GL_Balance,
  w.Prev_CO_MTD,

  /* curr attributes */
  w.Curr_Account_Identifier,
  w.Curr_Facility_ID,
  w.Curr_CIS,
  w.Curr_Account_Name,
  w.Curr_CSS,
  w.Curr_PROD5,
  w.Curr_RBC,
  w.Curr_Status,
  w.Curr_GL_L4,
  w.Curr_Bank_Code,
  w.Curr_SSB,
  w.Curr_GL_Balance,
  w.Curr_CO_MTD,

  /* Account_Name for the “event” side (curr if exists, else prev) */
  CASE
    WHEN w.has_curr=1 THEN w.Curr_Account_Name
    WHEN w.had_prev=1 THEN w.Prev_Account_Name
    ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
  END AS Account_Name_For_Event,

  /* event scoping (bank/facility/CIS for event) */
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
    WHEN w.has_curr=1 THEN w.Curr_Bank_Code
    ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
  END AS Bank_For_Event,
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
    WHEN w.has_curr=1 THEN w.Curr_Facility_ID
    ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
  END AS Facility_For_Event,
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
    WHEN w.has_curr=1 THEN w.Curr_CIS
    ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
  END AS CIS_For_Event,

  /* balances */
  (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,
  CASE
    WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
    ELSE COALESCE(w.Prev_SSB,0)
  END AS SSB_For_Event,

  /* movement typing */
  CASE
    WHEN w.had_prev=0 AND w.has_curr=1 AND w.curr_auto=1 THEN 'Autochange Downgrade IN'
    WHEN w.had_prev=1 AND w.has_curr=0 AND w.prev_auto=1 THEN 'Autochange Exit'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.prev_auto=1 AND w.curr_auto=1
         AND COALESCE(w.Curr_SSB,0)<>COALESCE(w.Prev_SSB,0) THEN 'Autochange Persisting Balance Changes'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.prev_auto=1 AND w.curr_auto=1
         AND COALESCE(w.Curr_SSB,0)= COALESCE(w.Prev_SSB,0) THEN 'Autochange No Change'
    WHEN w.had_prev=0 AND w.has_curr=1 AND w.curr_auto=0 THEN 'Downgrade IN (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=0 AND w.prev_auto=0 THEN 'Exit (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.curr_auto=0
         AND COALESCE(w.Curr_SSB,0)<>COALESCE(w.Prev_SSB,0) THEN 'Persisting Balance Changes (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.curr_auto=0
         AND COALESCE(w.Curr_SSB,0)= COALESCE(w.Prev_SSB,0) THEN 'No Change (ex-Auto)'
    ELSE NULL
  END AS Movement_Type,

  /* Owners w/ CIS thresholds */
  CASE
    WHEN w.Curr_PROD5='Business RE Term Loans'
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN w.Curr_PROD5='Business RE Term Loans'
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN w.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN w.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN w.Curr_RBC='R' THEN 'Autochange'
    WHEN w.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN w.Prev_PROD5='Business RE Term Loans'
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN w.Prev_PROD5='Business RE Term Loans'
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN w.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN w.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN w.Prev_RBC='R' THEN 'Autochange'
    WHEN w.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* Owner for event (for bridges / Top 30 by owner) */
  CASE
    WHEN w.has_curr=1 THEN
      CASE
        WHEN w.Curr_PROD5='Business RE Term Loans'
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
        WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
        WHEN w.Curr_PROD5='Business RE Term Loans'
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
        WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
        WHEN w.Curr_CSS='INFL10' THEN 'Daniel'
        WHEN w.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
        WHEN w.Curr_RBC='R' THEN 'Autochange'
        WHEN w.Curr_Bank_Code='L-FCB' THEN 'Connor'
        ELSE 'NOT COVERED'
      END
    WHEN w.had_prev=1 THEN
      CASE
        WHEN w.Prev_PROD5='Business RE Term Loans'
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
        WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
        WHEN w.Prev_PROD5='Business RE Term Loans'
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
        WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
        WHEN w.Prev_CSS='INFL10' THEN 'Daniel'
        WHEN w.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
        WHEN w.Prev_RBC='R' THEN 'Autochange'
        WHEN w.Prev_Bank_Code='L-FCB' THEN 'Connor'
        ELSE 'NOT COVERED'
      END
    ELSE 'NOT COVERED'
  END AS Owner_For_Event,

  /* reviewable flag */
  CASE
    WHEN (
      (Movement_Type IN ('Downgrade IN (ex-Auto)','Exit (ex-Auto)')) AND
      (
        (Movement_Type='Downgrade IN (ex-Auto)' AND COALESCE(w.Curr_SSB,0) > 0) OR
        (Movement_Type='Exit (ex-Auto)'         AND COALESCE(w.Prev_SSB,0) > 0)
      ) AND
      (
        CASE
          WHEN Movement_Type='Downgrade IN (ex-Auto)' THEN
            CASE
              WHEN w.Curr_PROD5='Business RE Term Loans' AND w.Curr_Bank_Code='L-CIT' AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 0
              WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw') AND w.Curr_Bank_Code='L-CIT' AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 0
              WHEN w.Curr_RBC='R' THEN 0
              ELSE 1
            END
          WHEN Movement_Type='Exit (ex-Auto)' THEN
            CASE
              WHEN w.Prev_PROD5='Business RE Term Loans' AND w.Prev_Bank_Code='L-CIT' AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 0
              WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw') AND w.Prev_Bank_Code='L-CIT' AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 0
              WHEN w.Prev_RBC='R' THEN 0
              ELSE 1
            END
          ELSE 0
        END = 1
      )
    )
    THEN 1 ELSE 0
  END AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  w.Curr_CIS_SSB,
  w.Prev_CIS_SSB,
  w.Negative_Flag,
  w.Negative_Class,
  w.Negative_Flip_Flag

FROM with_cis w
/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(w.Prev_SSB,0) = 0 AND COALESCE(w.Curr_SSB,0) = 0)
ORDER BY Bank_For_Event, Facility_For_Event, Account_Key;









/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE (no thresholds) ========== */

WITH
/* 0) Minimal parameter: history window only */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me   -- last 72 months only
),

/* 0b) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Base RC-level balances (time filtered) — ONLY the selected RC_CODE */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN params p
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
    AND b.RC_CODE = m.manual_rc_code
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 3) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 4) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 8) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 9) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 10) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 11) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 12) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 13) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code
FROM reasoned r
ORDER BY r.month_end;











/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE (manual input) ========== */

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,                 -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,  -- kept for reference (not enforced)
    500000000.0::FLOAT8                AS material_resid_threshold -- >= $500M residual
),

/* 0b) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Base RC-level balances (time filtered) — ONLY the selected RC_CODE */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN params p
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
    AND b.RC_CODE = m.manual_rc_code
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 3) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 4) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 8) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 9) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 10) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 11) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 12) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 13) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.month_end;







/* ========== RC_Code Anomaly Detection — REG12-only, Thresholded, PBI-safe ========== */
/* Key features:
   - Uses only 12-month regression per RC (no REG36, MA6, MA12, no seasonality)
   - Limits history (min_me) to control runtime
   - Applies exposure_min_for_model on latest balance
   - Adds TOTAL_PORTFOLIO pseudo-RC
   - Outputs PI bands, Severity_0_100, Persistent_Outlier_3of6, Reason_Code
   - Flags Is_Material_Residual_500M for |Residual| >= threshold
*/

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,            -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,   -- >= $1B latest
    500000000.0::FLOAT8                AS material_resid_threshold  -- >= $500M residual
),

/* 1) Base RC-level balances (time filtered) */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b,
       params p
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Portfolio total per month as pseudo-RC */
base_total AS (
  SELECT
    'TOTAL_PORTFOLIO'               AS RC_CODE,
    'Total Loans - Portfolio'       AS RC_DESCRIPTION,
    month_end,
    SUM(bal_num)::FLOAT8            AS bal_num
  FROM base_rc
  GROUP BY month_end
),

/* 3) Combine RC-level + portfolio-level */
base_all AS (
  SELECT * FROM base_rc
  UNION ALL
  SELECT * FROM base_total
),

/* 4) Latest month & latest exposure per RC */
latest_me AS (
  SELECT
    RC_CODE,
    MAX(month_end) AS max_me
  FROM base_all
  GROUP BY RC_CODE
),

latest_exp AS (
  SELECT
    b.RC_CODE,
    b.bal_num AS latest_bal
  FROM base_all b
  JOIN latest_me m
    ON m.RC_CODE = b.RC_CODE
   AND m.max_me  = b.month_end
),

/* 5) RCs that pass exposure threshold */
material_rc AS (
  SELECT
    e.RC_CODE
  FROM latest_exp e
  CROSS JOIN params p
  WHERE e.latest_bal >= p.exposure_min_for_model
),

/* 6) Filter base to material RCs + portfolio */
base AS (
  SELECT b.*
  FROM base_all b
  WHERE b.RC_CODE IN (SELECT RC_CODE FROM material_rc)
),

/* 7) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 8) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 9) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 10) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 11) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 12) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    -- residual distribution stats
    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    -- MoM distribution stats
    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    -- RMSE per RC (for PI bands)
    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 13) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 14) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 15) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 16) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 17) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 18) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  /* Flag big residuals */
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.RC_CODE, r.month_end;






https://www.instagram.com/icestat_analytics?igsh=MW4xdTc3dWlsazBzag%3D%3D&utm_source=qr




import os
import pandas as pd
import numpy as np

pd.set_option("display.float_format", "${:,.2f}".format)

# --- USER INPUT ---
FILE_PATH  = "loan_extract.xlsx"    # or "loan_extract.csv" | "loan_extract.xlsb"
SHEET_NAME = 0
DATE_COL   = "END_OF_MONTH_DATE"
BANK_COL   = "BANK_CODE"
GL_COL     = "GL_ACCOUNT_HIER_LEVEL_4"
BAL_COL    = "GL_BALANCE"
MOM_$      = "MoM_GL_$"
MOM_PCT    = "MoM_GL_PCT"

REQUIRED = [DATE_COL, BANK_COL, GL_COL, BAL_COL, MOM_$, MOM_PCT]

# --- Load ---
def read_any(path, sheet=None, parse_dates=None):
    ext = os.path.splitext(path)[1].lower()
    if ext == ".csv":
        return pd.read_csv(path, parse_dates=parse_dates, infer_datetime_format=True)
    elif ext in [".xlsx", ".xls"]:
        return pd.read_excel(path, sheet_name=sheet, parse_dates=parse_dates, engine="openpyxl")
    elif ext == ".xlsb":
        return pd.read_excel(path, sheet_name=sheet, parse_dates=parse_dates, engine="pyxlsb")
    else:
        raise ValueError(f"Unsupported file extension: {ext}")

df = read_any(FILE_PATH, sheet=SHEET_NAME, parse_dates=[DATE_COL])
df.columns = [c.strip() for c in df.columns]

# --- Checks and cleanup ---
missing = [c for c in REQUIRED if c not in df.columns]
if missing:
    raise KeyError(f"Missing required columns: {missing}")

df[DATE_COL] = pd.to_datetime(df[DATE_COL], errors="coerce").dt.date
df[BAL_COL] = pd.to_numeric(df[BAL_COL], errors="coerce").fillna(0)
df[MOM_$] = pd.to_numeric(df[MOM_$], errors="coerce")
df[MOM_PCT] = pd.to_numeric(df[MOM_PCT], errors="coerce")

# --- Find the last 2 month-ends ---
all_dates = sorted([d for d in df[DATE_COL].dropna().unique()])
if len(all_dates) < 2:
    raise ValueError("Less than 2 distinct month-end dates in data.")
prior_eom, current_eom = all_dates[-2], all_dates[-1]

# --- Subsets for the two months ---
cur = df[df[DATE_COL] == current_eom].copy()
prev = df[df[DATE_COL] == prior_eom].copy()

# --- Join current and prior balances ---
joined = pd.merge(
    prev[[BANK_COL, GL_COL, BAL_COL]],
    cur[[BANK_COL, GL_COL, BAL_COL, MOM_$, MOM_PCT]],
    on=[BANK_COL, GL_COL],
    how="outer",
    suffixes=("_prior", "_current")
)

joined = joined.fillna(0)
joined.rename(columns={
    f"{BAL_COL}_prior":   "Prior_GL_BALANCE",
    f"{BAL_COL}_current": "Current_GL_BALANCE",
    MOM_$:                "MoM_GL_$",
    MOM_PCT:              "MoM_GL_PCT"
}, inplace=True)

# --- Display sample ---
print(f"Prior EOM:   {prior_eom}")
print(f"Current EOM: {current_eom}")
print("\n=== Sample joined table ===")
display(joined.head(20))

# --- Optional: pivot by GL then Bank ---
pivot_current = cur.pivot_table(
    index=GL_COL, columns=BANK_COL, values=BAL_COL, aggfunc="sum", fill_value=0
)
pivot_prior = prev.pivot_table(
    index=GL_COL, columns=BANK_COL, values=BAL_COL, aggfunc="sum", fill_value=0
)

print("\n=== Current month matrix (rows=GL, cols=Bank) ===")
display(pivot_current.head(10))
print("\n=== Prior month matrix (rows=GL, cols=Bank) ===")
display(pivot_prior.head(10))

# --- Save outputs ---
os.makedirs("outputs", exist_ok=True)
joined.to_csv("outputs/GL_balances_MoM_joined.csv", index=False)
pivot_current.to_csv("outputs/GL_balances_current_matrix.csv")
pivot_prior.to_csv("outputs/GL_balances_prior_matrix.csv")

print("\nFiles saved in ./outputs:")
print(" - GL_balances_MoM_joined.csv")
print(" - GL_balances_current_matrix.csv")
print(" - GL_balances_prior_matrix.csv")
