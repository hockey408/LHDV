/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE, LAST 12 MONTHS ONLY ========== */

WITH
/* 0) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR(50) AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Find the latest month_end for this RC (Total Loans only) */
rc_max_me AS (
  SELECT
    CAST(MAX(b.END_OF_MONTH_DATE) AS DATE) AS max_me
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.RC_CODE = m.manual_rc_code
),

/* 2) Base RC-level balances — ONLY last 12 months relative to max_me */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN manual_rc m
  CROSS JOIN rc_max_me mx
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.RC_CODE = m.manual_rc_code
    AND CAST(b.END_OF_MONTH_DATE AS DATE) >= ADD_MONTHS(mx.max_me, -11)
    AND CAST(b.END_OF_MONTH_DATE AS DATE) <= mx.max_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 3) Index per RC, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 4) REG12 parameters (computed on these 12 rows) */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM idx_tm
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS forecast
  FROM idx_tm l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    f.*,
    t.prev_bal,
    t.pos3_count,

    (f.bal_num - f.forecast)::FLOAT8 AS Resid,
    ABS(f.bal_num - f.forecast)::FLOAT8 AS AbsResid,

    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      ELSE ABS(f.bal_num - t.prev_bal)
    END::FLOAT8 AS MoM_Abs,

    CASE
      WHEN t.prev_bal IS NULL THEN NULL
      WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
      ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(f.bal_num - f.forecast)) OVER (PARTITION BY f.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(f.bal_num - f.forecast)) OVER (PARTITION BY f.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN t.prev_bal IS NULL THEN NULL ELSE ABS(f.bal_num - t.prev_bal) END
    ) OVER (PARTITION BY f.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN t.prev_bal IS NULL THEN NULL ELSE ABS(f.bal_num - t.prev_bal) END
    ) OVER (PARTITION BY f.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN t.prev_bal IS NULL THEN NULL
        WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
        ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
      END
    ) OVER (PARTITION BY f.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN t.prev_bal IS NULL THEN NULL
        WHEN ABS(t.prev_bal) < 1.0 THEN ABS(f.bal_num - t.prev_bal) / 1.0
        ELSE ABS(f.bal_num - t.prev_bal) / ABS(t.prev_bal)
      END
    ) OVER (PARTITION BY f.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (f.bal_num - f.forecast)*(f.bal_num - f.forecast) )
      OVER (PARTITION BY f.RC_CODE)
    ) AS rmse
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 8) P95 AbsResid & MoM_Abs (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 9) Severity */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 10) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 11) Reason_Code */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code
FROM reasoned r
ORDER BY r.month_end;









/* ================================== Query 1: MoM_Account_Detail (incl. negatives, charge-offs, status) @ ACCOUNT_KEY grain ======================================= */

WITH latest_curr AS (
  SELECT MAX(End_of_Month_Date) AS curr_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE Non_Accrual_Flag = 'Y'
),
latest_prev AS (
  SELECT MAX(End_of_Month_Date) AS prev_eom
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB, latest_curr
  WHERE End_of_Month_Date < (SELECT curr_eom FROM latest_curr)
    AND Non_Accrual_Flag = 'Y'
),
params AS (
  SELECT
    (SELECT curr_eom FROM latest_curr) AS curr_eom,
    (SELECT prev_eom FROM latest_prev) AS prev_eom,
    CURRENT_TIMESTAMP                 AS query_run_ts
),

/* 1) Bank map + normalize keys; NA pop; keep positives & negatives (no SSB>0 filter) */
base AS (
  SELECT
    End_of_Month_Date,
    UPPER(TRIM(Account_Key))         AS Account_Key,
    UPPER(TRIM(Account_Identifier))  AS Account_Identifier,
    UPPER(TRIM(Facility_ID))         AS Facility_ID,
    UPPER(TRIM(CIS_Customer_Number)) AS CIS_Customer_Number,
    Account_Name,
    Contract_Source_System,
    PROD_HIER_LEVEL_5,
    RBC_Code,
    Status_Code_Description,
    GL_ACCOUNT_HIER_LEVEL_4,
    GL_ACCOUNT_CODE,
    Non_Accrual_Flag,
    Source_System_Balance,
    GL_Balance,
    Available_Balance,
    Borrower_Risk_Rating,
    PD_Grade,
    Days_Past_Due,
    SOURCE_SYSTEM_CHARGE_OFF_MTD AS CO_MTD,
    CASE
      WHEN Contract_Source_System IN ('AL','CU','LN','LO','UU','US','TA','LJ','CF','FRDS-EXCPTN','FRDS_EXCPTN')
        THEN 'L-SVB'
      WHEN Contract_Source_System = 'ALL'
           AND GL_ACCOUNT_CODE IN
           ('1051872','1061833','1041344','1041211','1041345','1041364','1041210',
            '1042127','1042213','1042048','1042368','1042408','1042409','1042424',
            '1100001','1142067','1042886','1043008')
        THEN 'L-SVB'
      WHEN Contract_Source_System IN ('ADJ','ALL','ALS','FDR','FISERV','GGSL','GL','LEA','PCFS','PSL','SBO')
        THEN 'L-FCB'
      WHEN Contract_Source_System IN ('ACAR01','ACAR01-EXCPTN','HUBFSV','HUBFSV-EXCPTN',
                                      'INFL05','INFL05-EXCPTN','INFL10','INFL10-EXCPTN',
                                      'LNIQ01','LNIQ01-EXCPTN','MSP001','SBO001','SBO001-EXCPTN',
                                      'STKY01','STKY01-EXCPTN','STRAO1','STRAO1-EXCPTN','STRAT1','STRAT1-EXCPTN')
        THEN 'L-CIT'
      ELSE 'NULL-Need to Research'
    END AS Bank_Code
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB
  WHERE End_of_Month_Date IN ((SELECT prev_eom FROM params),(SELECT curr_eom FROM params))
    AND Non_Accrual_Flag = 'Y'
    AND GL_ACCOUNT_HIER_LEVEL_4 IN ('Total Loans','Lns Held for Sale')
),

/* 2) Prior EOM NA-pop collapsed to 1 row / ACCOUNT_KEY */
prev_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Prev_Account_Identifier,
    MAX(Facility_ID)               AS Prev_Facility_ID,
    MAX(CIS_Customer_Number)       AS Prev_CIS,
    MAX(Account_Name)              AS Prev_Account_Name,
    MAX(Contract_Source_System)    AS Prev_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Prev_PROD5,
    MAX(RBC_Code)                  AS Prev_RBC,
    MAX(Status_Code_Description)   AS Prev_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Prev_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Prev_GL_Code,
    MAX(Bank_Code)                 AS Prev_Bank_Code,
    SUM(Source_System_Balance)     AS Prev_SSB,
    SUM(GL_Balance)                AS Prev_GL_Balance,
    MAX(Available_Balance)         AS Prev_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Prev_BRR,
    MAX(PD_Grade)                  AS Prev_PD_Grade,
    MAX(Days_Past_Due)             AS Prev_DPD,
    SUM(CO_MTD)                    AS Prev_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT prev_eom FROM params)
  GROUP BY Account_Key
),

/* 3) Current EOM NA-pop collapsed to 1 row / ACCOUNT_KEY */
curr_norm AS (
  SELECT
    Account_Key,
    MAX(Account_Identifier)        AS Curr_Account_Identifier,
    MAX(Facility_ID)               AS Curr_Facility_ID,
    MAX(CIS_Customer_Number)       AS Curr_CIS,
    MAX(Account_Name)              AS Curr_Account_Name,
    MAX(Contract_Source_System)    AS Curr_CSS,
    MAX(PROD_HIER_LEVEL_5)         AS Curr_PROD5,
    MAX(RBC_Code)                  AS Curr_RBC,
    MAX(Status_Code_Description)   AS Curr_Status,
    MAX(GL_ACCOUNT_HIER_LEVEL_4)   AS Curr_GL_L4,
    MAX(GL_ACCOUNT_CODE)           AS Curr_GL_Code,
    MAX(Bank_Code)                 AS Curr_Bank_Code,
    SUM(Source_System_Balance)     AS Curr_SSB,
    SUM(GL_Balance)                AS Curr_GL_Balance,
    MAX(Available_Balance)         AS Curr_Available_Balance,
    MAX(Borrower_Risk_Rating)      AS Curr_BRR,
    MAX(PD_Grade)                  AS Curr_PD_Grade,
    MAX(Days_Past_Due)             AS Curr_DPD,
    SUM(CO_MTD)                    AS Curr_CO_MTD
  FROM base
  WHERE End_of_Month_Date = (SELECT curr_eom FROM params)
  GROUP BY Account_Key
),

/* 4) Join months @ ACCOUNT_KEY */
joined AS (
  SELECT
    COALESCE(c.Account_Key, p.Account_Key) AS Account_Key,

    /* prev side */
    p.Prev_Account_Identifier,
    p.Prev_Facility_ID,
    p.Prev_CIS,
    p.Prev_Account_Name,
    p.Prev_CSS,
    p.Prev_PROD5,
    p.Prev_RBC,
    p.Prev_Status,
    p.Prev_GL_L4,
    p.Prev_GL_Code,
    p.Prev_Bank_Code,
    p.Prev_SSB,
    p.Prev_GL_Balance,
    p.Prev_Available_Balance,
    p.Prev_BRR,
    p.Prev_PD_Grade,
    p.Prev_DPD,
    p.Prev_CO_MTD,

    /* curr side */
    c.Curr_Account_Identifier,
    c.Curr_Facility_ID,
    c.Curr_CIS,
    c.Curr_Account_Name,
    c.Curr_CSS,
    c.Curr_PROD5,
    c.Curr_RBC,
    c.Curr_Status,
    c.Curr_GL_L4,
    c.Curr_GL_Code,
    c.Curr_Bank_Code,
    c.Curr_SSB,
    c.Curr_GL_Balance,
    c.Curr_Available_Balance,
    c.Curr_BRR,
    c.Curr_PD_Grade,
    c.Curr_DPD,
    c.Curr_CO_MTD
  FROM curr_norm c
  FULL OUTER JOIN prev_norm p
    ON c.Account_Key = p.Account_Key
),

/* 5) Presence/auto/charge-off flags + CIS totals + negative flags */
with_flags AS (
  SELECT
    j.*,

    /* presence flags */
    CASE WHEN j.Prev_SSB IS NULL THEN 0 ELSE 1 END AS had_prev,
    CASE WHEN j.Curr_SSB IS NULL THEN 0 ELSE 1 END AS has_curr,

    /* autochange flags */
    CASE WHEN UPPER(COALESCE(j.Prev_RBC,'')) = 'R' THEN 1 ELSE 0 END AS prev_auto,
    CASE WHEN UPPER(COALESCE(j.Curr_RBC,'')) = 'R' THEN 1 ELSE 0 END AS curr_auto,

    /* charge-off flags (still based on CO_MTD) */
    CASE WHEN COALESCE(j.Curr_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Curr_CO_MTD_Flag,
    CASE WHEN COALESCE(j.Prev_CO_MTD,0) > 0 THEN 1 ELSE 0 END AS Prev_CO_MTD_Flag,

    /* ---- Negative logic ---- */
    /* convenience aliases */
    COALESCE(j.Prev_SSB,0) AS Prev_SSB_NZ,
    COALESCE(j.Curr_SSB,0) AS Curr_SSB_NZ,

    /* any negative in either month */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) < 0
        OR COALESCE(j.Curr_SSB,0) < 0
      THEN 1 ELSE 0
    END AS Negative_Flag,

    /* explicit flip flag: pos -> neg OR neg -> pos */
    CASE
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0 THEN 1
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0 THEN 1
      ELSE 0
    END AS Negative_Flip_Flag,

    /* detailed negative classification */
    CASE
      /* 1) Positive → Negative flip */
      WHEN COALESCE(j.Prev_SSB,0) > 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: Pos→Neg Flip'

      /* 2) Negative → Positive flip */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) > 0
        THEN 'Neg: Neg→Pos Flip'

      /* 3) New negative (no prior exposure, now negative) */
      WHEN COALESCE(j.Prev_SSB,0) = 0 AND COALESCE(j.Curr_SSB,0) < 0
        THEN 'Neg: New (No Prior)'

      /* 4) Cleared negative (was negative, now zero) */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) = 0
        THEN 'Neg: Cleared to Zero'

      /* 5) Persisting negative with delta */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) <> COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting Δ'

      /* 6) Persisting negative, no delta */
      WHEN COALESCE(j.Prev_SSB,0) < 0 AND COALESCE(j.Curr_SSB,0) < 0
           AND COALESCE(j.Curr_SSB,0) = COALESCE(j.Prev_SSB,0)
        THEN 'Neg: Persisting No Δ'

      ELSE NULL
    END AS Negative_Class

  FROM joined j
  
),
with_cis AS (
  SELECT
    f.*,
    SUM(COALESCE(f.Curr_SSB,0)) OVER (PARTITION BY f.Curr_CIS) AS Curr_CIS_SSB,
    SUM(COALESCE(f.Prev_SSB,0)) OVER (PARTITION BY f.Prev_CIS) AS Prev_CIS_SSB
  FROM with_flags f
)

/* 6) Final projection: includes Account_Name, negative flags, and filters out pure zero rows */
SELECT
  (SELECT query_run_ts FROM params) AS QUERY_RUN_TIMESTAMP,
  (SELECT curr_eom FROM params)     AS CURR_EOM,
  (SELECT prev_eom FROM params)     AS PREV_EOM,

  w.Account_Key,

  /* prev attributes */
  w.Prev_Account_Identifier,
  w.Prev_Facility_ID,
  w.Prev_CIS,
  w.Prev_Account_Name,
  w.Prev_CSS,
  w.Prev_PROD5,
  w.Prev_RBC,
  w.Prev_Status,
  w.Prev_GL_L4,
  w.Prev_Bank_Code,
  w.Prev_SSB,
  w.Prev_GL_Balance,
  w.Prev_CO_MTD,

  /* curr attributes */
  w.Curr_Account_Identifier,
  w.Curr_Facility_ID,
  w.Curr_CIS,
  w.Curr_Account_Name,
  w.Curr_CSS,
  w.Curr_PROD5,
  w.Curr_RBC,
  w.Curr_Status,
  w.Curr_GL_L4,
  w.Curr_Bank_Code,
  w.Curr_SSB,
  w.Curr_GL_Balance,
  w.Curr_CO_MTD,

  /* Account_Name for the “event” side (curr if exists, else prev) */
  CASE
    WHEN w.has_curr=1 THEN w.Curr_Account_Name
    WHEN w.had_prev=1 THEN w.Prev_Account_Name
    ELSE COALESCE(w.Curr_Account_Name, w.Prev_Account_Name)
  END AS Account_Name_For_Event,

  /* event scoping (bank/facility/CIS for event) */
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Bank_Code
    WHEN w.has_curr=1 THEN w.Curr_Bank_Code
    ELSE COALESCE(w.Curr_Bank_Code, w.Prev_Bank_Code)
  END AS Bank_For_Event,
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_Facility_ID
    WHEN w.has_curr=1 THEN w.Curr_Facility_ID
    ELSE COALESCE(w.Curr_Facility_ID, w.Prev_Facility_ID)
  END AS Facility_For_Event,
  CASE
    WHEN w.had_prev=1 AND w.has_curr=0 THEN w.Prev_CIS
    WHEN w.has_curr=1 THEN w.Curr_CIS
    ELSE COALESCE(w.Curr_CIS, w.Prev_CIS)
  END AS CIS_For_Event,

  /* balances */
  (COALESCE(w.Curr_SSB,0) - COALESCE(w.Prev_SSB,0)) AS MoM_Delta,
  CASE
    WHEN w.has_curr=1 THEN COALESCE(w.Curr_SSB,0)
    ELSE COALESCE(w.Prev_SSB,0)
  END AS SSB_For_Event,

  /* movement typing */
  CASE
    WHEN w.had_prev=0 AND w.has_curr=1 AND w.curr_auto=1 THEN 'Autochange Downgrade IN'
    WHEN w.had_prev=1 AND w.has_curr=0 AND w.prev_auto=1 THEN 'Autochange Exit'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.prev_auto=1 AND w.curr_auto=1
         AND COALESCE(w.Curr_SSB,0)<>COALESCE(w.Prev_SSB,0) THEN 'Autochange Persisting Balance Changes'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.prev_auto=1 AND w.curr_auto=1
         AND COALESCE(w.Curr_SSB,0)= COALESCE(w.Prev_SSB,0) THEN 'Autochange No Change'
    WHEN w.had_prev=0 AND w.has_curr=1 AND w.curr_auto=0 THEN 'Downgrade IN (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=0 AND w.prev_auto=0 THEN 'Exit (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.curr_auto=0
         AND COALESCE(w.Curr_SSB,0)<>COALESCE(w.Prev_SSB,0) THEN 'Persisting Balance Changes (ex-Auto)'
    WHEN w.had_prev=1 AND w.has_curr=1 AND w.curr_auto=0
         AND COALESCE(w.Curr_SSB,0)= COALESCE(w.Prev_SSB,0) THEN 'No Change (ex-Auto)'
    ELSE NULL
  END AS Movement_Type,

  /* Owners w/ CIS thresholds */
  CASE
    WHEN w.Curr_PROD5='Business RE Term Loans'
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN w.Curr_PROD5='Business RE Term Loans'
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Curr_Bank_Code='L-CIT'
         AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN w.Curr_CSS='INFL10' THEN 'Daniel'
    WHEN w.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN w.Curr_RBC='R' THEN 'Autochange'
    WHEN w.Curr_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Curr,

  CASE
    WHEN w.Prev_PROD5='Business RE Term Loans'
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
    WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
    WHEN w.Prev_PROD5='Business RE Term Loans'
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
    WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
         AND w.Prev_Bank_Code='L-CIT'
         AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
    WHEN w.Prev_CSS='INFL10' THEN 'Daniel'
    WHEN w.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
    WHEN w.Prev_RBC='R' THEN 'Autochange'
    WHEN w.Prev_Bank_Code='L-FCB' THEN 'Connor'
    ELSE 'NOT COVERED'
  END AS Owner_Prev,

  /* Owner for event (for bridges / Top 30 by owner) */
  CASE
    WHEN w.has_curr=1 THEN
      CASE
        WHEN w.Curr_PROD5='Business RE Term Loans'
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) > 500000 THEN 'Samya'
        WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) > 250000 THEN 'Casey'
        WHEN w.Curr_PROD5='Business RE Term Loans'
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
        WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Curr_Bank_Code='L-CIT'
             AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
        WHEN w.Curr_CSS='INFL10' THEN 'Daniel'
        WHEN w.Curr_Bank_Code='L-SVB' THEN 'Eleanor'
        WHEN w.Curr_RBC='R' THEN 'Autochange'
        WHEN w.Curr_Bank_Code='L-FCB' THEN 'Connor'
        ELSE 'NOT COVERED'
      END
    WHEN w.had_prev=1 THEN
      CASE
        WHEN w.Prev_PROD5='Business RE Term Loans'
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) > 500000 THEN 'Samya'
        WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) > 250000 THEN 'Casey'
        WHEN w.Prev_PROD5='Business RE Term Loans'
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 'Not Covered; Under $500k; Samya'
        WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw')
             AND w.Prev_Bank_Code='L-CIT'
             AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 'Not Covered; Under $250k; Casey'
        WHEN w.Prev_CSS='INFL10' THEN 'Daniel'
        WHEN w.Prev_Bank_Code='L-SVB' THEN 'Eleanor'
        WHEN w.Prev_RBC='R' THEN 'Autochange'
        WHEN w.Prev_Bank_Code='L-FCB' THEN 'Connor'
        ELSE 'NOT COVERED'
      END
    ELSE 'NOT COVERED'
  END AS Owner_For_Event,

  /* reviewable flag */
  CASE
    WHEN (
      (Movement_Type IN ('Downgrade IN (ex-Auto)','Exit (ex-Auto)')) AND
      (
        (Movement_Type='Downgrade IN (ex-Auto)' AND COALESCE(w.Curr_SSB,0) > 0) OR
        (Movement_Type='Exit (ex-Auto)'         AND COALESCE(w.Prev_SSB,0) > 0)
      ) AND
      (
        CASE
          WHEN Movement_Type='Downgrade IN (ex-Auto)' THEN
            CASE
              WHEN w.Curr_PROD5='Business RE Term Loans' AND w.Curr_Bank_Code='L-CIT' AND COALESCE(w.Curr_CIS_SSB,0) <= 500000 THEN 0
              WHEN w.Curr_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw') AND w.Curr_Bank_Code='L-CIT' AND COALESCE(w.Curr_CIS_SSB,0) <= 250000 THEN 0
              WHEN w.Curr_RBC='R' THEN 0
              ELSE 1
            END
          WHEN Movement_Type='Exit (ex-Auto)' THEN
            CASE
              WHEN w.Prev_PROD5='Business RE Term Loans' AND w.Prev_Bank_Code='L-CIT' AND COALESCE(w.Prev_CIS_SSB,0) <= 500000 THEN 0
              WHEN w.Prev_PROD5 IN ('Business Non-RE Term Loans','Business Commitment Draw') AND w.Prev_Bank_Code='L-CIT' AND COALESCE(w.Prev_CIS_SSB,0) <= 250000 THEN 0
              WHEN w.Prev_RBC='R' THEN 0
              ELSE 1
            END
          ELSE 0
        END = 1
      )
    )
    THEN 1 ELSE 0
  END AS Reviewable_Flag,

  /* expose CIS totals + negative flags */
  w.Curr_CIS_SSB,
  w.Prev_CIS_SSB,
  w.Negative_Flag,
  w.Negative_Class,
  w.Negative_Flip_Flag

FROM with_cis w
/* filter out rows where both prev and curr SSB are exactly zero */
WHERE NOT (COALESCE(w.Prev_SSB,0) = 0 AND COALESCE(w.Curr_SSB,0) = 0)
ORDER BY Bank_For_Event, Facility_For_Event, Account_Key;









/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE (no thresholds) ========== */

WITH
/* 0) Minimal parameter: history window only */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me   -- last 72 months only
),

/* 0b) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Base RC-level balances (time filtered) — ONLY the selected RC_CODE */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN params p
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
    AND b.RC_CODE = m.manual_rc_code
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 3) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 4) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 8) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 9) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 10) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 11) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 12) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 13) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code
FROM reasoned r
ORDER BY r.month_end;











/* ========== RC_Code Anomaly Detection — SINGLE RC_CODE (manual input) ========== */

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,                 -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,  -- kept for reference (not enforced)
    500000000.0::FLOAT8                AS material_resid_threshold -- >= $500M residual
),

/* 0b) Manual RC selection (EDIT THIS) */
manual_rc AS (
  SELECT
    'RC123456'::VARCHAR AS manual_rc_code   -- <<< MANUALLY INPUT YOUR RC_CODE HERE
),

/* 1) Base RC-level balances (time filtered) — ONLY the selected RC_CODE */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b
  CROSS JOIN params p
  CROSS JOIN manual_rc m
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
    AND b.RC_CODE = m.manual_rc_code
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base_rc b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 3) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 4) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 5) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 6) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 7) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 8) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 9) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 10) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 11) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 12) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 13) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.month_end;







/* ========== RC_Code Anomaly Detection — REG12-only, Thresholded, PBI-safe ========== */
/* Key features:
   - Uses only 12-month regression per RC (no REG36, MA6, MA12, no seasonality)
   - Limits history (min_me) to control runtime
   - Applies exposure_min_for_model on latest balance
   - Adds TOTAL_PORTFOLIO pseudo-RC
   - Outputs PI bands, Severity_0_100, Persistent_Outlier_3of6, Reason_Code
   - Flags Is_Material_Residual_500M for |Residual| >= threshold
*/

WITH
/* 0) Parameters */
params AS (
  SELECT
    ADD_MONTHS(CURRENT_DATE, -72)::DATE AS min_me,            -- last 72 months only
    1000000000.0::FLOAT8               AS exposure_min_for_model,   -- >= $1B latest
    500000000.0::FLOAT8                AS material_resid_threshold  -- >= $500M residual
),

/* 1) Base RC-level balances (time filtered) */
base_rc AS (
  SELECT
    b.RC_CODE,
    b.RC_DESCRIPTION,
    CAST(b.END_OF_MONTH_DATE AS DATE)    AS month_end,
    SUM(b.SOURCE_SYSTEM_BALANCE)::FLOAT8 AS bal_num
  FROM V_SECURE_PORTFOLIO_DETAIL_LOANHUB b,
       params p
  WHERE b.SOURCE_SYSTEM_BALANCE IS NOT NULL
    AND b.GL_ACCOUNT_HIER_LEVEL_4 = 'Total Loans'
    AND b.END_OF_MONTH_DATE >= p.min_me
  GROUP BY b.RC_CODE, b.RC_DESCRIPTION, CAST(b.END_OF_MONTH_DATE AS DATE)
),

/* 2) Portfolio total per month as pseudo-RC */
base_total AS (
  SELECT
    'TOTAL_PORTFOLIO'               AS RC_CODE,
    'Total Loans - Portfolio'       AS RC_DESCRIPTION,
    month_end,
    SUM(bal_num)::FLOAT8            AS bal_num
  FROM base_rc
  GROUP BY month_end
),

/* 3) Combine RC-level + portfolio-level */
base_all AS (
  SELECT * FROM base_rc
  UNION ALL
  SELECT * FROM base_total
),

/* 4) Latest month & latest exposure per RC */
latest_me AS (
  SELECT
    RC_CODE,
    MAX(month_end) AS max_me
  FROM base_all
  GROUP BY RC_CODE
),

latest_exp AS (
  SELECT
    b.RC_CODE,
    b.bal_num AS latest_bal
  FROM base_all b
  JOIN latest_me m
    ON m.RC_CODE = b.RC_CODE
   AND m.max_me  = b.month_end
),

/* 5) RCs that pass exposure threshold */
material_rc AS (
  SELECT
    e.RC_CODE
  FROM latest_exp e
  CROSS JOIN params p
  WHERE e.latest_bal >= p.exposure_min_for_model
),

/* 6) Filter base to material RCs + portfolio */
base AS (
  SELECT b.*
  FROM base_all b
  WHERE b.RC_CODE IN (SELECT RC_CODE FROM material_rc)
),

/* 7) Index per RC, tmax, prev_bal, 3-month activity */
idx AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (PARTITION BY b.RC_CODE ORDER BY b.month_end) AS t
  FROM base b
),

idx_tm AS (
  SELECT
    i.*,
    MAX(i.t) OVER (PARTITION BY i.RC_CODE) AS tmax,
    LAG(i.bal_num) OVER (PARTITION BY i.RC_CODE ORDER BY i.month_end) AS prev_bal,
    SUM(CASE WHEN i.bal_num > 0 THEN 1 ELSE 0 END) OVER (
      PARTITION BY i.RC_CODE
      ORDER BY i.month_end
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS pos3_count
  FROM idx i
),

/* 8) 12-month evaluation window */
last12 AS (
  SELECT *
  FROM idx_tm
  WHERE t >= tmax - 11
),

/* 9) REG12 parameters per RC */
reg12_params AS (
  SELECT
    RC_CODE,
    COUNT(*)               AS n12,
    SUM(t)::FLOAT8         AS sumx12,
    SUM(bal_num)::FLOAT8   AS sumy12,
    SUM(t*bal_num)::FLOAT8 AS sumxy12,
    SUM(t*t)::FLOAT8       AS sumx2_12
  FROM last12
  GROUP BY RC_CODE
),

/* 10) REG12 fitted values on last12 window */
reg12_fit AS (
  SELECT
    l.RC_CODE,
    l.month_end,
    l.RC_DESCRIPTION,
    l.bal_num,
    l.t,
    CASE
      WHEN p.n12 >= 2 AND (p.n12*p.sumx2_12 - p.sumx12*p.sumx12) <> 0
      THEN
        ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
          / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12)) * l.t
        + (
            (p.sumy12/p.n12)
            - ((p.n12*p.sumxy12 - p.sumx12*p.sumy12)
               / (p.n12*p.sumx2_12 - p.sumx12*p.sumx12))
              * (p.sumx12/p.n12)
          )
      ELSE NULL
    END::FLOAT8 AS fc_reg12
  FROM last12 l
  JOIN reg12_params p USING (RC_CODE)
),

/* 11) Attach prev_bal & pos3_count to forecasts */
fits_ready AS (
  SELECT
    f.RC_CODE,
    f.month_end,
    f.RC_DESCRIPTION,
    f.bal_num,
    t.prev_bal,
    t.pos3_count,
    f.fc_reg12 AS forecast
  FROM reg12_fit f
  JOIN idx_tm t
    ON t.RC_CODE   = f.RC_CODE
   AND t.month_end = f.month_end
),

/* 12) Residuals, MoM, per-RC stats & RMSE */
enriched AS (
  SELECT
    x.*,
    (x.bal_num - x.forecast)::FLOAT8 AS Resid,
    ABS(x.bal_num - x.forecast)::FLOAT8 AS AbsResid,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      ELSE ABS(x.bal_num - x.prev_bal)
    END::FLOAT8 AS MoM_Abs,
    CASE
      WHEN x.prev_bal IS NULL THEN NULL
      WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
      ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
    END::FLOAT8 AS MoM_Pct_Abs,

    -- residual distribution stats
    AVG(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS mean_abs_resid,
    STDDEV_SAMP(ABS(x.bal_num - x.forecast)) OVER (PARTITION BY x.RC_CODE) AS sd_abs_resid,

    -- MoM distribution stats
    AVG(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_abs,
    STDDEV_SAMP(
      CASE WHEN x.prev_bal IS NULL THEN NULL ELSE ABS(x.bal_num - x.prev_bal) END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_abs,

    AVG(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS mean_mom_pct,

    STDDEV_SAMP(
      CASE
        WHEN x.prev_bal IS NULL THEN NULL
        WHEN ABS(x.prev_bal) < 1.0 THEN ABS(x.bal_num - x.prev_bal) / 1.0
        ELSE ABS(x.bal_num - x.prev_bal) / ABS(x.prev_bal)
      END
    ) OVER (PARTITION BY x.RC_CODE) AS sd_mom_pct,

    -- RMSE per RC (for PI bands)
    SQRT(
      AVG( (x.bal_num - x.forecast)*(x.bal_num - x.forecast) )
      OVER (PARTITION BY x.RC_CODE)
    ) AS rmse
  FROM fits_ready x
),

/* 13) Z-scores */
with_z AS (
  SELECT
    e.*,
    CASE
      WHEN e.sd_abs_resid IS NULL OR e.sd_abs_resid = 0 THEN 0
      ELSE (e.AbsResid - e.mean_abs_resid) / e.sd_abs_resid
    END::FLOAT8 AS Z_Resid,
    CASE
      WHEN e.sd_mom_abs IS NULL OR e.sd_mom_abs = 0 THEN 0
      ELSE (e.MoM_Abs - e.mean_mom_abs) / e.sd_mom_abs
    END::FLOAT8 AS Z_MoM_Abs,
    CASE
      WHEN e.sd_mom_pct IS NULL OR e.sd_mom_pct = 0 THEN 0
      ELSE (e.MoM_Pct_Abs - e.mean_mom_pct) / e.sd_mom_pct
    END::FLOAT8 AS Z_MoM_Pct
  FROM enriched e
),

/* 14) P95 AbsResid & MoM_Abs per RC (for severity scaling) */
p95_abs AS (
  SELECT RC_CODE, MIN(AbsResid) AS p95_abs_resid
  FROM (
    SELECT
      RC_CODE,
      AbsResid,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY AbsResid) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                     AS n
    FROM with_z
    WHERE AbsResid IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

p95_mom AS (
  SELECT RC_CODE, MIN(MoM_Abs) AS p95_mom_abs
  FROM (
    SELECT
      RC_CODE,
      MoM_Abs,
      ROW_NUMBER() OVER (PARTITION BY RC_CODE ORDER BY MoM_Abs) AS rn,
      COUNT(*)    OVER (PARTITION BY RC_CODE)                   AS n
    FROM with_z
    WHERE MoM_Abs IS NOT NULL
  ) q
  WHERE rn >= CEIL(0.95 * n)
  GROUP BY RC_CODE
),

/* 15) Severity raw */
sev_raw AS (
  SELECT
    z.*,
    (
      0.25 * ( z.AbsResid / NULLIF(p95a.p95_abs_resid,0) )
      + 0.65 * ABS(z.Z_Resid)
      + 0.07 * ABS(z.Z_MoM_Abs)
      + 0.03 * ( z.MoM_Abs / NULLIF(p95m.p95_mom_abs,0) )
    )::FLOAT8 AS Severity_Raw
  FROM with_z z
  LEFT JOIN p95_abs p95a ON p95a.RC_CODE = z.RC_CODE
  LEFT JOIN p95_mom p95m ON p95m.RC_CODE = z.RC_CODE
),

/* 16) Severity scaled 0–100 */
sev_scaled AS (
  SELECT
    s.*,
    ROUND(
      100.0 * (1.0 - EXP(
        - CASE
            WHEN s.Severity_Raw IS NULL OR s.Severity_Raw < 0 THEN 0
            ELSE s.Severity_Raw
          END
      )),
      0
    )::INTEGER AS Severity_0_100
  FROM sev_raw s
),

/* 17) Persistent outlier: 3 of last 6 months >= 70 */
pers AS (
  SELECT
    x.*,
    SUM(CASE WHEN x.Severity_0_100 >= 70 THEN 1 ELSE 0 END) OVER (
      PARTITION BY x.RC_CODE
      ORDER BY x.month_end
      ROWS BETWEEN 5 PRECEDING AND CURRENT ROW
    ) AS outlier_6m_sum
  FROM sev_scaled x
),

pers_flag AS (
  SELECT
    p.*,
    CASE WHEN p.outlier_6m_sum >= 3 THEN 1 ELSE 0 END AS Persistent_Outlier_3of6
  FROM pers p
),

/* 18) Reason_Code based on residual vs MoM signals */
reasoned AS (
  SELECT
    p.*,
    CASE
      WHEN ABS(p.Z_Resid) >=
           CASE
             WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= ABS(COALESCE(p.MoM_Abs,0.0))
               THEN ABS(COALESCE(p.Z_MoM_Abs,0.0))
             ELSE ABS(COALESCE(p.MoM_Abs,0.0))
           END
        THEN 'Residual spike vs model'
      WHEN ABS(COALESCE(p.Z_MoM_Abs,0.0)) >= 2
        THEN 'Unusual MoM swing'
      WHEN p.MoM_Abs IS NOT NULL
           AND pm.p95_mom_abs IS NOT NULL
           AND p.MoM_Abs > pm.p95_mom_abs
        THEN 'Large absolute MoM'
      ELSE 'Mixed'
    END AS Reason_Code
  FROM pers_flag p
  LEFT JOIN p95_mom pm ON pm.RC_CODE = p.RC_CODE
)

SELECT
  r.RC_CODE,
  r.RC_DESCRIPTION,
  r.month_end,
  'REG12'                 AS Best_Model,
  r.forecast              AS Forecast_Selected,
  r.bal_num               AS Actual,
  r.Resid,
  r.AbsResid,
  r.MoM_Abs,
  r.MoM_Pct_Abs,
  r.Z_Resid,
  r.Z_MoM_Abs,
  r.Z_MoM_Pct,
  r.rmse,
  (r.forecast - 1.96 * r.rmse)::FLOAT8 AS PI_Lo,
  (r.forecast + 1.96 * r.rmse)::FLOAT8 AS PI_Hi,
  r.Severity_0_100,
  r.Persistent_Outlier_3of6,
  r.Reason_Code,
  /* Flag big residuals */
  CASE
    WHEN ABS(r.Resid) >= p.material_resid_threshold THEN 1
    ELSE 0
  END AS Is_Material_Residual_500M
FROM reasoned r
CROSS JOIN params p
ORDER BY r.RC_CODE, r.month_end;






https://www.instagram.com/icestat_analytics?igsh=MW4xdTc3dWlsazBzag%3D%3D&utm_source=qr




import os
import pandas as pd
import numpy as np

pd.set_option("display.float_format", "${:,.2f}".format)

# --- USER INPUT ---
FILE_PATH  = "loan_extract.xlsx"    # or "loan_extract.csv" | "loan_extract.xlsb"
SHEET_NAME = 0
DATE_COL   = "END_OF_MONTH_DATE"
BANK_COL   = "BANK_CODE"
GL_COL     = "GL_ACCOUNT_HIER_LEVEL_4"
BAL_COL    = "GL_BALANCE"
MOM_$      = "MoM_GL_$"
MOM_PCT    = "MoM_GL_PCT"

REQUIRED = [DATE_COL, BANK_COL, GL_COL, BAL_COL, MOM_$, MOM_PCT]

# --- Load ---
def read_any(path, sheet=None, parse_dates=None):
    ext = os.path.splitext(path)[1].lower()
    if ext == ".csv":
        return pd.read_csv(path, parse_dates=parse_dates, infer_datetime_format=True)
    elif ext in [".xlsx", ".xls"]:
        return pd.read_excel(path, sheet_name=sheet, parse_dates=parse_dates, engine="openpyxl")
    elif ext == ".xlsb":
        return pd.read_excel(path, sheet_name=sheet, parse_dates=parse_dates, engine="pyxlsb")
    else:
        raise ValueError(f"Unsupported file extension: {ext}")

df = read_any(FILE_PATH, sheet=SHEET_NAME, parse_dates=[DATE_COL])
df.columns = [c.strip() for c in df.columns]

# --- Checks and cleanup ---
missing = [c for c in REQUIRED if c not in df.columns]
if missing:
    raise KeyError(f"Missing required columns: {missing}")

df[DATE_COL] = pd.to_datetime(df[DATE_COL], errors="coerce").dt.date
df[BAL_COL] = pd.to_numeric(df[BAL_COL], errors="coerce").fillna(0)
df[MOM_$] = pd.to_numeric(df[MOM_$], errors="coerce")
df[MOM_PCT] = pd.to_numeric(df[MOM_PCT], errors="coerce")

# --- Find the last 2 month-ends ---
all_dates = sorted([d for d in df[DATE_COL].dropna().unique()])
if len(all_dates) < 2:
    raise ValueError("Less than 2 distinct month-end dates in data.")
prior_eom, current_eom = all_dates[-2], all_dates[-1]

# --- Subsets for the two months ---
cur = df[df[DATE_COL] == current_eom].copy()
prev = df[df[DATE_COL] == prior_eom].copy()

# --- Join current and prior balances ---
joined = pd.merge(
    prev[[BANK_COL, GL_COL, BAL_COL]],
    cur[[BANK_COL, GL_COL, BAL_COL, MOM_$, MOM_PCT]],
    on=[BANK_COL, GL_COL],
    how="outer",
    suffixes=("_prior", "_current")
)

joined = joined.fillna(0)
joined.rename(columns={
    f"{BAL_COL}_prior":   "Prior_GL_BALANCE",
    f"{BAL_COL}_current": "Current_GL_BALANCE",
    MOM_$:                "MoM_GL_$",
    MOM_PCT:              "MoM_GL_PCT"
}, inplace=True)

# --- Display sample ---
print(f"Prior EOM:   {prior_eom}")
print(f"Current EOM: {current_eom}")
print("\n=== Sample joined table ===")
display(joined.head(20))

# --- Optional: pivot by GL then Bank ---
pivot_current = cur.pivot_table(
    index=GL_COL, columns=BANK_COL, values=BAL_COL, aggfunc="sum", fill_value=0
)
pivot_prior = prev.pivot_table(
    index=GL_COL, columns=BANK_COL, values=BAL_COL, aggfunc="sum", fill_value=0
)

print("\n=== Current month matrix (rows=GL, cols=Bank) ===")
display(pivot_current.head(10))
print("\n=== Prior month matrix (rows=GL, cols=Bank) ===")
display(pivot_prior.head(10))

# --- Save outputs ---
os.makedirs("outputs", exist_ok=True)
joined.to_csv("outputs/GL_balances_MoM_joined.csv", index=False)
pivot_current.to_csv("outputs/GL_balances_current_matrix.csv")
pivot_prior.to_csv("outputs/GL_balances_prior_matrix.csv")

print("\nFiles saved in ./outputs:")
print(" - GL_balances_MoM_joined.csv")
print(" - GL_balances_current_matrix.csv")
print(" - GL_balances_prior_matrix.csv")
